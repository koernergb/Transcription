 All right, welcome back to the E370 discussions. This week we're doing a bunch of project one related things. So the conceptual basis behind project one, which covers the entire LC2K ISA and then a couple of implementation things that we can look at today. So let's get started. This is the winter 22 semester. So if you're watching this in winter 22, these are the things that are upcoming. Homework one today and project one A do in three days. This semester all the homeworks we do on Mondays or Tuesdays and all the projects we'll be doing Thursdays. So the next couple of weeks we're going to have some sort of project thing do every Thursday. So make sure to stay on top of that. But for now, project one A is to think to focus on. And I think combined project one S and M would take longer than one A. So if you haven't started that, now's the time to do it. All right. So our goal today is to look at the conceptual basis for an ISA. So ISA that stands for Instruction Set Architecture. And so we have this ISA called LC2K that we've created specifically for this class. It was created I think four decades ago around 1980. Specifically for XB70. And it allows us to take a really basic example and generalize it to all the major steps of building an ISA in just one semester. And so project one is going to break that into three parts. First, actually getting what we would call code into machine readable code, then running that code like an actual program, and then actually being able to write programs for this ISA. And so that's going to be project one M. But that should also include some test cases that you write for projects one A and S and future projects. So that's what we're doing today. So ISA, so far in lecture, may have been just a very high level term. But in one sentence, an ISA is a set of instructions, which is why it's called an Instruction Set Architecture. But more than just those instructions, it tells us how those instructions move around data. In order to move around data, we have to hold different places for data. And so for LC2K, that's going to include registers. We have eight of them, and there are going to be 32 bits in LC2K. We also have 6536 memory locations, which are also going to be 32 bits, which we're going to call a word in LC2K. And each of those addresses, which is different from what's in the memory location, is going to be 16 bits. A couple of the things just about where data can belong in LC2K. We have data and instructions in the same memory. So that'll be really important for project one S, because if you go to a .fill, once you turn that into machine code, you can't tell if it was originally a .fill or an instruction. But if your PC is at that location, you have to interpret it as an instruction. So that's going to possibly make some things difficult, but maybe make some other things easier. And then there is one other place where we can store data, technically. And that is our PC, our program counter. Essentially, a pointer, a memory address to the instruction that we're currently executing. So LC2K can use instructions to access all the registers, memory locations, and the PC. And that's going to allow us to run any of our programs. So Sunny here is going to point out a couple peculiarities about our instructions, and we'll get into project one A, related things. Yeah. So what we have here is the list of all the instructions that are supported by the LC2K ISA. And so I encourage you guys to check this out in your own time. It takes a little bit of time to fully digest your capabilities and the types of instructions that you're going to use. But before we really get into using them, I do want to talk about a couple instructions that people tend to struggle with, and talk about how they're used and how they work under the hood. So the add and or instructions are pretty straightforward instructions. They perform the different bitwise or different operations on the target registers, and they apply them to a destination register. The load and store instructions are also very similar in that they perform accesses to memory, and they can modify memory and registers based on the parameters that are passed to them. The BQ instruction is one of the ones that I think I'm going to spend a little bit more time on right here, because I think people tend to struggle with it. So the BQ instruction kind of means branch of equals to instruction. And so the BQ instruction, I'm going to see if I can add to the Q. BQ instruction takes three parameters. The first parameter is going to be a register. I'm going to be referring to this as register A. The second parameter is going to be another register. It's also going to be referred to as register B. And the last parameter is going to be what I'm going to refer to as the offset field. So this is a really powerful instruction because it allows us to change our PC based on the values of certain things and registers. So branching is the practice of changing my program counter. And so if we want to branch of equals to, essentially what we're going to want to do is we're going to access the value that's stored in register A. So let's say that the value that was stored inside register A was five. And we access the value that's stored inside register B. And let's say that's also five. At that point, we perform a comparison operation. So L2K only supports the quality comparison. And that's what BQ is. And so if these values are equals to each other, then we're going to execute what's called a branch. If they're not equals to each other. So instead of both them being five, one of them are six, for example, then essentially we just do nothing. We move our program counter onto the next instruction and we essentially perform no additional operation. However, if we are equals to, our program counter kind of will change. And in the formula that you'll see that we'll use throughout this course for BQ is that PC plus one plus offset is the destination. So what does that mean? Right? So the program counter to recap is just essentially a place in memory that stores a pointer to what instruction I'm currently executing. So if my BQ instruction was on line five, then my program counter at that point, because we are in a word addressable architecture, will be five as well. But let's say that I want to change my PC to 10. Essentially, my destination, my desired destination is 10. I want to write an instruction that checks registers, you know, A and B. And if the values inside those registers are the same, will change my PC to that destination. So line 10. Well, the value that goes in that third field is not going to be 10, because the third parameter is not the absolute line number. It's the relative line number. So it's where the instruction is relative to the current PC. And so if I did want to calculate it. So let's say going back to my example, we are going to assume that our PC is five. So we're going to five plus one plus the offset is equal to 10, which is our destination. And so we can calculate our offset by subtracting five plus one from 10. And so in this example, our offset would be four. So one of the key things to note with the branching instructions is that it is relative, right? It's not going to be the third field is not going to be an absolute view. The other instruction that I've seen people get confused with a lot of the time is the Joller instruction. So this stands for jump in link register. So Joller instruction takes just two arguments. And both of these arguments are going to be registers, right? They're going to be registers A and registers B. So prior to this, the way I like to think of this is I have this instruction also changes my program counter. Similar to the branching instruction, but unlike the branching instruction, it's a non-conditional jump. So I'm not going to check for a quality within any registers. I am just going to jump regardless. In addition to that, we're also going to do one thing that I'm going to get to in just a second. So the first register A stores the instruction that I'm going to try to jump to. So this is absolute, right? So if the instruction I'm trying to jump to is online 10, I would want to store the value 10 inside register A. So I might do that by, for example, doing load 0A and then if I had a label that I'd fill with 10 on it, that would achieve what I want. So what that first register does is it tells us where to jump to. Well, you might be thinking, well, what's really the purpose of that second register? I like to think of that second register as almost like a bookmark or a breadcrumb. And so what it allows us to do is if we were to jump to an instruction, it allows us to save our spot, right? Save our old PC so that perhaps later in the program, I can come back to it. So the value that gets assigned to register B. So register B's value is going to change. We don't really care about what was in it beforehand. We're going to assign something to it. And so the value that gets assigned to register B is going to be PC plus one. And so if my model of execution looked like, let's say the very first line is zero here. And then I followed it with a jowler with registers, you know, A, B. And then I had a bunch of, let's say I had a halt instruction right below the jowler. And then I had a bunch of lines and then my line 10, right? Well, what's going to happen is we're going to load the 10th line into the register A. We're going to jump to that. And we're going to save. So our PC here is one. So the value that's going to be stored inside register B is going to be equal to two. And so I'm going to jump to this instruction down here. And I'm going to follow them sequentially. But let's say I want to come back to the instruction that I was at. I want to come back to instruction to, or I want to come back to the point of code that called the jowler. On the flip side, I could have a jowler here that instead of having register, you know, A and B, if I set my destination register to the old kind of like the bookmark register here. So I don't really care about this register here. That's just kind of if I want to jump back to that spot I could. But the important part is that using jowler and using that second register gives me the ability to jump to a spot and code and then come back. And so that's going to be really useful in the context of functions where you can have like code that's going to be repeated. And so you could jump to that segment of code and then you could jump back to whatever code that called it. And so that's a very useful technique and that reflects kind of oftentimes what happens in other ISAs. So you will see this in like for example, number seven in the homework. And so that's something to consider as you go into that. Halt and no op instructions are fairly simple as well. Halt instructions kind of just end the program and no op instructions don't do anything. Awesome. Okay, let's talk about kind of focusing on project 1a. How do we represent these instructions? Because we talked about you know, the different op codes and the different fields that they take. But as we've discussed in class, when it comes down to it, all of our representations for code for our ISAs are turned into machine code, which is just numbers. Right. And so for LC2K, the size of each instruction that was kind of like determined beforehand is 32 bits. Each instruction is 32 bits regardless of which op code it is. So what matters is where do we encode the parts of the instruction within that those 30 bits, 32 bits that I have. So because I have eight op codes, I'm only going to need three bits to represent all eight of those. We talked about that last time with you know, two to the three being late. Similarly for the both the registers, we're going to have three bits to represent each of those. But the other field that we were didn't spend too much time talking about earlier was the offsets. So you'll note that in each of these instructions, we kind of have the 16 bit field that's changing. So sometimes, you know, like in this example right here, that's fully unused in other cases, such as our type instructions and i-type instructions, we are using it for different purposes. So recall that our type instructions are added in more instructions. And so there three parameters are three registers, right. And so that third register, what's going to be called the destination register, is just encoded at the very tail end. And so you might be asking like why who kind of decided that this would be the way things are. So the design of an ISA is kind of an iterative process. And you'll notice that within the LC2K ISA, we have a lot of these fields that kind of say unused. Within a real, I don't say real ISA, but perhaps an ISA that you would more conventionally see in perhaps your your MacBook or your Windows machine or your Linux machine, it's very rare to see like fully unused bits. And the reason is is because ideally, I would be, I want to encode as many instructions as possible. We're not going to focus on that. What we're going to focus on is what we have. We're trying to have it very simple. And so the part that I think that people get confused about is this difference between the R type instructions and the i-type instructions. So you'll note that for both of these examples, we are kind of reusing those last 16 bits. You notice that where the offset is in the i-type instruction, the destination register is in the R type instruction. So something to consider when you're working through Project 1A is the way that you treat those last 16 bits is going to be determined by the type of op-cup that you run. And so those are some things to think about as you go forward. Note that like those fields are just completely unused for J type and op-type instructions because I don't really have a third parameter, right? Or in the case of op-type instructions, I don't even have a second parameter. I just have my op-code. I think you want to add me? It's all good. Yeah, I think one thing about that idea of reusing that bit field, that 16-bit bit field at the end. That'll make things really easy in Project 1S when you're essentially decoding the machine code and trying to figure out if it's the destination register for an R type or an offset for an i-type, you can handle them the same way when it comes to Project 1S because all these bits, bits 15 through 3 for R type instructions right here, are going to be completely zeros. So when you see unused, that means zero. So if they're all zeros and we know that a number with a bunch of leading zeros is the same as whatever the number was, we can just treat them the same way. We could treat it almost as a 16-bit number. One other thing I do want to point out that's not on here. We also have our directives and other ISAs have more directives, but in LCTK we just have one directive and it's a dot fill. This is not an instruction. We call it a directive because it directs the assembler to stick some value into a memory location instead of calculating it like an instruction, just literally copy paste. And that is going to be one thing that we can do in Project 1S. And beyond just numbers, we can treat this value field just like any of the offsets from the i-type instructions, specifically LWSW, but we'll see more on what we can do with that in this next slide. Yeah, so let's talk a little bit more specifically about Project 1A and labels. So in those examples that I was showing you earlier, we kind of were using numbers to represent everything. But one really nice thing about LCTK is that you don't really need to calculate or count each line number. I'm sure that you'd find that annoying if you had to, if I wanted to jump to x instruction, if I had to count all the lines to it and then choose that number. So what LCTK offers us is labels. Labels appear on the very left side of an instruction. And what they allow us to do is resolve what a line number is or kind of like refer to a certain line number. And so while we do have labels in LCTK, when we are transforming the assembly language to machine code, we can't actually like encode the labels as such. And so what we have to do is kind of this process of translating the labels into numbers. However, this makes the Project 1A implementation just still marginally more difficult. And it kind of shapes the way that we have to go about encoding it. And so let's take a look at an incredibly short program that I'm just going to spin up right here. Let's say I had an instruction at 012 and then I had load 03, I'm going to have a label 5. And then I'm going to declare the label here. So when it's on the left side, it's the declaration. And then I'm just going to put a directive to fill number 5 there. That's just a very short concise LCTK program that I just spun up. Well, if I were to just write my Project 1A implementation to go straight down the instructions in a linear order, what you'll find is that if I were to look at this, I would be able to encode this successfully. But if I got to the second line, right, without looking forward. Right. So at this point, I don't even know that the label or the doc they'll exist, right. And I ran into the label 5, I would be very confused because I was like, I have never declared this label before. So our suggestion for perhaps how you should implement this is to kind of go about it in two passes. So instead of just having this one pass where I go down the code, instead, we're going to go through in two passes. So in that first pass, all we're going to do just a few simple things. So one thing we could do is you could handle errors. But we're not, I'm not going to focus on that part right now. The main purpose of that first pass is to discover where the labels are. So in this case, our label is on the second line. Right. So you're going to want to kind of create some form of data structure to save these labels and save the lines that they occur at. That way, on my second pass, when I go through and I encode each of these instructions. So that first instruction doesn't have any labels. So it's you know, still going to be a fairly simple one. But on the second one, when I run into that 5, I can reference that data structure that I generated in that first pass to discover that my label occurs at line 2. So note that for like load instructions, we use absolute labels. So the value that would be replaced with this would be 5. Or sorry, would be line 2. And so I would encode that load instruction as if the three parameters I'd receive were 0, 3 and 2. Some important things to note in the process is again that branching instructions are relative. And so if that load instruction were perhaps instead of branching instruction, the value that would be encoded would not be a 2 and would rather be referring back to that form that I discussed earlier, relative to where that branching instruction occurred. Yeah. I think so things to consider as you're walking through the process. Some things that I've seen that are helpful are like some students will go about implementing their first pass and then just iterate through whatever data structure they have and run out where the each label occurs. And that's a good step in ensuring that like your first pass works before you even go about encoding your second pass. Some other things to consider is to I highly encourage you to write your own test cases before fully relying on the autograder. If you're getting something wrong on the autograder, chances are you could without spending too much time think of a test case that would kind of catch your own box. So definitely something to consider. So that first pass as I talked about the output that you want to desire is essentially is to generate a data structure. That second pass we are going to print to a file. So the input parameters that your program receives is the name of an input file and the name of an output file. So I believe in the StarGer code that we provide you we generate a file pointer. And so the function that you want to be looking at is going to be fprintf. And what that allows you to do is simpler similar to printf that we discussed last time is it allows you to instead of printing to the standard cf which is what you often see it will print that output directly into the file. And so that's kind of the desired output that you're going to be doing in pass 2 which is you're going to be printing all of it like each singular decimal number for each instruction straight to that file pointer. It looks like you want to add something. Go ahead. Oh yeah this is when you when you're debugging your first pass your code will look something like this just so that you can print out essentially a map from your labels to your addresses. But going along with testing we'll we'll talk about testing more on the next slide. But what we don't talk about much is error checking. There's a couple I think it's like four error checks that are listed in the spec. Definitely make a test files for each of those. So make purposefully bad lc2k code that your assembler should exit on. Note that when the exits you won't be able to see any of the output. So none of that will be correct. And that's because there's really no correct possible assembly file or machine code output for a bad assembly file. So there's there's really nothing to check correctness for besides just exiting one. But with all these errors you can do most of them in the first pass. If you wish you can also do some of them in the second pass. Whatever is easiest for you but generally the the closer you have all your error checks together the fewer edge cases you have. So if you try to do the mall and pass one you probably won't have conflicting error checks at any point. But it's up to you ultimately. Let me see if I can clear out notes. Yeah so yeah Mason Hart was started talking about testing a little bit. So you know you can see this calculation here. So technically speaking we could have up to 6.3 million possible LC2K instructions. So we don't expect you to write 6.3 million LC2K instructions and test your program against that. What we do expect you to do is consider to test every single opcode. Make sure that every opcode does is encoded to what you intend it to be as well as you consider I think some things that where people kind of struggle with is perhaps the encoding of negative values in offset fields. Particularly in the branching instructions because I believe that would probably be the only place you'd really have to represent a negative number in LC2K. Well in addition to the dot fill instructions. Well one thing you should think about and consider is to the two's complement representation. And you know in C or at least in our implementation of C all integers if you declare an integer as follows. Right. Is going to be a four byte integer, four byte signed integer. And so if I were to represent a value such as negative five in that integer the most recall the most significant bit which would be you know the left most bit if I wrote it out in binary representation is going to be a one. Consider what would happen if I were converting that to a 16 bit field. Bit masking just the last 16 bits might not be exactly what you want and what might result in different behavior. So while you're going through writing your project one A and if you start running into weird errors with regards to dealing with negative offsets for the branching instructions I highly encourage you to think about the implications of this and we'll go through recap a little bit really shortly about you know how we switch between different two's complement representations and hopefully that will give you some insight on that but that's something to consider. Also another thing to consider is different types of values for dot fills. So you could have negative offsets and we can also have negative values for perhaps our dot fills and so I'd encourage you to think about the values that'd be inserted there. Some other things to consider is you should also try so there's two ways to kind of use offset field for the load instructions, store instructions, the fill instructions as well as the branching instructions and so try messing around with both having labels as well as immediate like our numbers and that should be interesting but we don't expect you to again get every single possible LC2K instruction but we do expect you to test a variety of different possibilities and a variety of different contexts. So if you're struggling with finding a bug within your code I encourage you to go back and try to generate more test cases that might push what you would perceive to be like normal or what you would consider an edge case or an corner case because that's often where people fall short on this project. Yeah just one thing to add I think you said something a minute ago about how negative numbers don't really make sense for like LW and S2D instructions like it totally makes sense for BQ that we can like branch back to a previous instruction but still LC2K allows us to do this so if I have a program like this so I'll just do something let's say that we have some sort of array and I'll just not fill it with with a one for now so we can load the address of the array or rather and I could do something like this and this would have the address of the array in that memory location so we end up loading let's say that this is going to end up being three we'll load three into register one then it technically would allow us to do something like this this should be a one we could do a negative offset with some sort of base that's greater and so how this would resolve since register one is currently three we would add that with negative three and get zero and so at the end the machine code whatever this number is I think it's like eight hundred thousand roundabout would be loaded into register two let's put a halt there to be really certain so that's something that we can technically do and it doesn't really make sense because if we're thinking about C like we would never index an array with a negative offset that's if we're doing our pointer arithmetic that's sort of like doing this which doesn't really make sense but it's something that lc2k allows us to do and it is a specific decision to make resolving numerical offsets for lwsw and beq all the same we could have used like unsigned numbers for lw and sw and only use sign numbers for beq but it's just how the isate is a couple of the notes on just some things to think about so if we had multiple lws and sw's to maybe the same location so I'll just do a rake and to be simple these two instructions would resolve the exact same machine code and the offset for the sw instruction would be the same as the lw but if we have something like a beq so we could have like and this will be bad lc2k but if we did a beq to start and another beq to start even though these look like the exact same line because start is in a different spot relative to each of these beq's they will be different so these here are not the same but these up here are the same and one other thing I'd like to point out about beq that I forgot to earlier I noticed how I have beq00 so most of the time we read the registers and do the comparison so we could branch sometimes if we had something like this I'll just call it target so we might branch sometimes we might not branch sometimes depending on the results of that but if our register a and register be indices of the same whether there's 0123456 or 7 like I have in this example here where the 0 is the same that means we will always take that branch there is never a case where we will not take that branch so if you're looking for some sort of unconditional behavior a beq with the same register index is the thing to look at yeah great point miss all right let's go ahead and okay let's go ahead and take a shot at a couple of problems and obviously I'm not interacting with you directly but I'm going to walk you through kind of thought process for answering each of these questions so there's going to be a couple of assumptions they're going to make in each of these questions but let's go ahead and reach the first one so increasing the number of registers generally reduces the number of instructions needed to implement a C program so so registers the way I like to think of registers in terms of memory is they are kind of like my my hands they're very nifty I can hold different tools in them and when I'm holding things in my hands I can use them in order to use a tool it has to be in my hands however in front of me I also have my desk right and so let's say my I've three tools here my phone these your buds cases and in my pencil I only have two hands and so at any point I can only hold two tools so if I were you know trying to build something and I had to use all three tools I would have to take extra time right so I'd use these first two tools and then I'll have to put let's say my pencil down and then pick up my my phone and then use it so essentially I had to execute extra instructions to go ahead and finish the task so registers are incredibly similar because they're very much so like my hands so if I have more hands right if I can store more tools at my disposable at my disposal I don't have to worry about performing memory accesses which is essentially what like my desk is the the process of interchanging something between my desk and my hands takes time it's an extra instruction usually in the form of a load or a store and so the benefit of having extra registers is that I don't need to perform those transactions which means that I don't need to execute as many instructions this is kind of the looking at the second question here increasing the number of registers reduces the number of memory accesses loads and stores these these questions go very much so hand in hand right the reason that I'm executing less instructions is because I don't need to go to memory to access different variables I already have them in my registers and so I don't have to perform as many sort of interchange now that isn't to say that if I had if I was running a particular program there isn't the possibility that that one program takes the exact number of the same number of instructions as the other one but if I ever do need to let's per say I had like three let's say I have two hands if I only ever use one tool well then it's not really going to make a difference if I have two hands or three hands or four hands right because I only ever need to use one of them but if I if I have six tools that I do need to use well then I'm going to have to perform some memory accesses so to answer let's see if I can get pull up the answers awesome um so to answer both of these questions we're going to have uh both of these are going to be true because I don't have to perform memory transactions and so the overall number of instructions is going to decrease I think there is another question about uh if we if we increase the number of registers are we going to reduce other instructions besides those in stores and so I think the answers know because uh you're going to be doing the exact same amount of additions you're going to be doing the same operations on the values that you need to calculate uh but there might be certain edge cases that we haven't thought about yeah so so some assumptions that I'm making when I'm answering this question is that increasing the number of registers isn't going to affect other parts of the instruction so it's not going to affect the types of operations that I can represent it's not going to affect the range of offsets I can represent and that's what for now that's what that's just an assumption what we'll discuss in just a little bit is the fact that if I were to limit the size of an instruction to let's say I can only store my instruction um as in 32 bits right well then if I wanted to increase the number of registers well then I would have to increase the number of bits I used to represent that and uh register those number of registers in my instruction and so if I want to expand all of those fields let's say my instruction already composes all of the 32 bits right so in the lc2k we talked about we had a few unused bits but let's let's assume that all of our bits were were used that means we're going to have to make sacrifices in in other parts of the representation so that we can fit those extra bits so let's talk about that um all right so um this part c asks um increasing the number of registers reduces the size of each instruction um let's let's talk about this so increasing the it kind of goes back to what I was just mentioning a couple seconds ago which is that um if we were to increase the number of registers let's think about all the implications that would have right so obviously there's going to be some hardware implications but let's talk about how that affects the iSA and the representation so um in lc2k we by default have like eight registers and so we represent that in three bits let's say instead of having eight registers let's say we had 16 registers that would mean that we'd have to represent each register as four bits and so for instructions like um let's say the add instruction where we have like add zero one two um our opcode will still compose of just three bits because we're not increasing the number of opcodes but instead this will compose of four bits this will also compose of four bits and this last one will also compose of four bits I mean note that those are going to be unused bits in between if you recall from the representations so does that the question is does that affect the size of each instruction no the short answer is no and the reason for that is although we are modifying the number of bits that represent like each register what we're not doing is expanding the overall structure of the instruction our entire instruction is still 32 bits um however some things to consider is that you know if we are limited to just 32 bits if we're limited to just 32 bits what might end up happening if I continue to increase the number of registers let's say instead of 16 I had a thousand 24 registers so this is a really really big number but then I would have to use 10 bits to represent each register um if I try to do that in this representation well my opcode takes three bits and I have to represent three registers which means three times ten I don't have enough space for that right um so the short answer is that the number of registers doesn't affect the number the size of each instruction in fact if I did continue to increase the number of registers it would eventually end up increasing the size of the instruction because under the current representation I don't have enough bits to what the 30 maybe three plus 30 which is 33 I don't have enough space and so I have to increase the size of the instruction to support the increased number of registers um so that one is going to be false because increasing the number of registers increases the number of bits per register um and in turn increases the size of the instruction looking at part D uh it says that increasing the number of registers allows for more operands to be used in a single instruction um in short this is false as well and the reason for this is that if I had to increase the number of registers um let's assume like for this case that I am locked in at whatever size of the instruction is instruction size so I cannot make my instructions bigger right so this kind of goes back to that example I was talking about earlier where uh let's say I had a thousand 24 registers which means I have to represent um each register as ten bits well if I want 30 bits of my instruction to be represented by registers well that leaves only two bits to uh represent opcodes right and so essentially the number of opcodes is now two to the two which is four and so I can only support four opcodes um and so rather um increasing the number of registers and in turn increasing the number bits that are required to represent those number of registers um will eventually reduce the number of uh maximal uh maximum possible operands um and so if I can hear this hopefully the answer creates agrees with me yep and so increasing the number of registers um again increase the number of bits I need to represent the index of those registers and in turn potentially increase the size of the instruction um and on the flip side of that uh increasing the number of registers could also affect the number of operands that I can represent assuming of course I don't want to increase the instruction size so why does this matter um well this matters within the scope of ISA design so when we were designing or when a professor back in you know the 1980s was designed the LC2K ISA or you know even uh within like arm which is another ISA that we used in this class the whenever that person was designing that they had to balance a couple of things often hardware and uh like optimization determines the maximum size of an instruction and so it's often a balance of determining how many operations or how many op codes you want to support and also balancing that with how many registers that you want to have within your architecture um and so yeah missing is there anything you want to add? Nope that's um that's exactly correct and as we continue looking at the LC2K ISA we'll see other examples of these balanced act decisions uh that we have to make when we're designing the ISA so now we're going to be moving into project 1A related things and I want to show you first this chart uh we'll be looking at this chart again in four weeks time when we actually uh get beyond simulation and actually like building hardware that runs uh LC2K code um but for now since we're doing the simulator uh we're going to show you some of the steps that you would take for each instruction and then uh you can incorporate this into your project 1S so if the first thing that you do for project 1S uh you have to read the instruction that you are supposed to currently execute and that is going to be uh whatever is in memory at the address that is in the PC so you read the instruction you can store that in some sort of variable and then you can go from there uh after that um for all the instructions that deal with registers which is everything besides knob and halt uh you'll want to read your register values and so you you might store them in a separate variable uh I think you can also uh just directly access them when you do your calculations later but of course after you read them you will need to do those actual calculations uh we have this thing up top called the ALU um we'll get more to that later but that just means arithmetic and logic unit so any sort of operators that you're going to be using C um additions uh comparisons a bitwise operators um all those are going to be used by some of add nor load store in BQ then we have our memory access which will only be with load and store and so that's going to be indexing into a memory array uh and you will have already figured out what the index is supposed to be and then um if you're not doing one of those instructions you might still be in a BQ or jaylor and you will have to update the PC somehow and now there is one caveat uh with this little chart um the order for jaylor of reading the register and writing the PC and writing the register is a little bit reversed so you can look back at the spec around the chart earlier in these slides uh but what we do we first write PC plus one to a register and then we read the register and then write PC which is why doing something uh like jaylor um uh let's see let's just say one one um we would first store PC plus one to register one but then we would read it again so it does some forwarding here uh and then because PC plus one is the next instruction and we are going to execute that instruction anyway we'll just execute it so the net effect is pretty much a no-op except we have modified register one to be used in future instructions uh if we need to do that uh but the others will follow uh this basic pattern so read instruction memory read registers do you do your operators access memory update the PC and then write the registers at the end uh we call that sort of a commit state uh at the end uh but we'll get to that uh more later in the course I guess uh but definitely use this chart okay uh so now we are going to go back to discussion one real quick um just because I think in the live sections we didn't always have time to cover two's complement um but it's going to be really useful for add ignore um so we'll just breeze through this real quick so the first thing and this is for project one A uh and for one S we do need to remember our bitwise operators so we have the chart a couple slides ago of all the different bit fields and how um we need to set those different bit fields to mean different things um so this is just a review from discussion one but if we want to take a bit field some value uh and put it into an empty bit field we first need to align it so we would left shift it by four though it add four zeros so that when we line it up it looks something like this with four zeros at the end uh and then when we do the bitwise or operation here it would smush them together and we would get the final thing that we want and this works because anything that is ord with zero is that original thing so this is zero zero one zero when it's ord with all these empty zeros that will be preserved uh we also have a bunch of implicit leading zeros over here so this one zero one zero when it's ord with the four zeros will be preserved uh but when we actually do our setting of the bit field it's reversed so now we have zeros up top and so the one one zero one is going to be preserved in the metal um the other thing and i guess you could not really need this for project 1a but you could um anything that is ord with a one or true is going to be true uh so if you have something that's all ones like a negative number that has a bunch of leading ones because it's two's complement which we'll see in just a second uh it would override everything and that would be bad so avoid that you want to use zeros instead of a bunch of ones and then we're going to do the opposite operation in project 1s uh so if we wanted to get back to this original thing here which we'll be here um we would need to uh have a mask with a bunch of zeros and ones and so those are going to be placed in strategic locations um there's a couple ways to do this we've done one way here so if you need to chop off some right most bits uh you can do a right shift so this right shift by four we're just completely eliminate those um you could also do your masking and then uh we're hoping that these will be zeros at the end and you could right shift after that but I think technically this is going to be cleaner code um anyway uh so if you want to get a rid of some bits on the right you can right shift and it'll just um delete them uh but if you want to get a rid of some bits on the left you can do a mask with a bunch of leading zeros so there's a bunch of implicit zeros before these four ones and so these four zeros here are here may lined up with this one zero one zero here uh and because anything ended with zero is zero these are just going to be wiped out to zero uh and then anything ended with one is preserved so ending with one and oring with zero is the same thing um and so we will have these uh after a right shift of course we'll have these one one zero one lined up with our four ones and then they will be preserved to our one one zero one at the end so remember that um so I know in my live section we didn't get to nangin numbers but uh we need some way to represent negative numbers in binary uh because in discussion one we did some uh binary um and we had this idea of expanded form how we have a bunch of positive powers of two um but in two's complement we're going to also use a negative power of two to allow us to use negative numbers um and so uh we're only going to have one negative power of two uh and that will be the leftmost or most significant bit uh and it's going to have the strongest place value in terms of absolute value but it will be negative so let's see how that might work uh so we have this example um let's start off let's look at this number uh and pretend that we're not in two's complement let's just pretend we're doing unusine numbers so we would have two to the power one plus two to the power zero and that's three and look at the end it's going to be three um so there are many cases where two's complement is going to be the same as unsigned numbers now let's look at this next one so let's pretend for a second that this is an unsigned number we would have two cubed plus two squared plus two to the zero so that's one plus four just five plus eight which is thirteen so an unsigned this would be thirteen um but when we have two's complement it's going to be negative three and that's because we're going to flip this bit to a negative two to power three so we have negative eight plus five which is negative three and you can see this flipping here and so notice the pattern so before we had zeroes in in these first bits and the representation between unsigned and signed was the same but when we have this front bit as a one that's the only value that's going to change and that's the only time where our values are going to be different um and because this front bit has the strongest place value that means that anytime we see a one at the front uh that's going to be a negative number because even if we have ones everywhere else it won't get large enough to overpower uh that other place value so even if we have all ones that's actually going to come out to negative one so it will be a distinctly negative number it won't even be zero right um and then we also have this math trick and to be honest i don't know who figured this out but this is a pretty cool idea computer science i think we can get from a positive number to its negative by flipping all the bits which means train zeros until ones and ones into zeros and then adding one um and we'll see in I think a couple slides uh how to do some addition but we can know that for now keep that in the back of your head just a couple more things when we compare them uh so here's a larger example of 8 bit numbers uh where we have a number that has a leading one uh but in unsigned numbers it is 240 and in signed numbers it is a negative 16 so distinctly different values however they are related in one way so if you take two to the power of the size of your number so this is an 8 bit number uh and you add that with your truth compliment representation uh then you will get the unsigned representation um and that's that has to do with some overflow things uh but that's one thing that you can do to double check uh if you're ever confused on converting between the two um so we did these problems last time i'll just show them again so this is a really really simple algorithm that we can do uh so if we have a number uh and we want to find its negative we can write it out in binary then flip the bits and then just add one um and so when we do this addition here of course if i'm adding one it's going to be a bunch of zeros um one at the end uh doing our by hand addition one plus one is two which is one zero in binary so we have to put down a zero and carry the one there'll be the same thing for a couple bits and then finally we have one plus zero which is one and a bunch more one plus zero which is one uh and then we get this final answer boom so that is negative 16 right as once again uh just for example if we have 43 in binary we would flip the bits and add one which is really simple heater because we just changed this last zero to one and that would give us our uh our our negative 43 um and so i did show you uh let's see here right here so i did the same addition algorithm that we did from the first discussion with unsigned numbers one really cool thing is that addition in intu's complement and regular unsigned numbers is the exact same algorithm uh you might sometimes have some overflow so if you had a leading one over here we're going to ignore that uh but otherwise it's going to be completely the same same algorithm uh so you notice that this number here is uh is negative uh so this is going to be what like negative 15 or sorry negative 17 and then we add one so that's one and we get negative 16 so it's going to be the exact same right um and this is once again just showing you that uh we can take two to the power of the size of the number uh add it with its negative representation and get uh what its unsigned representation might be um i think yeah i think there is one thing that's not on here uh and that's how to be convert between small signed numbers and large signed numbers so um let's say i have i have this number here which is negative four uh it's four bit signed representation right now and let's say i want to convert it to signed five bit so signed five bit representation what i can do is just look at whatever the leading value is and copy that over to the new leading bits so we see a one here so the signed five bit representation would be uh just the same thing except we add a one at the front um and we're going to call this sine extension uh but here's why it works so uh let's just kind of box off this 100 at the end uh we're going to assume that that's going to have the same value because it does uh but in signed four bit representation this place value is negative two to the power three right and now that same place value uh let's see if i can mix in my error is going to be two to the power three but now the leading bit is going to be negative two to the power four uh the really convenient thing here is that negative two to the power four plus two to the power three that's negative 16 plus eight is negative eight so this plus this is equal to that and that's going to be really useful for sine extension um now note that if we have a leading zero and civil leading one uh sine extension is just going to be copying that zero over and we know that adding leading zero is for unsigned numbers or positive numbers doesn't change the value and so that's why if we have a positive number that means that it has to have a leading zero we just add a bunch of zeros at the end or at the beginning uh it'll be the same number and so i can't remember if we use that too much in this class but we will see it in a couple weeks briefly mentioned in the lecture right so the main key here look at the front if it's zero it'll be positive if it's a one it'll be negative um and they do say try on your own to negate zero so negative zero is equal to zero the thing we did this last time the negative zero is going to be a bunch of zeros no matter what so then if we turn that into a bunch of ones uh whatever size it is is going to be negative one and then negative one plus one equals zero so um for the purposes of binary and whose complement zero is going to be called a positive number and when we get to floating point there is going to be a positive and a negative zero um but that that'll be something that we'll look at in a couple weeks and i don't think we'll even mention it in discussion right um going on the reverse so if we want to take a five bit signs number and turn it into a four bits let me rewrite up here uh and we're trying to go from there to there uh we can just chop off the leading bits whatever they are as long as they're in the valid range of four bit numbers which would be uh negative eight to positive seven um and remember that this represents negative four so that's okay um we can just chop off the leading ones and so you might do that with a mask i remember a couple of slides ago we changed a bunch of things to zero we chopped them off by doing a mask with a bunch of zeros followed by a bunch of ones and so you'll need to do that in project 1A for sure if you ever put a negative number into an offset field um so think how how you might do that right um and then finally uh your computer is going to do a lot of the stuff automatically um so things like converting from larger numbers to smaller numbers it might not do that automatically unless you know your uh your built-in types really really well um but most of the time it's it's going to do all the operations automatically so addition subtraction all that stuff your computer will do it for you and it's always going to store it in binary so if you ever see a decimal number it's actually binary if you ever see a hex number it's actually binary um it just prints it out on our screens nice and easy for us so uh if you ever need to manipulate individual bits uh just do it within the number don't make an array of zeros and ones because that gets really really messy really really quickly you have to do a whole bunch of multiplication and i do not recommend it okay so that's the quick review on two-scompoint and the bitwise stuff and i do that because we're going to look at uh how we might do that in lcgk and what that means for lcgk um so uh first we have this add instruction and um i'm going to mention this briefly uh because it'll come up a lot in project one in um but we have this add instruction and the add instruction is useful not just you can add things which is obviously useful but that also allows us to do some basic multiplication or left shifting so if we add a number to itself that's obviously the same as multiplying times two uh which is the same which is the same as left shifting by one uh so obviously if we take the result and then add that to itself do that again and again again again uh we can left shift by any arbitrary number and we might have to do that in a loop uh which we will do for project one in uh that's something that we can do um and and so we get this bottom uh truth truth statement so if we do it multiple times then uh we can left shift it by some arbitrary amount and don't forget that overflow um and then we also have this other instruction lcgk and i get a lot of questions why why nor um because it can be really confusing to think in terms of nor operations uh but in lcgk because we wanted to make it as simple as possible uh we wanted to keep ourselves to eight instructions uh we're going to use this nor because it is what's called a universal gate so if we wanted to use some regular or operations then we would need to implement either knots or maybe an end or something else uh in in order to get the full range of logical operations so just a couple examples uh if we want to actually do the knot a bitwise knot uh we can just know something with itself and that's because when you or something with itself it's that same thing so you do the or and then you knot that and you get the knot to be original thing um we can also do a nor or rather an or by first doing the nor and then taking that result and norming it with itself so using uh the definition of nor and this idea that we can get to a bitwise knot by doing a nor with itself uh we can we can do the same thing uh to get an or um and then we do have to use some review from two or three or two seventy uh the demortons laws in order to get to an end operation uh so if we take a value um and we knot both of the inputs first so that is doing a nor with itself on both of the inputs uh then we can ignore those two results together and by demortons laws this uh this bitwise knot distributes cancels that cancels that but turns this into an end uh and so um that's going to be really really useful for project 1m because we will need to do some masking in project 1m so that turns into an end and you can look up more on on Wikipedia uh there's ways to do x-ore x-nor i guess if you took this and operation and did a knot you could get a nand um but that'll be really useful for project 1m right so i say all this because what if we want to do subtraction and i'll see decay now arm has a dedicated subtraction um but if we want to do subtraction lc2k all that we have to do is first uh do a nor with itself on the second operand to get knot b i suppose then if we add one we get negative b and if we add the negative b plus a we get a minus b um so we we can do subtraction lc2k with three instructions instead one but that's okay and you might even need a fork to load this positive one here so i'll just mark that as an lw and then finally uh we can do a bunch of ants to do our left shifts and then three nor operations to do an ant operation and that gets us a total of masking um similarly if we want to set some bit fields we can do some left shifts and then do two or operations uh nor operations see a one or operation so there's there's a lot of variability there right now i'm going to turn back to sunny and we're going to go through some of what i call brace blocks in lc2k and uh how we would translate that into um into lc2k from c and that'll be really useful for project 1m yeah so um i'm sure that you guys in your computer science backgrounds and careers of art have seen a whole lot of code that kind of looks like what we have off to the left here so this is an example of some code and c what i don't expect you to have as much experience with is um writing code that would be the equivalent to this in an assembly language so um what we're going to do here is we're going to try to translate what we have on the left which is kind of like this if uh else statement um into what we have on the right um and so i'm going to walk you guys through kind of my thought process and also kind of identify some key characteristics of of this block um so i'm going to draw my best to kind of um color code this and kind of identify what parts code um are being encoded in each one of so looking at this if l statement we essentially really have like um for segments of code so the first segment is what i'm going to mark here in or underline here in red um which is the condition right so this is right now we're going to compare the values that are stored in registers two and registers three um and based on the uh whether that returns a true or a false value or a zero or non-zero value um we're going to change the code that we execute right so the second part of code um that i'm going to underline here in green is the code that is executed um if the statement is correct um so this code is only going to execute if the value inside register two is not equal to the value inside register three the third component that i'm going to underline here in yellow is the code that is in the else block which is a code that executes if um if the value in the statement results defaults and the last part of code that we have it's not really code right now but um that we could have is whatever code occurs at the very very bottom um whatever code that executes after you know the if l statement is done so that code is going to be executed no matter what regardless of which uh regardless of what the uh condition is so let's take a look at how we could perhaps do this in lc2k so recall the the one instruction that does comparison for us um and allows us to branch based on that is the beq instruction um uh so um right here in our conditions case we are trying to compare whether um register two is not equal to register three so we only have the uh instruction that compares that if they are equal to each other right and if they're equal to each other we're going to perform some sort of job so the values that we're going to have is parameters for this part are going to be registers two and three because those are registers that we want to compare right these are the registers that are going to appear in the condition um the destination so here we have a label um i'm sure you could put a number right as well but um for sake of simplification leaving for the label so this is the part of the code that is going to be jumped to if this condition evaluates the true so essentially um if this um if this condition evaluates the true we want to execute this bit of code right here we want to execute that green code right well currently the way we have our code structure we are going to jump to this else branch if we evaluate um if this statement evaluates the true if they're equals to each other um and so the code that we would kind of want to occur here because we are checking for non-equality right so if these are not equals to each other recall um then the code that we want essentially if this evaluates to true which means that they are equals to each other the code that we want to execute is right here this yellow code and so the code that we're going to put at the else kind of walk here is going to be correlate to the yellow segment here um on the other end right um if that be Q2 3 right if register 2 is not equal to register 3 we want to execute the green code so if a brand if a be a Q instruction does not you know it's provided registers whose values are not equal to each other or who that are not equal to each other then the code that's going to execute is just the line after it right essentially no operation no branching operations perform and so the operation that's going to execute is right here um however um if we just had these statements so if we kind of ignored this statement right here um this third line what would end up happening is that we would end up executing both instructions right so ideally we execute our green code and the next code that we execute is going to be the blue code right the code at the very bottom any code that occurs after the addition so our blue code kind of exists here so in this case we don't execute anything after so we have a halt here but if you wanted to perhaps execute an add instruction or any sort of other instruction there you could also have that there so the reason we have this statement right here is so that we don't execute the yellow code after we finish running the green code so this is the overall structure of an if um of an if else block we have a condition that we will generally check using a be a Q instruction so note that it's kind of inverted because we can only check for equality we don't really have a be an EQ we only have b equals and so if that it evaluates the true um we are going to execute the code that the code that is should be associated with the label so in this case the labels else the code that should be executed in associated with association with else else is the code that should be associated that should execute if they are equals to each other so in this case we want to execute r1 is equal to 0 if r2 is equal to r3 so that's why we have that on this line the code that executes when they're not equals to each other is the is in this case the green code um and so this is going to be like the overall structure of any if else state and so you'll find this extremely useful um perhaps in as Mason mentioned project 1m but also even more generally um is as we move forward in in projects too um but yeah so upper this is an example of an if else statement we're also going to look at a couple other types of common statements that you might see within c um cool Mason can you just hit the next button I don't know why it's not let me move my slide forward okay cool um it's good um all right so the wild statement is also another example so what a wild statement essentially does is it keeps running the code so in this case the blue code inside here until the condition um in the red text um it evaluates the truth so in this condition in this example we are looking at um we are trying to run the code until r2 is uh as long as r2 is equal to r3 um so um essentially we want to only jump we only want to if we had like if we need the same colors if we had um code like after this right i'm underlining this in green right we only want to execute that green code we only want to jump to that green code once the condition evaluates the false so essentially um what we can do here with the branching instruction is we can compare the values uh inside registers in two and three and only when they're equal to each other um we will jump to the code uh to the green code right um so we'll jump down to this part however um what in the middle here we're going to have so if that condition does not evaluate the truth we will then continue to execute the next line which is found here so this is kind of the literal translation of that um the last line that we have here so recall mason mentioned this earlier if we ever have a beq instruction where both of the uh registers provided are the same then obviously the values inside those registers are going to be the same and so essentially um what we are going to do is regardless of what values in registers zero we are going to change our pc we're going to jump all the way back to this line over here and so essentially the the form of execution that we're going to see is we're going to check a condition we're going to execute whatever lines are inside that loop so here i've illustrated that as the like blue code where the we're adding one uh add 111 and then at the very end of that we're going to jump back to the start where we are checking the condition and so essentially we're just going to be checking a condition over and over until we can kind of break out of that condition so in this case in this particular program we're going to kind of be stuck in an infinite loop because we're not r2 unless sorry if r2 is initially different then is r2 is initially not equal to r3 then we're going to constant we're never changing r2 or r3 so we're going to kind of end up in an infinite loop but um more generally um you could modify for instance registers two or three and so you could keep iterating through this code until um that they meet certain values that you want. Awesome. There's some of the other ones yeah there's one example that we don't have in the slides and you may have used this in crc++ but we do have one more type of block called the do-while so a do-while block um is guaranteed to execute whatever's inside the braces at least one time so it'll execute it once I guarantee and then at the end it'll check our conditions um and if this is actually much easier to translate to else at your k um so it looks something like this so we could add a label do at the which is the beginning of our brace we could do our same add 1 1 1 and then we'll do our beq uh let's see um two three and actually I'm going to modify something here um yeah yeah so um in the in the reason I do that is because when we have a do-while loop when we do our condition checking at the end uh we actually can check for equality so if you're truly trying to check for equality in a while loop instead of inequality uh you you can do something like this uh the only caveat is that it will happen at least once um I suppose at the beginning if you really want to do a true while loop you could add an unconditional branch um to the uh maybe maybe we could do something like this so you could branch to the end first then do your condition check and then go and do the thing uh and so that condition breaks but um that would eliminate the need uh to to have i guess other unconditional branches that always execute but also eliminate the need to have some sort of end to label that is after um the end of our our loop here but so you might want to use that yeah so like what we're showing in this well we're hoping to accomplish to show you a couple ways of doing it i'm not the the ways that i'm showing you are not holistic we're not showing you every potential way to represent a while loop in lcduk but this is just a very common way of doing so so mason here illustrated us another way to do a while loop and he also showed us how to do a do-while loop um so yeah so um another type of common convention that you might want to implement in lcduk is a forluch so breaking down exactly what a forluch does um there's really three parts in fact they're they're actually quite similar to uh to wild loops but the difference lies in the the top part where we declare what uh and initialize it initialize a certain register or variable to a starting value um we have a condition right really similar to our wild loop that we are going to constantly check and we're also going to have um a certain operation that we're going to perform every time we perform this loop so in the case of the example here we initialize register to five so that's only going to execute once when we initially run this loop um the very first time we're about a run loop um the second part is going to be that condition and the second part in red is going to be that condition which we're going to check every time we run the loop um and then the third part is going to be what I call kind of the iteration step where we're going to modify a variable um and uh and that's going to occur at the end of each loop iteration so um the composition of this kind of goes as follows so when we're trying to initialize something to a certain value so in this example we are trying to initialize register to the five so we could do this using a load instruction so um um uh is he going to let me write in like that respond to me please okay cool um all right so my iPod is not listening to me so I'll just verbal explain the spark Mason you can take any notes so that you see fit um as we walk through this so that green part at the very top there is us loading the value five into register two um so note that in this example here we don't actually show you with label five but presumably at the end of our program we'd have something that would be labeled five and have like a dot fail five um and so we don't we don't show that right now looks like Mason's drawing that for us now but essentially what that accomplishes is we're initializing a register to a particular value so that line of code is only going to be executed once um the second thing that we might do is we have what is considered like our condition so that's what's in red so that's what you see on the third line so that's going to be very similar to what you saw back when we did the while so we're going to check that condition every time either the third part is going to be what's you know located inside the loop so that's what's in blue um so we're doing performing the operation at 1111 so this is what's new is everything in pink this is kind of the main difference between a while loop and a for loop is that we want to kind of perform this increment operation um every time we execute the loop so this is going to be the last thing that's going to happen in the loop before we branch back to the start of the for loop um and so we want to our increment operation here says plus plus r2 so essentially we want to add one to the value of r2 um well in order to do this we have to first have the ability to work with the number one right and so you can see at the very start of the for loop in the second line here we load the value one into register five there by doing that in the fifth line by adding performing add to five to essentially we're taking whatever values in register to we're adding one to it and we're scoring that back in register to then we go back to the start of our loop so essentially um what this allows us to do is change the registers and change the values of the registers that are in our um loop condition so like last time in a while loop we saw that we were never really changing registers two or three and so we would kind of end up getting stuck in an infinite loop however here um in this for loop we are modifying register to and so essentially we're going to add to one to register to until we have a value where register two is equal to register three and then we're going to branch all the way to the end of instructions with the end label yeah a couple things I'd like to know um yeah uh so just like we had with the while loop and the do while loop in the last side uh we we could construct this a different way so um let's see so assuming that this top part is going to be the same and that bond part is probably going to be the same uh so we could have some way to branch to the end so let's uh or maybe maybe we'll call it check like we did on the last line uh then we have whatever stuff we're doing inside the for loop so that's add one one one oops uh and then of course we increment new increment uh and then we have our check our check condition right and that here is the EQ uh two three four and of course this would have to be uh if our for loop was checking our two being equal to our three but we could do it this way um also uh we'll get more into this later in the course on compiler optimizations uh but sometimes compilers will be able to tell if the condition is true on the first iteration of the loop uh and if the condition is guaranteed to be guaranteed to be true on the first iteration of the loop and we never have to do this so uh we might not need this um we might not need this uh if the condition uh is guaranteed to be to be true at the beginning uh so i'll call out at the start um and so if you are doing something again for project 1m where you'll probably have to use the loop you might have some sort of structure that looks like this so you do your stuff you do your increment then you do your check which branches backwards um just a quick clarification it would be the when it's not true when they are if it's never gonna run in the sense that if the condition always evaluates to false right um let's see so let me let me think about this again so if the condition starts up as false we would go down here and check uh then two would be not equal to three and so we would continue along our way so uh it would guarantee that the condition is true uh of course if we're checking R2 being equal to R3 uh so yeah so you definitely do have to go through and um make sure that all your conditions are correct because if you're doing something like a do while loop uh it'll look like the correct condition just at the end but if you're doing a regular for a while loop uh you might do it inverted so yeah just have i don't think yeah just just a heads up um i don't think we we don't talk very much in this class about compiler optimization so of course this class is an introduction to compilers just so you everybody gets a good idea of how they work um however i believe in uh i may be wrong but i believe it was homework to uh historically we've we've offered like a question which kind of um encourages you to check out some um other compilers that run on ccode and take a look at what optimizations they make and that was entirely optional i believe but um if you're interested in compiler optimizations i encourage you to tempt that question on that homework if we end up having it. Yep all right so now we have a practice problem um and so i'll let's send it over the solution but one thing to remind uh this practice problem has two parts that kind of cover everything that we've done in the past couple minutes so first there's an arithmetic operation so we have to do that calculation uh and then we will translate the if else block yeah all right let's um let's let's take a shot at it so at the very top here i'm just gonna here second let me see oh i'm on my eraser okay so i'm gonna save some okay um i'm gonna save some room just for some loads so i'm gonna assume initially that i have all the variables that i have on hand and i'm just gonna declare some loads as i go so let's start like i'd generally like to start where the code essentially happens so i'm going to designate so it looks like i have unsigned valve this is going to be a variable right and so i'm going to choose some register um to save this variable in um let's see i want to kind of stay in line with the answers so let me check really quickly where we put that uh isn't it off the top if we had let's say register two yeah sure that works so we're going to store valve in R2 um here we have another variable it's an integer um and this is going to be assigned integer and we're going to store that in let's say register three um let's say register one okay cool and let's see why in just a minute here awesome all right so we're going to store those variables in those designated registers so if you're trying to turn some c code into lc2k or really any assembly the one of the first parts is kind of deciding what registers are gonna or what variables are gonna be stored in one registers and so that's what we've done here um so none of these uh variables are kind of initialized to any value so we can just assume that we don't we're not going to load anything into that initial um okay so here we have an if block um and so in that if condition we take the modulo 8 um and then we take the result of that operation we compare it to so perhaps the first operation you really need to do is get the value modulo 8 so let's think about what modulo 8 is actually doing um so what the modulo operator does is it kind of takes essentially a remainder operation um it gets the remainder of uh the value when divided by 8 so if I had the value 9 the resulting value that I would get would be 1 right um and so let's think about or similarly if I had like value 8 the remainder would be 0 so let's think about how we could possibly perform this operation within um using bitwise operators right and what we're going to use is we're going to use bitmasculum so let's look at like the representation of those two examples I get where we have um the number 9 right um so when our percent 9 as follows so 9 can be represented as a 1 0 0 1 right um and let's look at the representation of the number 8 so this is going to be 1 0 0 0 um let's let's find a couple more examples um let's think about the number 16 right that's also a multiple of eight and so we would expect the modulo operator to give us um um remainder of 0 right and so let's look at the representation of 16 so that's going to look like 1 1 0 0 0 we'll have about one more one last example um of a value oh sorry yeah that's correct it's 1 0 0 0 0 um and then let's look at one more value like perhaps the number 11 right um so this is going to look like um 1 0 1 1 right so both of these numbers 8 and 16 are numbers that kind of satisfy my condition and if you look at them and I encourage you to perhaps try numbers like 24 and 32 other multiples of eight you'll notice that all multiples of eight have their last three bits set to 0 and why does this make sense well those last three bits um are going to be 0 because those last three bits represent non multiples of two between the range 0 and 7 any value to the left of that any ones that I have in the binary representation that I have to the left of that are going to be are going to represent values that are multiples uh that are going to have 8 as a factor right now they're going to be multiples of 8 and so what determines whether something is a factor uh is going to have a modulo of 8 that's equal to 0 or or not is going to be these last three bits so essentially we want to check if these last three bits are equal to 0 or if they're not going to be equal to 0 well let's let's think about what operators we learned that we can use to isolate these three bits and then compare them to um like perhaps the value 0 um so I'm going to erase some of this really quickly cool um that should be good enough um so well now let's go ahead and uh write some LC2K so what we want to do is we want to isolate those last three bits so if we were writing c code for instance well what we want might want to do is we want to perform a bit mask so we um so right now our val is stored in r2 and we essentially want to say r2 is equal to r2 um not r squared r2 um uh bitwise ended with 0 be 111 what that does is essentially isolates those last three bits um then what we might want to do is we might want to um check essentially if once we perform that operation if that is equal to 0 right because if that is equal to 0 that must mean that our val or the the value that's stored in register 2 is a multiple of eight so let's go ahead and write some and think about how we could perform a bitwise end so you might notice off the bat that we don't have a and operator right where we're limited as far as like our type instructions go we're limited to add instructions and nor instructions so this kind of goes back to what um mason was mentioning earlier where we can use the end instruction or that use the nor construction to construct other logical gates such as the end gate so the way we do that is we perform so look if I wanted to um i'm just going to kind of recap this um if I wanted to perform the bitwise end between registers a and b right I would perform a nor on a with a i would and i would let's just reassign that to that'll give us not a um I could give a perform the same operation on b and I could produce a and b by performing the nor on the results of both of those operations so let's go ahead and write that in else is okay um so um well to start I need to load this value into a certain spot in memory right um so let's just load that into perhaps register 3 is that a good one Mason um uh yeah okay so let's load that into register 3 so what is this value well in decimal that's going to be seven right so I'm going to load um but into register 3 the value seven right for now whenever I write in a number like this I'm going to assume that at the bottom there's going to be a label that says seven dot fill and an actual integer right and I'll do that at that um but um so what we want to do is take r2 and perform a bitwise nor with itself let's go ahead and do that so we're going to go nor um we're going to do register 2 with register 2 um and we can we can probably just save that inside register 2 as well so essentially what we're doing here is we are um flipping all of the we're performing the bitwise nor on register 2 and saving it back to register 2 we're probably going to want to do the exact same thing as we illustrated at the bottom here for register b and so we're going to do the same thing for register 3 so now I have gotten these two bouts well now I'm going to perform one last bitwise nor or yeah one last bitwise nor which will give us the result of a and b um and so let's just save this uh to I guess just register 3 because I don't think we're going to need the value seven anymore um so what we're going to do is we're going to form nor 2 3 and then we're going to save it to register 3 so essentially what we've succeeded in doing here is um we've performed this operation here um and we've saved the result of that operation in register 3 so we've successfully made a bitwise and in lc2k um so now we want to see if the value in that register is zero so this is going to be come back to like a common convention that I highly suggest that you use an lc2k it's just simply a suggestion which is you're going to need the value zero a lot and every register in lc2k is initialized to zero and so usually it's good practice to just maintain the value of zero inside um the register zero um so I'm going to take advantage of that at this point so I want to compare and I want to check if the value inside register 3 is zero so the way I do that is I do a bq a person of equality to between register zero which has the value three uh has the value zero and three right which is going to have the result of uh uh val modulo 8 and if it's true I'm going to um jump to a certain label I'm not going to define this yet so let me go ahead and erase some of my work we have more room to write the rest of the lc2k code awesome okay so now let's just clearly click so now we've successfully done the operation inside the condition um and um going back to what we were talking about earlier um with if blocks right if these are if this condition evaluates to true right which is essentially what we're checking here I want to execute result is equal to one so the so the value that I'm going to or the code that I want to execute when the branch instruction is executed um is result is equal to one so I'm going to write my label all the way down here called true and what I want to execute is result is equal to one well initially I said that result is associated with register one um and so I can load the value uh one into register one so here the destination register is register one and the value that's being loaded is as follows um however um on the flip side if you know if that if statement evaluates defaults then I want to assign the value zero to the result um and so I could one way of doing that there's actually several ways of settings uh they certain register to zero but the way I'm going to do that is performing an add instruction um so the red code is here so um I'm going to perform an add instruction um and I want to save that to register one so I could do add zero zero one and the reason this sets register one to the value zero is because the register zero we're going to maintain has the value zero and so zero plus zero is equal to zero however you know going back to what you were talking about earlier we don't want to execute result is equal to one if we hit the like done condition so um we might call this like um uh let's i'm going to check the answers really quick okay so we have a label called return in the answer solution so I will maintain that so if I have return here the return is essentially um whatever code falls below this like the segment that I've shown um so because there's no code there I'm just going to call it a halt instruction for that right so um what I want to do is I want to jump down to my return label um well you know if I want to jump there no matter what as long as I set these registers equal to each other so set a common practice I'm going to use zero zero um and the destination that I want to jump to is the return label um so um let's take them to erase these random ones um so let's really quickly now so I I referred to like the number seven um I referred to the number seven earlier and I referred to the number one and I referred um well I guess that's the only things that I referred to but I referred to these numbers so at the very bottom I'm going to have a couple dot fills that defines them right so I might have um seven dot fill seven and one uh lose probably not the best color for that part uh one dot fill one and um yeah I believe um this should be correct so I'm missing do you want to reveal the solution quick oh there it goes awesome so let me okay so here in this example you'll note that there's a couple extra instructions and that's just us um you know providing example inputs for what val and and result uh or sorry what val is like initialized to um so here we say that like val was initialized to 16 um but that could really take any particular value yeah awesome um one thing I do want to point out and I think I may mention this uh in discussion one but this will be really important for project uh four not to project four uh when we did the modulus with eight we got seven um and that can be generalized to any power of two so we have some value modulus a power of two that's going to be equal to uh that value and did with that power minus one so seven is eight minus one and here's why if we draw eight and binary it's this um and so we have three zeros at the end uh we want to preserve those three zeros right and so we just subtract one and I'll turn this into zero and all these into ones so that's why we do that and that's equal so right so um yeah not particularly relevant for LCGK right now but that'll be really useful later on in the course so let's uh keep going I guess um this is the starter code from the project one spec um and we do get a lot of questions and what exactly this is doing so I want to go through real quick and convert it into C code all right so let's look here so a couple things I'm going to notice from the beginning uh I have a couple constants um that's constant that's constant uh I'm loading that constant there and let's see um oh and this is tricky um I'm loading the other constant negative ones somewhere else but we'll figure out uh how to do that a minute um a couple of other things uh and of course I give you the comments here that it decimates um but if I see some sort of ad where one of the source operands is the same as the destination operand that's similar to like a plus equals and C plus plus um and then finally I have a condition check with zero and then um I have an unconditional like we were talking about earlier so if I see an unconditional branch um that goes backwards I'm thinking it's a loop of some sort so let's look at this so first thing we'll do we'll put five into register one I'll just uh let's see I'll have an integer five I'll set it equal to or sorry register one I'll set it equal to five and that looks like an eight unfortunately anyway so I'll set register one to five um and then I'll also have to use that value in order to figure out what our next LW is doing so register one is five and my color change again there we are um now we have one in register five or sorry five in register one and we're going to read register one on this next line so if you remember uh the LW instruction takes the value in register a plus the offset and then calculates that as our memory location so five which is in register one plus three is eight and then we do have to do some counting so zero one two three four five six seven eight will get us to negative one so now into register two let's call it is equal to negative one okay um then I see that I'm going to be um decrementing register two since this is negative one that plus equal is essentially uh something like this right um and then I have a beq so when register one is zero then I'll go to here so two we're going to go to pc plus one plus two which is this halt so this beq points to the halt um so I'm doing some sort of jump to halt and then I have my loop so let's see so um at the very first iteration of the loop uh it's going to decrement and so register one is going to start off at five and then get decrement at the four and then of course three and two and one and then finally once it's zero they'll go to the end so essentially what this is doing uh let's say I said that that would decrement from five down to zero so that's going to happen five times so we know that this loop is going to occur five times and so we can write as something like this uh we could do like while that um and then that would that actually be it but uh to make it easier to read I do have a solution that's uh probably more like what we would actually write and see available for you uh so oftentimes we don't use absolute register indices when we're writing in seco we have our favorite variable like x uh or i or j or something um so we could have uh x start off as five and then we decrement it every time um we could also do this in a for loop and uh like I said previously we could also do something like while x minus minus and I think I think that might actually be a minus minus x that we have to do um no no that's completely right so you could just generalize it to one line which is pretty cool uh you would still need to initialize x though so there's multiple ways to translate into c but the goal is to get closer to whatever you would actually write uh when you're writing seco um and so I think probably the best way here is to do it with the for loop and this needs to see me calling because we use for loops a lot and when we look at the for loop here we can identify those four colored parts that we had a couple slides ago so we have our initialization here in it uh we have our condition check which is here so there's a check in it check and then we have no actual body stuff but we do have our decrement which is here so those are the three parts of the for loop and that's why it's probably best to turn this into a for loop so that's that problem um real quick before we end here we're going to go over the algorithm for project 1m and in order to understand the the algorithm for project 1m we do have to look at expanded form uh so when we do multiplication um we we can uh do it similar to expanded form uh so we break everything into its parts its place values its digits uh we do all the multiplications and then we add together the final sum and so that's what we're going to be doing here so just looking specifically at the binary um when when we do the multiplication here um either we include the number if it's a one or we exclude it if it's not there or if it's a zero uh so we're going to use that idea quite a bit so when we do regular multiplication with decimal numbers uh this is something that we learned in grade school but it'll go something like this uh so we'll pick one number that we're going to go digit by digit by and I'm going to pick this bottom one so we have 26 10 104 and what we do we take the top number multiply by the first digit and then we store that result on a first line almost then we're going to add a zero uh because the two has a place value of 10 so that the added zero so we'll go ahead and write our zero here uh and then we'll do the same things we'll take 104 times two which is 208 and we'll place that to the left of our added zero then we'll add it all up and we'll get our final answer and so you can verify that 104 times 26 is equal to 2,704 just like addition uh the algorithm for multiplication in binaries can be the exact same and if if you're looking for more clarification you can't find it i believe in section 3.3 of the textbook unfortunately we don't provide the textbook uh we we can't do that do that copy we don't want to be like other schools that have provided it online for free publicly because that would be very bad so let's look at the actual algorithm here so we're going to pick a number that we're going to go bit by bit for i'm still going to do the bottom number but you can totally do the top number um and so i'm going to start off with the first one it's a one and so i'm going to take one thousand one times one it's one thousand one so i'll just copy it down and then i'll add a leading zero and remember in lc2k to add a leading zero all you have to do is shift by one which is adding it with itself so at this point we would take one thousand one and add it with itself store it in some other register and then we can keep going so now looking at the second bit it's a one one thousand one times one is one thousand one so we'll just copy it down right now we encounter a zero and anything times zero zero so it's just about two zeros and then finally same thing one thousand one times one we've now shifted over three times so we have three ending zeros and then once again one thousand one so now we add that all together and some sort of running some and we get our final answer and you can verify let's see this is uh what nine times eleven so we're expecting that this should be ninety-nine and i haven't done the math myself so let's see this is uh thirty two i believe plus sixty-four that sums up to what ninety-six and this over here is going to be three uh so it does sum up to ninety-nine which is nice um for project one m uh we have a couple difficulties we do have to figure out how to isolate the individual bits uh to see if they're one or zero uh so to do that we can do the masking stuff that we did earlier uh we showed you how to do an and operation lc2k so you can do that with some sort of mask and that mask will have a single one and all the rest will be zeros uh you'll you'll do the and operation between that mask and number that you're going bit by bit for and the results will either be zero or it'll be something else i don't worry about right shifting because if it's zero you know that bit was a zero if it's a big number or one you know it's a one and so you can use a beq with zero to tell you if you should add that shifted number to your running sum or not so here uh we would probably just skip over whatever addition so skip addition uh if we were able to be eq with zero and whatever the result of our mask was otherwise we would do the addition with the shifted number and if we have some other registrals call it register seven that's our sum uh we could keep adding this into our register seven sum over time and at the end we would have the correct answer i'm a couple of notes about project one them by the way uh we're only dealing with 15 bit numbers um so here we're doing a four bit example but you would have to do it with 15 bit numbers uh the reason we do that is because if we were to do 16 bit numbers that would require 32 bits maximum for a product but since we're doing two's complement for all of our words and registers in lc2k uh if we were to multiply 16 bit numbers it could overflow turn something negative and we don't want to do that so we're only going to do 15 bit numbers right and that is the algorithm for binary multiplication there are ways to do this quicker in hardware but again lc2k is a very simple isa we only have the ad instruction we don't have a multiplication instruction like arm x86 or something so we have to do this manually instead a couple things from project one m and your test cases and project two c which is also writing in lc2k assembly uh you might want to write it in c and then use the things that we've taught you today to translate it into lc2k um also it's always good to add comments you'll notice that everything that we provide to you uh for lc2k is going to be very well commented and it should really be the same so that you can understand your own code and so that we can understand it in officers this has been discussion two