 Okay, hello everyone. I wanted to make a video for Project 1. Of course, just as I'm ready to hit the record button, this guy, this is Spencer, comes over into man's attention. So if I see him a little bit distracted, I'm looking to the side of me over here where he's sitting, that's why. Okay, so first of all, on this project, the first thing I'll say is don't panic. One thing to understand is you don't have to understand everything about this project to start planning it or even coding it. There's a lot to the project, but all of our projects are designed to be able to be built in pieces. So that being said, where should you start? Well, read through the project specification. Also look at the Extrapetiaf that's on Canvas called Project 1, the STL and you. And that has some useful tips in it that will make things easier for you to understand and a little bit of coding tips in there how to change like a single character into a number and vice versa or single digit, I should say, how to change a single digit into a character and vice versa. In fact, don't try to use ATUI on a single character. I don't think I put that in there. The reason is ATUI expects to be given not a character, a character pointer to a string of characters that ends with a backslash 0. And when you've got a single character, even if you take up an address of, there's no guarantee what's after it in memory. So you may give it, you may have a character containing the digit one, you give ATUI the address of that character and oh look, it just happens to have a three after it in memory. So that one becomes a 13 instead of a one. So don't use ATUI when you want to do a single digit, the Project 1 STL and you will show you how to do that. The other thing is be willing to go back to reading parts of the project, looking at the Project 1 STL and you slides, maybe coming back to this video and hopefully after I've got it all uploaded, I'll remember tomorrow morning to go in and put some timestamps in for like where major sections begin. Okay, so once you've got some that understood, one of the things that you can do is process the command line. It's going to be a lot like Project 0. Hey, this is one of those reasons that Project 0 helps you is because our projects tend to use command line processing and once you've done it once, the subsequent programs are going to be, you know, like right now you'll say, okay, well, I'm going to copy some pieces of Project 0's command line processing. I'm going to change it a little bit because you know, hey, that Project 0 command line processing only had to deal with returning a string. Here you've got to somehow return whether it's stack mode or cue mode and what the output mode is. Hey, there's a simple way to do this. Make the whatever the function is, I think I called it get mode in Project 0. Instead of having it return a string, make it avoid, but make it a member function of the class and then you can modify member variables instead of local variables and then your class, let's see, you call it the station class or whatever it's called, the station class will know everything, including whether it's stack mode, a cue mode, what the output mode is, etc. Okay, so if you and you don't have to get that done first, you could just say, hey, I'm going to start coding and I'm just going to assume that it's going to be let's say stack mode or cue mode. It's going to be one of them and I'm going to assume an output mode and I'll do that command line stuff later. Well, whether you write the command line processing first or not, next thing to do is read some input. Now it says this in the projects back, you're going to read from CM. Even if the input is in a file and you do something, let me write on the table here, even if you do something like this, dot slash ship dash cue, less than, I forget what the name of the sample files are that I gave you, anyway, let's just call it like input dot txt. Now normally, when you type this at the command line, your program will not see this stuff. The operating system takes care of it and says, hey, instead of CM being to the keyboard, CM should be hooked to this file named input dot txt. Now inside of X code and some other ideas, that stuff doesn't work and that's where X code redirect comes in. But the main point is you shouldn't be creating file streams, you shouldn't be looking for file names to open or anything like that. You should just be reading from CM, writing to see out. And if we do something like redirect the output to a file, the operating system, or a code redirect will take care of it for you. So you're just going to read from CM right to see out. So start reading input, pick an input type. You don't have to write in both pick one. So pick one input type and start reading it in. Oh gosh, now to read in input, we've got to talk talk about data structures. Okay, we'll come back to that issue. So we'll come back to talking about data structures in a little bit. Let's just go through a list of what we should do. So we've got to, oh, hey, let's pick list. We've got to, well, we got to do a lot of reading read the spec, the project one, STL and you, STL and you. Okay, we got to do some two maybe. We could do some command line processing. Step three, let's read some input. Read input, pick a moment. Okay, now to do that, we're going to have to worry about, wait a minute, what about those data structures? Okay, so let's change that. This is going to be step three anymore. Pick that step four. Step three is going to be data structures. We don't need all of them to begin with, but we'll need at least one of them. So we'll come back to step three in a little bit. Step four, we read some input and then step five, let's start doing some searching. And let's just talk about searching in terms of, hey, I've got to do the searching at least enough to know whether there's a solution or not. Now then once we've got that searching and where it can search and know if there's a solution or not, then we could, hey, I can say, hey, let's do some output. If there's no solution, and let's pick a mode. And here's where it starts to get interesting because if you pick map output mode and there's no solution, what you're going to end up doing is outputting the map that you read in. So that would tell you, if you're reading works, so that could be really important to know. Okay, and that's if we pick map output, if we pick list output mode, it's really easy. You print path taken and you're done. So that doesn't tell you much. It's really easy to get done, but it doesn't tell you a lot. Okay, so now once we've got some output, when we know, say if we do map output, we know we read the input properly, then we can go back and let's update the searching. To do or to allow to allow backtracing. Now we're not going to do the backtracing yet. We're going to allow it. We're going to save the info we need to do the backtracing. And the backtracing is in the project one STL new and we're going to talk about it later tonight. I say tonight because it's like 11 o'clock for me the day before the project's coming out. I'm finishing up a video. Okay, so there we're going to update our searching to keep tracking our backtracing info. And also this might, so this is going to affect this step. It's also may have to affect our data structure. We've got to remember new info. You may have to go modify our data structure to make room for it. Okay, then after that, how about if we do the output? If there is a solution. And then we're going to we're going to do some work, right? We're going to get these, get, we're going to make sure everything's correct. Or at least most cases are correct. And then we're going to go back and finish the other input. And output types. And there may be bugs. We may not finish step nine. We may say, here, it's kind of late. There's no more off-stars today. But hey, I'm not sure how to fix this bug. Well, I'm not solving this map properly, but I can go write another output mode. And then once I've got my searching fix, pay my output, should be fine. So you can you can skip steps. You can partially do steps. And also remember, along the way here, it is not like a step 11. Along the way, you should be creating test files and submitting things to the auditor. You don't have to have all this working before you submit to the auditor. You can submit to the auditor, hello world and some test files and start earning points. And also when you get to the point where your program is partially right, as we go through your test files, the first one that we encounter that you get the wrong output will tell you the right output and the wrong output. Or what should say, we'll tell you the right output and your output, which like I said, if it's the first one that we can counter that you're wrong, we'll show you. Here's our output. Here's your output. And that will really help with debugging because it is possible to take an input file and predict the output using your brain to play computer, but it takes a while as you're going to see later on. We're going to do an example in the video. Okay, so there's our sort of a big outline for coding this. All right, so let's talk about memory and data structures and stuff like that. First thing I want to warn you, it's not the first thing in my list. I've got a list on my screen here. It's not the first thing in my list, but I'm going to give you a hint here first. Don't use pointers. Don't use pointers in this project. They are not your friend in this project. There's going to be enough pointers in project two that no matter how much you like pointers, you'll probably get enough of them or more than enough in project two. You don't need them in project one. They do two things in project one. One thing they do is they waste memory and the other thing that they do is they force you to waste more memory because a pointer doesn't give you very much information. It tells you where something is in memory, but it doesn't tell you where it is in a 3D map. Right, I've got a pointer to an address. Is that in level zero or level three? Don't know. Is it row two or column or row 50? I don't know. Calum two or column zero. Don't know. So a pointer doesn't really help you. Don't use pointers in this project. We're going to have to read in a 3D map. The simplest way to keep track of that 3D map is in a 3D vector. Now here's another tip. Don't start by saying, I got to have a vector of 3D vector characters because you're going to need more info later on. So let's give you a counter example. Suppose we are writing a project to keep track of student records. You wouldn't start by saying, hey, I'll make a vector of strings. That's my student names. And then I know, I know I'm going to need more later, but I'll just, you know, as I go along, I'll add a vector of addresses in a vector, cities, vector states, vector zip codes, vector of student numbers, vector majors, vector GPs. No, no, no, no. And pretty soon, everywhere where you had some code done, and you used to pass this function, three vectors, now you modify it to pass it four vectors. You got to find a modified function header, modified function header prototype, modified variable, it calls it to add another variable to call that function. Then as you add another variable, you got to go modify code, you got to modify code. Instead, what if you started out by saying, hey, I don't know everything that's going to go into a student, but let's make a student data structure and let's make a vector of students. And if I add anything to the student data structure, I still only have one vector. Same idea here. So let's call it like a square in the, in the, ship. And I think, let me see if I, what term I used. Yeah, like I say in the project, like I say, discovered means that this square has been added to the search container. So let's, I just want to check consistency here. Let's go with the word square. So I need a square data structure. Like what is one place in the map? Well, at least, it's got to have a character. And as I discover one or two other things that I need, I can add them to that struct, let's say, and I'll always have a 3D vector of those structs, regardless whether there's one thing in the struct or two or three. I'll always have one 3D vector. Now, you may say, hey, Dr. Pellety, do we have to use a 3D vector? No, you don't have to use anything. You're going to need to be able to end act stuff. So you could instead of doing a 3D vector, you could do a 3D pointer where you do all the news and all the deletes yourself, but it doesn't really gain you anything over a vector. That just adds work and adds potential errors because you might forget to delete something, etc. So there's no real advantage to using 3D pointers over 3D vectors. You might say, well, wait a minute, what about that thing we learned in 280 where we can like, we can fake a 3D data structure by just having a 1D and we do all the math ourselves. That's possible too. But I don't think it's worth it to do all the math yourself. Is it a little bit faster? Yes. Is it worth the trouble? No. Because when I wrote the solution that your timing needs to be meeting those goals, I used a 3D vector so you can get all the points without doing all the math yourself. So I wrote a pretty straightforward solution. I avoided stupid mistakes. I didn't do some optimizations I thought of. And in one place, I was actually a little bit wasteful of memory just in case you were because it makes sense to do it that way. And so I tried to write a middle of the road solution. And then the autograder adds 50% to my time and 38th extra to my memory is your goal. So if mine runs in 10 seconds and yours runs in 15 or less, you still got full points. So you don't have to do things like changing from 1D to 3D and vice versa just to get the points on it. If you find that that is the only thing you can think of, there's probably something else you missed and that's a good time to come to office hours and say, hey, you know, got a little bit of efficiency trouble. Can you help me here figure out what's going on? Okay, now where was I in my notes here? Okay, so we're going to need a 3D vector. We're also going to need the the project spec talks about the search container. We're going to need a search container and that's not a 3D vector. The other thing is the data type that goes in the 3D vector and the data type that goes in the search container should be different types. If you try to make it one data type that goes in both of them, it's going to be bigger than it needs to be. And so making the especially the 3D vector, the thing that goes in the 3D vector, if it's bigger than it needs to be, it gets really big because it's multiplied by number of levels times the size times the size. And so a little bit extra, a little bit too much in there makes a big difference in the 3D vector. And so if you make one generic data structure for both containers, it's going to be too big. We want just the info we need in the 3D vector and just the info that we need in the search container. Next thing, when you read in, it doesn't matter what input mode the file is in, the internal data structure is going to be the same. There's going to be a 3D vector whether you read a map input or a list input, we want the 3D vector to be exactly the same data structure and that way the searching code is exactly the same. So there's like two different ways to read input. The searching code is always the same. And then the producing the output could go one to two different ways. But we know the output code is going to be the same no matter what the input is. So no matter what the input mode is, the searching code is the same and the output code is the same, although the output's going to have to have two sections, one for list output, one for map output. So what do we need to remember? Well, we need to remember that station, the 3D data structure for the space station. We've got to remember our command line options at whatever point we read those in. We have to remember them. We should also keep track of maybe not just maybe not just the 3D vector, but maybe hey, as I'm reading in the map, whether it's map mode or list mode, maybe I should remember like where is the start? You know what level row column is the start in? What level row column is the end in? I might need to know that information later. And you say, well, wait a minute, what if I don't need those? Isn't that a waste of memory? It's not that big a deal. It's the start location and the end location. There's they exist. There's not millions of them. Whereas I could give you a map that says, hey, you know, this is map mode. The there are 10 levels. Each level is of size 5,000. That's 5,000 times 5,000. 25 million times 10 levels is 250 million things in the 3D vector. Whether you keep this end location as a separate data structure or not, not very big compared to the 250 million squares in the input. So when we talk about worrying about memory, we want to worry about what goes in those containers that like the 3D vector, we know the size, but it could be big or the search container that I don't even know how big it is. The search container could have five things in it or 5,000 or 100,000. It's going to grow and shrink and that's what I want to raise us. I don't want to make the stuff in there too big. I don't want the stuff in the 3D vector to be too big, but like you don't want to worry about, oh my gosh, can I can I save two bytes by not keeping track of this variable? Who cares? Compared to the 250 million, those extra couple bytes are not a big deal. Okay, another thing which I put in the projects back and it's important to remember and I told my staff, let's try to be consistent about this in like, off-sourge and piazza posts and stuff like that. Couple big concepts. Discovered and investigate. So discovered is a concept and it's also something we have to remember and the project one STL and you and my example in a little bit will tell you, will show you why you have to remember it. So discovered is a concept and it's something we've got to remember in a convenient way to get back at that info later on. Investigate is a concept that we don't have to keep track of. So discovered is when things go into the search container. Now we have to keep track of that because we never put something in the search container that's already been discovered in the past. Because if we did that, then we could end up with a case where I go like, hey, I start here and oh that just happens to be in the corner and there's a floor here. I go over there and I say, yeah, I can I can discover this and then I start from this one. I say, wait, I can discover that and I just keep bouncing back and forth between those forever. So that's why we never want to discover something more than once. So anytime something goes into the search container, it's discovered and we've got to remember that it has been discovered and then investigate is basically when I say, hey, I went from the start over to the data, now I have to take out of the search container, right? Something comes out of the search container. Investigate is when I say, hey, where can I get to from here? Investigate is saying, well, I'm at a dot. I could look north, oh no, I can't, that's off the edge of the map. That would be dangerous. Okay, what about East of me? Well, East of me is not off the edge of the map. It's not a solid wall, so that's safe and it's not already discovered. So I could discover the thing to the East of me. So discover is when you put it in the deck, investigate is when it comes out and you look around to see what else you can discover. So investigate is basically the process of discovering other things. So we have to keep track of what we discover, but we don't have to keep track of what we investigate. So discovering is putting them into the deck. Investigating is what happens after we take something out of the deck, out of the search container. Okay, hello Spencer, yes, you're a good kid. Okay, so now what I'm going to do is I made an example that is not anywhere else in the projects back, etc. I'm going to make this little example and what we're going to do is run through it for both stack mode and q mode and we're going to also show what information we have to keep track of and it'll so help you see why the output is different for stack mode and q mode. And after we do this big example, I got a bunch of other tips I got a little bit listed below this example. So, all right, so here's my example. So whether it's mat mode or not doesn't matter, but I'm going to write it as mat mode because it's easier to write out. M2 is a number of levels 3 is the size of each level and I could or could not have a comment for what the levels are. I could or could not have a comment like hey, this is the video video example video example and I've got a comment like level 0. So the level 0 comment does not have to be in lower case, it doesn't have to have no space after the slash slash it can be anything I want. So it's just a convenience. So I've got dot dot e actually that was my idea. It doesn't really matter, but let's put a number sign in here. Not number sign dot and dot dot start, okay, and then level 1. We're going to have dot dot e dot dot h dot dot dot. So here's one that we have to use the elevator. So I wanted to do an example like that because it's important to see what we have to keep track of and it's one that will give us different output for stack or queue mode. So let's go through this. So that's what the input looks like. Now what I'm going to do is I'm going to redraw that in a way that's going to allow me to modify it a little bit easier as we go through the example. So what I'm going to do is actually modify my text file, put a number sign and I change the middle of the level 0. Okay, so this is like my 3d vector. So this is index 0 of my 3d vector. I'm going to make it big so I can put those stuff in here. Actually, let me just change that slightly. I'm going to put the character a little bit to the left, so I've got room for other stuff. Okay, so there's level 0. Here's level 0. I have two of those. That'll allow. So level 1, I have this. And then this one has an e and h and then the rest is easier. It just dots. Open the floor. Okay, there we go. All right, so what I'm going to do is I'm going to run through this example in Q mode and then we're going to discover something about this one we decide to print output. Okay, so so we're going to do this with as if it was dash Q and I don't care about the output mode because we don't need to get to that point yet. So if we look at the routing scheme, important part of the project spec, which is on, I'm going to look it up here a little bit quick here. So the routing scheme is like bottom of page 3 to the top of page 4. So the routing scheme. First thing we have to do is we've got add to our search container. Okay, ooh, I've got a draw search container. So my search container and what I'm going to do is I'm going to draw this as if this is the front and the back goes out this way and I'm going to add things to it and take things off of it, etc. Now, I've got to add the starting location to the search container. Well, how do I add the search container to it? Is it sufficient to just put an S? What if I took out of the search container adopt and said to say, well, where am I in the 3D vector? I got a dot that could be anywhere, almost. Okay, so I can't just put an S in there. I've got to put something in there like, hey, what goes into the search container is like 022, like a room or row in a column. Okay, so I'm adding 022. That goes in there and it gets discovered. That's what my check mark means. So that has been discovered. So this is the routing scheme, but this is before we start loop it. So we've got to put the start in there, so prime the pump is an English expression. We have to put something in before we take something out. So we put that in and now the routing scheme says basically, now once that's in, we've got to start looping as long as the search container is not empty and we haven't found the solution, we've got to keep searching. Okay, so what it says is basically there's some steps listed. So the first step there, step one is basically says, take the next location from the search container and we're going to refer to it as the current location. Okay, so I've got to have a new check. Keep this everything invisible here. Okay, so now we have the current location. So my current location is 022. Okay, and then I'm going to pop that. I remove it or pop it from the search container. Okay, so from that location, what do we do? Step two says, investigate all the locations that you can reach from the current location. So that means north, east, south, west, in that order. Okay, so I say, north and me and every time I do this, I may not remember to say it, but we got to think it. Every time we check a direction, we first have to say, is that direction valid? Like, can I go north from here? Okay, well, if I'm not and row zero, then it's okay to go north of here. Okay, so it's safe to go north. It is not a solid wall, so it's somewhere that I would go and it's not yet discovered. Therefore, I can discover it. So what we do is we put a check here and the order of these two steps doesn't matter. We put a check there and we add it to the search container. So that would be zero, one, two, level zero, row one, column two. So we add that to the search container. So that was north of the current location. We're still investigating the current location. We discovered one thing, north of us. Now we say, what about east? That would be off the edge. Do nothing else, because anything else would be an invalid index, sag fall, all kinds of bad things. All right, what about south? That would be off the edge. No. All right, what about west? Okay, west is of the location that exists. We haven't discovered it yet. It's not a solid wall. So we should discover that. So we should add zero to one to search container and market as discovered. Those two things should always happen together. You put it in the search container, you market as discovered or vice versa, but they always happen together. Okay, now the other thing we got to do is we've got to do what it also says in step two is also if this thing is an elevator, oh, it's not the current location is not an elevator. So we don't have to do that part of step two. All right, step three basically says as soon as like if we if any one of these, the north or the east, south or west, or elevator, if any of these had resulted in a hanger, we would stop searching, but that didn't happen. Okay, so we'll go back to step one. All right, step one says get a new location from the search container. Now this one, the current location is not a container. It's just a variable. When I cross that out, it's gone. So current location is now zero, one, two, and that gets removed from the search container. All right, now from zero, one, two, I'd go to, so I was step one, take the next location out, step two is investigate this location. Okay, zero, one, two is north of a year of valid location. Yes, it is. Is it solid wall now has been discovered? No, that's good. So I can discover the location north of me and add zero, zero, two to the search container. Okay, what about east of my current location? No, it doesn't exist. What about south of me? It's a valid location. It's not a solid wall, but I've already discovered it. So you can't do that. All right, what about west of me? It's a valid location. I've never been there, but it's a solid wall so we can't discover a solid wall. All right, that's north of east southwest. Am I standing on an elevator? No. Okay, we're done with the current location. Go back and we didn't find the hangar, so we go back through the loop. Okay, give a new location. Okay, new location is zero to one. And here's where you might be tempted to say, wait a minute, I thought we could only move north east southwest. You just went from this one. You just teleported on a diagonal. No, I didn't. Because remember, you the person are still standing right here until your trusty robot companion finishes running this program. Your feet are glued there. The robot's program is investigating this one and then investigates that one. It might investigate some very different locations in a row, but that's okay because there's just computations. Once the robot is done and prints out a map or a list of a list of steps to take, map mode list mode, that's when you start moving your feet and then you will actually only go north or west. All right, so don't worry about it if it looks like your teleporting. You're not doing anything. The robot's still running the program. Okay, so current location is zero to one. We take that out of the search container and we investigate zero to one. Okay, zero to one is north of me a valid location. Yes, it exists. Has it been discovered? No, is it a solid wall? Yes, oh, can't go north of here. All right, east of me, east of me exists, but it's already been discovered. Can't do that. South of me does not exist. West of me, west of me does exist. It's never been discovered. It's now solid wall, so we can discover west of me. So west of me gets marked as discovered and we add zero to zero to the search container. Alrighty. And then last thing, am I standing on an elevator? No. Okay, none of those really hangers, so we go back to step one. Get a new current location. New current location is zero zero to pop it out. All right, zero zero to. So we start investigating this location. Is it, uh, sorry, go to North East Southwest, always do North East Southwest. Does North of me exist? No. Does east of me exist? No. Does south of me exist? Yes, but it's already discovered, so forget it. All right, what about west? West of me exists. It's never been discovered. It's not a number sign, so we can add one west of us to the search container. So that would be zero, uh, zero column one. So zero zero one gets added to the search container. Then the last, oh, and we marked as discovered, forget that. Then the last thing we do is we say, hey, I'm still in step two here. Am I standing on an elevator? I am standing on an elevator. All right, if I'm standing on an elevator, what I have to do is I have to check every level from zero up to the maximum and check if there is a capital E in that same row column. Is there a capital E there? And is it already discovered? If not, we discover it. Now you might start thinking, well, what about if you E onto a, if you take an elevator, but the elevator is next to a hanger? No, no, no, no. We don't worry about who's next to who until it comes out of the deck. How does the search container? So right now we're standing on an elevator, so I say, okay, let's check from level zero all the way up to the maximum level, which would be level one. So I've got to say, is there a capital E there? So I'm checking level zero. You might say, well, wait a minute. I've got to say if it's not the same as the current level. No, because I'll say, hey, level zero is there at capital E there? Yes, there is. Is it already discovered? Yeah, it's already discovered, so we can't discover it again. So you don't have to check if it's the same as the current level. All right, level one. Level one, is there a capital E there? Yes. Has it already been discovered? No. Therefore, it can be discovered. So that capital E gets discovered and it gets added to the search container, which would be one zero two gets added to the search container. All right, then level two doesn't exist. Our loop is done. We have to loop to check all the floors, right? There could have been three floors or four floors, seven levels. I think I just got a loop from zero up to less than the number of levels. Hey, sounds like maybe when I read the input, I should remember in my space station or whatever I call my class, besides the 3D maze itself, maybe I should remember how many levels are in it? What is the size of it? Because all these things where I say like, disease to me exist, well, to know if he's to me exists, I need to know how big the level is. So, hey, a couple more variables. What's the number of levels? What's the size of each level? Okay, I've finished with my current location. Did I find the hanger? No, because I haven't. I haven't gone from somewhere that could see the hanger. I haven't taken anyone out who is next to the hanger. So I got to go back to the search container. Search container says we got to check out and investigate next location. Okay, next location is zero to zero. Zero to zero. Cross that one out. That's my current location. So my current location is level zero, row two column zero. So I start doing my normal things. Does Northamia exist? Yes. Has Northamia already been discovered? No, is it something I would walk on? Yes, now it's a solid wall. So I can go north of here. So Northamia gets added to the deck. Okay, I mean, another row for the search container here. Let's just draw a line in there. Okay, so the next row of the search container would be Northamia would be zero, one zero. So that gets added to the search container and it gets marked as discovered. Okay, so that was Northamia. East of me does it exist? Yes, has already been discovered. Yep. Okay, done with that. Southamia doesn't exist. Westamia doesn't exist. Right, we're done. Oh, and is the current location an elevator? No. So we're done with the current location. Go back through the loop. Get someone new out of there. Zero zero zero one. So zero zero one gets, whoops, gets taken out of the search container, becomes the current location, and then we start investigating zero zero one. Does Northamia exist? No. Does Eastamia exist? Yes, but it's already discovered. Does Southamia exist? Yes. Is it discovered? No. Is it a solid wall? It's a solid wall. So I can't go discover that one. How about Westamia exists? It hasn't been discovered before. It's something I would walk on. So let's discover that one. That one goes into the deck. That would be zero zero zero. Okay, zero zero zero goes into the search container. And am I standing on the elevator? No. Okay, I'm done with the current location. Go back through the loop. Take a new location out. One zero two. All right, take that out of the search container. And now we investigate it. Does Northamia exist? No. Does Eastamia exist? No. Does Southamia exist? Yes, it does. Has it been discovered? No, it hasn't. Is it a solid wall? No. So I could discover it. So I can discover Southamia would be one one two. One comma one comma two. We market as discovered. And then we say, Hey, that's the hanger I'm done. I don't check West of me. I don't check if I'm an elevator. As soon as I see that hanger, time to stop. All right, so I stopped my searching and then I would be say, Hey, it's time to produce the output. Right? Oh, wait a minute. How do I produce the output? I can't start back at the beginning. The beginning went two different ways. I don't know which one of them led to the goal. Well, remember, every location in this map has either been discovered or it has. Now those that are discovered, remember, they only get discovered once. Because a location can get discovered at most lots. If it's discovered, there's only one place that you could have been before you were there. I talk, I think it has like the predecessor. You could call it the previous. You could call it the path, whatever you want to talk, whatever you want to call it. But everybody has a unique way that they got there. So let's sort of think and reverse a little bit. When I found the hanger, where was I? Oh, I was right here. I was right there when I found the hanger. So somehow in the hanger, besides just putting a checkmark, I need some more information. I need the hanger to know how it got there or where it came from. Whatever sort of thing makes sense to you. So what would I like to print when it's output time? When it's output time, well, I'm going to need to print an S, but not in this way, be different square. That's a little bit tricky. But you could think of it and how you record it isn't important. At some point in the code, there's going to be reverses where you say like, I got here by moving south, that means I came from the north. Or if you record it as I came from the north, at some point you'll have to print it as an S. So whether you think of it as the direction I moved north east southwest or the direction I came from, you're going to have to reverse it at some point in the code. So I'm going to go with what I would have to print eventually in a different location, but I would have to print an S. So I'm going to say, hey, I got here by going south. Okay, well elevator, elevator, how did you get there? Okay, because remember, everybody has a unique predecessor. I can work my way back from the hanger to the start. Okay, so elevator, how did you get there? I took an elevator. Wait a minute, that isn't useful. What if there's a capital E here in four or five different floors, which floor did you come from? That capital E is not enough. Okay, so a capital E there is not enough. How did you get here? Well, how about where I came from? Right? Because I got to work my way backwards from the end, from the goal to the start. To get from the goal to the start, I would have to say, hey, I came here from floor zero. All right, floor zero, how did you get there? I moved north. Okay, square south of that. See, I said you're going to have to reverse it. So if you got there by moving north, the square south of there, how did you get there? Well, I moved north. Okay, well, square south of there, you're the start. You're really special. Like you're discovered, but you don't really have a predecessor, but you're the start. Okay, so that is something else we needed to keep track of, yes, hello, Spencer, that's something we needed to actually keep track of the whole way through because we can't just say, hey, now that it's done, what did I need to put there? No, we really needed to do this the whole way through. This one needed to say like the level zero, row two column one. This one needs to say like, I got here by moving west, got here by moving west, got here by moving north, got here by moving west, and the zero, zero, zero, I forget. Zero, zero, zero, I think, came west, I think. I can't remember. Not critical because it's not the path, but we really had to record that information everywhere. As we were doing the searching, we didn't just need to keep track of the, how do you been discovered? We had to keep track of how do you get here? Where did you come from? So we need to do that whole thing. So now, if we were to modify like our searching code so that every time we discover something, we add it to the search container, we mark it as discovered, and we keep track of how did you get here? Now, we can't overwrite like the dots with all of those because then we wouldn't have a dot to print anywhere. So we can't modify the like character. We got to have some information about how did you get here? Now, how many possible ways this is this is a memory issue? How many possible ways are there to get to here? Right? I'm at a location. Well, I know the only way to get here. I mean, great. I've only got one predecessor, but without knowing anything, the number of possible ways I could have gotten to this square is from the northeast southwest or from one of 10 other floors, or it could be the start location, which is kind of weird. It's discovered, but doesn't have a predecessor. Or maybe it's never been discovered at all. So there's about 16 ways, 16 possible predecessors that anybody could have. Any square can have one of about 16 predecessors. And the way I've drawn it is actually a way that's efficient to do it. What I put there is right. What? A character? A character is efficient. You might say, well, wait a minute. Can't I put a level a row in a column there? Sure. If you want to take up four bytes for a level four bytes for a row and four bytes for a column, you could use 12 bytes instead of one, but memory trouble. All right. So then when it's time to produce output, what you have to do is when it's time to produce output, you have to first know, did I have a solution? Yes or no? Well, that was easy because I found the hanger. I have a solution. How do I know that? I might have another variable in my class that says, do I have a solution or not? So if I've got no solution, then the output is pretty easy. But if I do have a solution, I have to backtrace, which means looping. I've got a loop from the hanger backwards one square at time, following directions back to the start. But that's not the directions. I didn't go south come from zero north north. I went north north, go to floor one and go south. So you need a data structure for producing the output that basically you kind of be able to put things in in one direction and take things out in the opposite direction. Sounds like stack. Vector could do the job also. A deck could do the job, but it's got to be some sort of, it can't be a queue and prior to queues is project tube. So that's not the every the answer in this project. So you could use stack, use vector queue is a deck, but you got to be able to go from the hanger to the start and then print the directions. If it's list mode, you print the directions from the start to the hanger. And if it was map mode, what you could do is you could go from the start to the hanger and modify what's in the map. You could say, hey, just for the things in the path, let's go modified and say, hey, that capital S can change colors again. That capital that capital S is not a capital S anymore. That is an M. This is not a dot, that's an M. This is not a capital E. It's a one to tell me go to floor one. So you got to reverse it again. Go to floor one. This isn't a capital E. This is a S to say go south. And I really do want to print the capital H. Alrighty. So that's what the output looks like if we did it as a stack or sorry, as a queue. Okay. So that's what would happen if we did it as a queue. Let's, I'm not going to run through the whole example of everything in the container. I'll do everything there. It's not going to be too bad. It'll be about the same hour. Okay. What I'm going to do is take me a second here. You erase this stuff. I used, raised a little too much of the E there. Okay. Let's do this stuff. I have the other one to do also. Okay. Vectorize the erasing, which is good that I don't have to hit every pixel, but I do have to hit every object that was drawn. Okay. So I got to get these. Okay. I got to fix my capital E. Alright. So now, oh, and I got to erase that dash S because I'm not doing dash S anymore. Okay. So now we got to do dash or to queue any. If you're really queue, we're going to do stack mode. Okay. It's changed back to blue. So now this is going to get a little painful because I don't think I have enough room to put the whole stack in here, but we'll try. Let's change things just a little bit. Let me erase the door. Okay. Alright. So we're going to do dash S. This is going to be my current location. And this is going to be my search container. So this is the bottom of the stack. The stack is going to grow upward. And I'm going to have to cross out stuff possibly. We'll see what happens. Okay. So that's going to be the search container. That's the stack. And that's going to be the bottom of the stack there. Okay. So we start out exactly the same. We put the start location in there. Okay. So the start location goes in there. That's zero, zero column two or level zero, row two column two, zero two two. It goes into the search container. And then we mark it as discovered. And now we can start to do it. Okay. So we pop off of there. So we get zero, two, two is our current location. Pop it off the stack. And now we start investigating this location. So go back to the northeast southwest. Can I go north of here? Yes. Is it already discovered? No. Do I walk on it? Yes. Okay. So that's level zero, row one column two goes into there and we mark it as discovered. And also we should mark it as hey, I moved north to get here. All right. So that was north. Disease to me exists. No. Does south of me exist. No. Does west of me exist. Yes. Is west of me discovered? No. What I step there. Yes. It's a dot. Okay. So that's zero, two, one goes on to the stack and gets marked as discovered and gets marked as like I moved west to get here. And am I standing on an elevator? No. Okay. Go back through the loop. Take one off of the search container top. Make its current location. So zero, two, one. Pop it off the stack. So that's my current location. Now zero, two, one. Does north of me exist? Yes. Has it been discovered? No. Is it somewhere I would walk? No. It's a number. Okay. Can't do that one. All right. East of me. It does exist. But it's already been discovered. South of me doesn't exist. Don't do anything else. West of me exists. West of me is not been discovered. It's somewhere I would go. So that would be, rest of me would be zero, two, zero. Goes on to there. It gets marked as discovered. I moved west to get there. Okay. So I've done north-east southwest. Am I standing on an elevator? No. Okay. So go back through the loop. Get a new location. So my current location is zero, two, zero. Pop it off the stack. All right. Does north of me exist? Yes. Has it done discovered? No. Would I walk there? Yes. Okay. So north of me gets at. So that would be zero, one, zero. It's at the stack. It gets marked as discovered. How I got there was moving north. Okay. So that's north of me. What about east of me? East of me does exist. But it's already been discovered. South of me doesn't exist. West of me doesn't exist. All right. Back. And I'm not on an elevator. So I'm done with this square. Back through the loop. Get a new location. Zero, one, zero. Pop it off the top. Okay. Does north of me exist? Yes. Has it been discovered? No. Is it walkable? Yep. Okay. So we add that once that would be zero, zero, zero. It's added. It gets marked as discovered. It gets marked as how we got there. All right. So that's north of me. East of me exists. East of me is not discovered. But it's a solid wall. So we don't do east. South of me exists. But it's already been discovered. West of me doesn't exist. I'm not an elevator. So I'm done with the current location. All right. Back through the loop. Get a new location. Zero, zero, zero. Is my current location? Pop it off the stack. All right. Does north of me exist? No. East of me does exist. Not discovered. Woodwalk there. Okay. So that's zero, zero, one. It's added to the stack. Marked as discovered. Move east to get there. All right. So that was we took care of north east. What about south of me? South of me exists. But it's already discovered. West of me doesn't exist. Okay. North East southwest. Taking care of a mountain elevator. So I'm done with this location. Back through the loop. Get a new location. Zero, zero, one. Pop it off the stack. All right. Zero, zero, one. Got to investigate it. North of me doesn't exist. East of me exists. East of me is not discovered. East of me is somewhere I could walk. It's not a solid wall. So we got to add that one. So that's zero, zero, two. It's added to the stack. It's marked as discovered. It's marked how it got there. All right. So that's east of me. South of me does exist. Not discovered. But I can't walk out of solid wall. Okay. West of me does exist. But I've already been there. All right. I'm not standing on an elevator. So current location is done. Back through the loop. Get a new current location. Zero, zero, two. Take it off the stack. All right. Zero, zero, two. North East southwest. North of me doesn't exist. East of me doesn't exist. South of me exists. But it's already discovered. West of me exists. But it's already discovered. I'm standing on an elevator. So I run through all possible floors. Zero through highest possible. So floor zero. It has a capital E, but it's already discovered. Okay. Check floor one. Floor one is a capital E. It's not discovered. So we add it. So that would be one, zero, two. It gets added to the stack. And it gets marked as discovered. And it gets marked. This one has to be a where you came from. You came from zero because I have to be able to back trace from level one to level zero. Okay. So that one's got to be a which floor you came from. Okay. So that's floor one. Level one is done. Loop's done. That's all the levels that exist. Okay. We're done with this location. We go back through the loop. Get a new current location. One, zero, two. Is under location. Pop it off the stack. Now start investigating. North of me doesn't exist. East of me doesn't exist. South of me does exist. It's not already discovered. It's somewhere I would step. It's not solid wall. So South of me gets added to the data structure to the search container. So that would be one, one, two. It gets added. One, one, two gets marked as discovered. How did I get here? I moved South. That's the hanger. I'm done searching. Okay. Time to produce output. Well, to produce output, I would have to go backwards from the hanger to the start. So it's the hanger says I came, I got here by moving South. That means I must have come from the north. That one says I came from floor zero. That one says I moved here by going east. That I moved here by, so let me just actually just get my pen color different. So sure show what we do backwards. So I say, hey, I started at the hanger. Hanger came from here. That one came from here. That one came from here, which came from here, which came from here, which came from, whoops, which came from here, which came from here, which came from here, which came from here, which is the start. So that's how I backtraced back to the beginning, put those in a stack or a vector, and then I reverse it from start to hanger. I can either print out the directions in coordinate list output, or I couldn't modify the letters in the map to produce map output. And then once I modify the maps, see I've got to run a loop to say, hey, let's run a loop to modify the map characters that are in the path, then I got to have like a triple nested loop to go printing out the map characters. Okay. So now you see the difference why the output could be the output could be different between stack and Q mode, because things get searched, things get investigated in a different order. Okay. So that's the output stuff. Okay. So now I got a few tips and then we're going to call this video done, go upload it. Okay. So tips. Okay. One thing and it's in the it's in the spec. It says when you're looking for comments, it's sufficient. If you see one slash, you can call that a valid comment and you don't have to look for a second one. And that's especially important for list input mode, because list input mode, I'll talk about that in a little bit. Do a few tips on that. Okay. Now another thing, if you are doing what we said, and you're using a deck, and you do what we said, which is like I said in the in the project one, STL new, the way I thought of it is I always push to the back. Then if it's supposed to be acting like a Q when it's time to get the next location, I take it from the front of the Q. So I copy the front and I pop front else if I'm supposed to be a or really just else else. I'm if it's not a Q, it must have been a stack. I should take from the back and pop back. So really, yes, I'm using a deck. I either add to the back and take from the front if it's Q or I add to the back and take from the back. If it's a stack, it's kind of like a stack that's laying on its side, right? I push and pop from the same end. That's a stack. Now, if you see that like, hey, for this map, I get the right output in stack mode, but not in Q mode or vice versa. And you go, oh my god, it's the deck. I use the deck raw or the deck doesn't work. No, remember that we took a different path through the map and taking a different path through the map might have encountered a bug in your code in one path that just didn't happen to run into that buggy situation in the other path. So if you get like one right and one wrong for stack and Q and you're using a deck, it's probably not the deck fault. It's probably some little situation that you encountered in one possible route that you didn't encounter in the other route. Okay, so list mode. When you do list mode, you don't want to use get line until you get to a comment. Now, comments you always want to use get line. As soon as you see that slash, whether it's map mode or list mode, do a get line and ignore the rest of it. But in stack mode, you don't want to use get line except for comments. You want to read with greater than greater than. So I've got like a list mode always looks like this. Align in list mode either looks like slash slash something or it looks like parentheses number comma number comma number comma some character parentheses. Well, what do they have in common? They both start with a character. So if I see in greater than greater than into a character, then I can check, hey, if that character is a, oh, wait, wait, let's not just let's not end that there. So that can check and say, hey, if that character is a slash, I do a get line and I'm done. But if it's not a slash, it must have been a parentheses and then I can see in some more stuff. Also, I can put this in a while while while you can do that. So while I can read a character, there must be another line. If if it's a slash, I can do a get line. Else, else, I got to do a bunch of code. Else, what I can do is I can say, hey, see in goes into some type of integer, not a character. Here, it might work, but it's a pain. So it goes into some types of integer. Let's call this level. It goes into some type of character, which is the comma, then it goes into a row number and not not a character because the row number could be one digit, three digits, four digits. So it's got to be an integer, some type of integer and unsigned in, you in 32T something like that. Spectals you what it's safe to assume about these. So then I could read into a character, I could read into a column number, I could read into a character, I could read into a important character like what is the square type. And then I could read into a character. Which is that closing parenthesis. What I see lots of people doing, I can tell who didn't watch the video because they're going to go, oh, I'm going to get line. And if the first character isn't a parenthesis, or if the first line is a parenthesis, then I'll take that string and I'll turn it into a string stream and they'll take the string stream and I'll use greater than greater than get stuff out and how do you want to process the line three times? You process it once to get line, then get it turned into a string stream, then it could be getting out of the string stream. And instead, you could just take it directly from cm, process the input once. Okay, how do you change from characters that are digits, single digits to an integer and vice versa? Look in the project one STL and you it's in there. List mode output I can found is a little bit easier because you don't have to both modify the output and produce the output. You just kind of have to do the backtrace and then go through one from hanger to start saving stuff and then from start hanger printing stuff. For map output, like I drew in here, be willing to modify the characters, be willing to say, hey, this start because I went backwards, hey, the hanger is still a hanger, but this capital E actually went south. This one actually, this capital E went to floor one, this dot moved east, this dot moved east, etc. Be willing to modify those because then you just need a triple nested loop to just output the map characters, map characters, some of which are the original dots or number signs and some of which are the modified stuff. Okay, that's all I've got for this video. So I'm going to finish this up, get it uploaded, and it'll probably take a while to get it visible on YouTube. Okay, stop recording. All right, good luck on the project, everyone, and we'll see you in off-sourge if you need help.