 Hey, welcome to the first project walkthrough for Eeks 370. In this video, we will go over the spec examples. We want to read through the full spec, but hopefully this should illuminate some of the finer details of the spec that are easy to mess. So welcome. All right, so to get into it, our first project is all about the basics of an ISA. So this will form the basis of what we'll look at for the rest of the semester. And so in this project, we will be implementing three main parts of an ISA by looking at else to K. So the first part in project one, a will be a assembler. It's why we call it project one, a. And in the assembler, we will translate from human readable assembly code to machine readable machine code, which is just a bunch of numbers really ones and zeros a binary. And then after we've done that, we will take those machine code programs that we generated with our similar. And then we will run those through a simulator and the simulator will simulate registers the PC, the main components of a CPU, the most basic type of CPU that could run the LCHK I say. And then finally, we will be writing some code in a simply language, or we need to do that in order to understand what the ISA is actually doing. And so we will be doing that in project one M aim is for multiplication because that's the program that will be writing. And then you'll also be writing some assembly code in your tests for the first two parts. So it's a lot of this project. Most of these have different due dates. So it's broken up a little bit. And this should give us an easy way to get started in the course. Before we look really deeply into the details of all those three parts, I want to show you something that I typically like to show in my lab sections. This is a graph from the winter 2023 semester showing the final score of all students as a function of their first submission time. And so you can see that those who start, let's see if this was the deadline right here, those who start, you know, at least three days before the project deadline were like pretty much guaranteed at least an 80. And so that's pretty good. So if you start at least three days before the project is due, you have an 80, of course, we have a few outliers, like I don't know what's going on here. And then even if you don't start early and you things happen and you get a bad score, you can use late days. That's what's happening over in this range. But I really would recommend against that for project one, since projects to L three and four in particular are much, much more difficult. I would recommend using no late days for any part of project one, but we will be reusing parts of project one for the rest of this semester. So it is absolutely critical to start early with this project. If you're in the spring term, we're moving at double speed. So two days is probably reasonable, since we give you six submits per day, but I really wouldn't push it out of it, start as early as possible. Once you kind of figure out what the projects are doing, it's not that much to code up. You'll have a little few bugs here and there, but getting the base concepts, right, is the trickiest part with this project because it's brand new and we're at the beginning of this course. So definitely start early. This is the same thing for project one S. In my opinion, project one S is a whole lot easier. I think I don't show the late days in this graph. So you can kind of see the trend going like this. And if we look back here, the trend is like this kind of going with like the lowest discounting all the outliers that's kind of like the baseline score, the minimum expected score, I suppose. And here's that same thing with project one S. So you can see it's a little bit higher because project one S is probably a bit easier. Still, I would recommend not messing around with it and taking too long. And then finally, here's the same thing for project one M project one M doesn't have nearly as many like test cases that we give you on the auto greater. So these other projects have maybe like 20 something test cases each and they're all different point values. Project one M to my memory has like 10 test cases and they're all worth like two points each. So that's why you don't see scores that aren't multiples of 10 on here. But project one M it's it's much more by model. So either you get it or you don't there's not going to be like a halfway mark for project one M like like we see with the other projects here. So that's why we see a lot more even those who started more than three days before the deadline, I'm not doing so well. So definitely starting early is absolutely key. Now let's actually get into the project. So again, the whole point of the project is to let us implement three main components of an ISA. And so let's do a little bit of review before we get into one a. So an ISA, which seems for instructions that architecture gives us a set of instructions. And then it tells us how those instructions move data rounds. So that's the architecture part defining where different things go. And so our big example for this semester will be LCTK. And so I'm going to show you all the different instructions that we have to make up that set of instructions in the next slide. But some other things that you need to know about LCTK that really define the data flow are as follows. So first LCTK is a von Neumann architecture. So that means that data instructions are in the same memory. So when we think about ex 280 and we have all this data, we've done a lot with pointers and point pointer arithmetic. And if you have ever printed out a pointer to see out, you'll see that it's just a member. And so those numbers are references in memory. So the idea of data instructions being in the same memory is that instructions will also add those pointers. And they'll be like back to back. So if you were to go through all the instructions and print out all those pointers, once you finish, then you would get into the different pieces of data that we have in our program. That is a von Neumann architecture. One thing to note, this is not true for the LCTK simulator that is on our website. In that case, there are actually separate conceptual data and instruction memories. So if you index into the data memory with like address zero, which should probably always be an instruction, then you won't get anything from data. You might get a zero, you might get something not really useful junk, you want to get an actual instruction them. Same thing on the flip side, if your PC is set to an address that is in the data section, then it's kind of undefined what it will do. I think the simulator just airs out, you might get a new up, you might get the equivalent instruction for zero, which will look at in a little bit. But in the simulator, they don't mix, but in your simulator that you're going to write for project one S, they will miss. So that allows us to do a couple of things like reflection, which is this fancy term for code that can modify itself. But knowing the difference between a von Neumann architecture and a non von Neumann architecture is very important. Also, we have eight registers in LCGK. So registers you can think of as temporary little components that hold variables, hold values, and you can modify them. You can use them for a bunch of different operations. But we have eight of them and they go from zero to set. So one error I see a lot is like a register eight. Well, register eight does not exist. And so we shouldn't see it in any of your sims. Also, LCGK has two to the 16 different memory locations and each of those is a word. That means it's a word addressable system. And so since we have two to the 16 possible locations, that means all of our addresses can fit in 16 beds. So we have this wide range of memory in your simulator. You will have to be able to simulate that entire thing. But I think it's pretty rare that we see data go into the full address range. By the way, all of our registers are also a word that's four bytes or 32 beds. And in LCGK, we assume that we're always using two's complement. And if you need a reminder of how two's complement works, go check out the lab slides. And I think the word size is generally defined by different ISAs, but typically I've seen it as four bytes. So an arm over it is four bytes and risk five over it is four bytes. And I'm not exactly certain about some other ISAs, but for LCGK, it'll be four bytes. We're going to treat that as an entire unit and entire number. So we can fit a numbers from things like negative two or like million or something up to positive to million and any of those registers or memory locations. And then finally, instructions fit in one word. So that means all of our instructions will be at most 32 bits. And our PC is just going to be an address that tells us what memory location. And we are currently executed. So the memory locations that the PC points to should contain machine code for an instruction, which I said earlier was just ones and zeros and number. And so we should be able to execute whatever the PC is pointing to. So let's take a look at those different instructions. We have eight of them in LCGK. So that means that we can encode them with just a three bit number. So we're going to call that the op code. I'll see in a second what we do with the op code. But let's real quick go through our different instructions. So we have four main types. We have our R types, I types, J types and O types. Our types that stands for registers. So whenever we have an R type instruction, we're going to be doing some operations with different registers. And so the add instruction, for example, will take two source registers, which we call register and register being and I'll add them together and then store it in a destination register. The nor instruction is the exact same except instead of adding things together, it's going to do a bitwise and or between res Bay and register B and store that result in the destination register. So again, these register A's, which should be this nation registers, they have to be a number from 0 through 7. And then within that register is going to be stored a value that could be 32 bits. So it could be anything from a really large name and a number to a really large positive number, including zero and one and anything else with I knew. So moving on from the R type instructions, we have our I type instructions and I type stands for immediate immediate means just a hard coded value within the instruction. And so typically we are going to call that the offset field. And so depending on what our instruction is, we'll do a different thing with the offset field. So look at our LW first LW stands for load word. And so load word that means we're going to take a word from memory and place it into a register. So load means from memory to registers. And so the value that will be loading from memory will be placed into register B. So it's kind of like our destination now. So we're going to take this register A, we're going to take whatever is inside register A. It's again that 32 it value. We're going to add it with this offset field, which could be positive or negative 16 that number. And then that's going to form the memory address. So it's kind of like some point or arithmetic that we did an e to 80. We can take some base, which can be interchangeable between our offset field and register A. Or whatever the indexes, which will be the other of those two, well, I have them together and then de reference and that becomes the value that we will load into register B. And then SW, which stands for store word is just the opposite. So we store register B, we take whatever is inside register B and place it into that same memory address calculation. It will be the contents of the rest of a plus the offset. So it's really, really key to know the difference between load and store load means from memory to registers and store means from registers to memory. And then we have B EQ. So let's see. So if LW stand for load word and SW stood for store word, then BQ is going to stand for branch if equal. And so like the other two I type instructions, we have two registers, register A and register B. And this time for the BQ instead of doing some like addresses with them or taking those values, we're going to compare those values to be the same. So if they are the same, then we are going to change our PC to PC plus one plus offset. So that allows us to go to a variety of different locations, other instructions in our program. It doesn't necessarily allow us to go anywhere in memory. But that allows us to to make decisions. That's the high level term to make decisions. And so one thing to note is that if we have like this instruction, for example, B EQ, three, two, and then some offset. We could still take this branch. So even though three and two themselves aren't equal, three and two refer to registers and whatever is inside of those registers might be the same value. In that case, we would take that branch to go somewhere else. Alright, so let's move on from the I type instructions. Next we have the singular J type instruction Jler. So I call it some people call it Jaller or however you want to say it. This stands for jump, jump for you and link register. So that doesn't sound like it makes a lot sense at first, which is fine. There's two parts of this. So the first part is to link, even though we call it jump and link and set link and jump. The first part is going to be a link and to link, we just take whatever our PC is at one and then store that into register B. So Jler, it has a J type that means we'll have two registers and then we won't have an offset. So just like all the previous instructions, we have a register A and register B. And for Jler, we are going to store PC plus one into register B. Then we jump, which is another word for branch. And our new PC is going to be whatever is inside register A. So that's the jump register part. So in other I say, there's like a, a JAL instruction jump and link or you first store PC plus one into register B, then you do something with the offset in order to calculate your new PC. But the jump register part means that we are going to take whatever is in register A and that's going to become our new PC. And so the ordering is really, really important here because what if register A and register B are the same. Well, first we store PC plus one into register B and then we take our register A, which is also register B. And then that contains PC plus one and we jump to PC plus one, which every instruction does. So if register A and register B are the same register, then the net effect is jumping to PC plus one and storing PC plus one into the register. So it doesn't do much, but it could be useful. And in real quick, think about what would happen if we had it the other way around. If we had it the other way around, we're re first jumped and then stored the previous PC into register B, then we wouldn't have this condition. So then it would kind of behave like any other JALer instruction. This is a special case. Finally, we have our O type instructions. I don't actually remember what the O stands for. I think it might just be like a zero instructions that don't do much. But we have two of them. The first one is Holt. And that is like an end of program type instruction. So it's kind of like the end of your main function for your thing about C. It just Holtz or exits. But one important thing about the Holtz instruction is that we still increment the PC as we do with all instructions. And then finally, we have a no op or a new. And that just means we do nothing. There is still that incrementing of the PC, because new apps shouldn't like Holtz the program. They shouldn't say we're done. We should so be able to execute a no op and then go over to the next instruction. In order to do that, we have to increment PC still. But otherwise the no op does nothing. So we'll see later in the course why we have them, even though for now it might look useless. But that is what the novel do. Okay, so now that we've gone over all the important parts of LCK, let's get into part a. So in part a, we are making that a similar. And so the kind of flow for the project will be as follows. We'll have an assembly code file and then we'll go into our part a. And then we will get a machine code file. And then that will go into our for s. And then we will get some sort of output. And so that's how the two parts of the project really work together. So by the way, one quick thing, the input doesn't have to end in AS. It can end in a bunch of different things. One of my favorites is dot LC 2k. And really that should all be lower case. You can use dot s if you want to. And there's certain reasons for that. But any type of assembly code we can feed it through part one a and we should get some machine code. So by the way, if he has a pie is going to be really, really useful. And then we also have some FAQs that will be posting in our our Google drive. So you can take a look at that. But let's get into what one a is actually doing with my favorite our spec example assembly code. So if you have the starter code to the spec, you can find this file. And this one over here, they're called spec dot AS. And spec dot mc. And I think I added a little dot correct at the end. So that you can kind of compare your generated spec dot mc with our correct spec dot mc. But these are these make up the examples that we give you in order to kind of get like a baseline version of the project working. So in the next couple slides, we are going to go through every single part of this example input and explain why it has the output that it does. First, a couple things to note, whenever you're writing else to K code, every single line of code is going to correspond to one memory location. So we are going to zero index. So this LW will correspond to address the zero. And in the next LW will have address one and two and then three or five six seven eight and nine. And so when we generate our machine code, those addresses will still hold. So that first LW. Is address zero. And this over here is address zero. So that means that that first LW instruction should translate to this number. One, two, three, four, five, six, seven, eight and nine. So we have the same length. We can see like this five carried straight over this negative one carried straight over the others. So we have a little confusing right now. So our goal is to explain why they are translated the way that they are. So let's go through it. So first we have that first number, that first line, I should say. And so we have an instruction. And we remember that our LW is an eye type instruction. And that means that there are two registers and then some sort of offset. So let's say that this is a letter, this is a letter. So that's in LCK can be either numbers, just hard code numbers. Or we can use labels. And so in this case, even though this is the word five, this is actually a label. It's going to be treat as text instead of a hard coded number. And so we're going to look at how to translate that in our code. But before we can translate, we need to know how the actual like a number format should be. LCK has the following number format. So every instruction I said was 32 bits. It's going to be treated as two's complement. But for our regular eight instructions, we are going to make the first. What is that seven bits unused? It might be a little bit more. Note that seven. And so when it says unused, that means they should all be zero. Our LW instruction, when we finally translate it, we are going to. See that there's a binary number that corresponds to this decimal number. And the first seven bits will all be zero. Thereafter, we are going to have three bits dedicated to the op code. So LW is going to translate into a three bit number. And then we are going to place it into this bit field. A bit 24 through 22. And no matter what the op code is, we're going to place there's three bits in that field. But we need to go back to this slide in order to figure out what the op code is. For LW, we had zero one zero or indecent one that's two. So our op code of zero one zero is going to go into these bits in our binary number. And then we have our register a. So we can see that our register a is a zero. And our register a belongs in bits 21 through 19. So it's once again a three bit number because we have restors zero through seven. And so when we are generating the binary translation for this instruction, we will place the binary value of zero into those three bits. So this will be a direct correlation. Same thing for register B except it goes in bits 18 through 16. So we just take the binary of one and three bit unsigned form, which is zero zero one. And I place it into the bit field for register B. And then finally, we need to figure out how to do our offset. Now, I'm going to claim that this label of five, it won't turn into one zero one, which is five in binary. Well, actually turn in to one one one. So question is why. Well, all of our labels, whenever we see them in else, educate will not be translated just as they are. We are going to translate those labels based on the rest of the assembly code file. So if we were, we're essentially going to treat five is kind of like a variable. It has some value. And so it has the value five, but that means that that variable also has an address. So we need to figure out what that address is. And do that just by looking at those addresses that we added to the side of our similar code. And we can see that five is defined at address seven. So we are actually going to take seven, which is one one one in binary. And that is going to become our offset inside the instruction. So we have to do that because our final, our final assembly code has to just be numbers. We can't have a text in our, our final machine code. And so we have to get rid of all the text and translate it into actual numbers that refer to the actual data. And so you have your thing, what if we wanted to hard code the five into the instruction. You could do that in other ISAs, but in else educated, we cannot do that. We must refer to variables with their memory addresses. So we're going to do that with five. So let's keep going. So now we have all the bits placed into our assembly code or sorry, a machine code for this number. And once again, this last number is going to be bits 15 through zero. So even though seven in binary was one one one, we had to sign extended up to a 16 bit signed number that still represents seven. And so once we get that number and we place a bunch of zeros in this unused box, then we can take this and turn it into decimal and that becomes our output. You might be wondering how we do that part. Really, you don't have to worry about that because when you're writing your C code for the assembler, all of your variables are actually stored in binary on your computer. This is something that we talked about in lab one, which all those variables are going to be in binary on your computer. So if you want to get the decimal, you can just use the percent D format specifier on your F print F function. And that will turn it into decimal for you. So if you think about this entire project in terms of binary, you only think about decimal whenever you're printing things out to the file, you will be OK. Please, please, please do not create an array of ones and zeros. I've seen that number four. Just use the standard int type in C because that's a 32 bit sign type. And that will be exactly what you need in order to do the project. If you're wondering how to get these different small bit strings into these different bit fields, think back to what we did for lab one. And think about how you can use these different bit wise operations in order to do what we're trying to do. So I recommend generally, you know, we talked about how we know that this last instruction, the offset translates into seven. You will have to implement that in code somehow. And so I recommend the following approach to your project. I recommend going through the else to get file in two passes. So when I say a pass, that means you are going to read in each line. And then once you've read in all the lines, you've done a pass. So if you want to make a second pass and you need to go back to the first line. In the starter code, we've given you a couple, a couple of functions. One of them is called read and parse. That's going to read in one line of a simply code. And then we've shown you how to use the C built in function of rewind. So that allows you to go back to the top. And so you can use those two functions in order to make your passes, but you should do the following two passes. And pass one, you should create essentially a array of labels. And that array should essentially represent this column here. All these different labels where they're defined. Don't look at these over here, because those are really uses of labels. Those aren't definitions of labels. And this first pass will allow you to translate those different offsets and uses of labels in your second pass, which should actually do the translation. So a couple of the things you can do. Most of our air checks in pass one. And so in order to figure out what air checks look like, you can look at the spec. So like, for example, we don't allow duplicate definitions of labels. So if I had another label start here, well, that means that start would be defined in two places. So that would be not a good assembly file. And so we should exits on seeing that. And you can do that in pass one. You can do most of the other errors in pass one. I don't think I'll go over many of them in this slide deck. But I definitely recommend doing these two different passes in your assembler. By the way, here are the encodings for the rest of the instructions. So we went over what I think is the most complicated instruction, which is an eye type instruction, because it has the offset. The others don't have offsets. So they're not as difficult to translate. All of them, of course, share the opcode. Many of them share rich or a and rich or b. But from this, you should be able to easily translate to all the other instructions. And with project one, you should know that there are an infinite. Well, not infinite. There's a very, very large number of possible SDK instructions. There's over six million to be precise. So you can't test everyone. One of the main components of the projects though, is to write some assembly code with enough different lines so that you can verify that your similar is working. And so you need to figure out what are the most important instructions from among all these different combinations that test to make sure that your assembler is valid. So when you're when you're thinking about that, I don't just test different op codes and things, although you should also think about all the different types of offsets that we can have. You know, numbers, which we haven't really looked at yet, but they just translate over into their binary. You should look at absolutely resolved labels for our LWs or SWs and got fills. So when I say absolutely resolved, that would include this label five that we had that translate to seven, as we just grabbed the address where five is defined and then turn that into binary and that was it. For BQs, we have relatively resolved labels. So that means if you have the same label in the offset of two different BQ instructions, the offset field, the numerical value would actually be different because the accused jump to PC plus one plus offset. They don't go to just a de referenced memory location, they jump relative to where they currently are. So you'll have to do a little bit of math and work to figure out that one in the project. Alright, so that's everything with testing that's pretty much everything with one a and so let's move on to one s. So like I said, we have this flow and I'll draw it again, where we have a similar code that goes into our assembler and then we get some machine code that goes into our simulator and then that gives us some sort of output about the actual program. So it's really important to understand why we have these different inputs. So it's important to know why we don't have a assembly file that goes straight into our simulator and it's important to know why we don't submit machine code to the symbol because it generates it. And the simulator expects a very particular format in order to actually simulate a program. So we want to be testing our assemblers with assembly code and then we want to test our simulators with machine code that is correct. So if our similar is generating bad machine code and we don't have a way to translate or to test our simulator, which expects the machine code. So of course, the similar was doing all these translations now simulator will be doing the actual execution of every instruction. So a couple nuances there, one of them is that in our similar there's like a one to one correspondence. So we had our input a single code and then we generated exactly one number and then once we generated that number, we didn't need to go back and do anything again. We did have our two passes that first pass was to generate the list of labels, but really the translation was done once. In our simulator, we had the potential to execute the same instruction more than once. And that's because of our BQ instructions in particular, if we have a BQ that sends the PC backwards and we execute those instructions that we just now executed. And so if you think about four loops in a C code, this is kind of the same concept. Whenever we have a for loop and see your C++, once we reach the bottom, we go back up to the top and we could do that potentially many, many times. We could just skip over the whole thing if we never get the condition or we could do it only once. It just depends on what the program is doing. And so that is, I think the main difference between the complexity of the similar in the simulator, because you can look at your simulator and you go, I executed this instruction correctly once. Therefore, I shoot it, execute it correctly every time. But that might not actually be true, depending on the other things going on with the registers and memory in your system. So going from the translation to the execution will be quite agent. But let's look at it. Let's see. So all of us. Oh, one quick thing. I mentioned that in this flow, we expect valid machine code in order to go into our simulator on our auto greater, you don't really have to worry about that. On our auto greater, we are going to ask you to submit a simply code. And so in our auto greater, we're going to behind the scenes translated into a valid machine code file. So you don't have to worry about your similar working perfectly in order to get any points on the simulator. So don't worry about that part, but that means that you should not be submitting any machine code files to the project 1s, or greater. Even though that would be a valid way to test it, makes it really hard for us, because of course the assembly code is the human readable code. And so if we're only messing around with machine code, and not thinking about the actual assembly code behind it, then it's going to be really, really difficult conceptually understand what one asks is trying to do. In other words, we're going to take our correct assembler on your assembly files, then generate machine code, and then we'll test that on your simulator. So let's actually look at project 1s. So part of 1s, like I said, is a CPU simulator. And so we're going to start with a couple, just quick things to make sure everything's going to work consistently across everyone's simulator. First, you want to begin by initializing the registers and the PC both to zero. So that's a convention in an LCTK. We're going to expect all registers and all LCTK code that we're going to see this term to start off with zeros at the beginning of the program. It doesn't mean that at the beginning of a function, they'll all be zeros. We'll see that difference later when we start talking about functions, but at least for programs, all of our registers and the PC will start off at zero. So earlier I said that we aren't going to be expecting a dot fill address zero, because the PC is going to start at zero. That's exactly why. So project 1s is going to take that machine code, which is just like a small number of lines, and then it could generate a potentially very, very large file. And it's going to have all these lines of text that are going to tell us our state of registers in memory after we execute every single instruction. So in order to do that, you don't have to manage the printing all yourself, but we have provided you with a print state function. So as long as you modify the registers and the PC and the memory correctly, and then you call print state, it is going to be correct. So you don't have to worry about the exact details of printing, as long as you just call the print state function. So we're going to give you this convert num function. That is going to take a 16 bit number and choose compliment, maybe like an offset from one of our instructions and extend it to the 32 bit, choose compliment representation of the same number. So you will need this, especially when you're, well, really any time you're doing an offset. So if you have an offset from an eye type instruction, you should definitely run it through convert num, or else you will not get the correct answer for these memory addresses and new PCs that you're calculating. So you're going to go through the state struct, and then we'll look at that same spec example, how we execute it in the simulator. So there's, let's see, there's convert num. You can, I think this is actually an old version of convert num, but thing you have an example, let's say I have some number, and it starts with the one in its 16 bit form. So that's what the rest of those numbers are. But whenever we call convert num, it's going to take that one, and it's going to duplicate it across these other 16 bits, so that the first 17 bits are all ones. So that allows us to keep a negative value and the same negative value when we convert it from 16 bet to 32 bit. On the other hand, if this is a zero instead, well, then we'll just put a bunch of zeros here, so that we are representing the same positive number when we convert num. So convert num does work with any input a 16 bit number. And so that will allow us to always have the correct value. When we're adding like a 16 bit number with a 32 bit number. Let's see. Here's what I'm looking for. We are going to also give you this state in the starter code, which you can find in the spec. That's linked from the spec on our website. And it's just going to be a simple C struct. It's going to have a couple different members. One of them will be the PC, which should be updated every instruction. And then we'll also have memory. We'll have num memory entries, which is going to be 65, 536. It's going to be at that many different memory locations. I know that sounds like a lot for one array. I don't worry about the memory overflow in this class, we're not really going to be worried about that, especially for the simulator. Then we'll have our eight registers. And then this really auxiliary variable will just help us with printing whenever we call print state. So looking at print state, it's always going to start with this at at at state. And then it's going to print the PC, the memory. And then for every memory value within the memory, it's going to print them at some address, at being equal to whatever the value is. And then it'll do the same for all of our registers. So we should see all seven or sorry, all eight registers, be print out by this print state function. And depending on how large your input machine code file was, it'll print that many elements from memory. So in else, like the registers and the PC, everything is going to be initialized to zero. So once you initialize memory to zero, then you bring in your machine code to override all those different entries and memory. Everything else after that is still going to be zero. And so we don't see any reason to print out thousands and thousands of thousands of zeros. If we just get what we need by printing the first however many elements in memory. So that's what print state is going to do. So that means do not modify the print state function. If you modify that, then it will be nearly impossible for us to know what's going wrong in your code. So please do not do that. All right. Of other way, if you want more details on the convert num stuff, you can either check lab two where we go into that in more detail. It's okay if it's not clear right now, you can also come talk to us in office hours and we can go through exactly what that's doing. So the key thing is to know that whatever that first bit is the left most bit in the 16 bit representation is going to be copied to all these new bits that we add to get to 32 bits. And so you can see the math again in lab two, which is trust that it works out to the same value. But finally, we can get to the example. So this is what we just translated with the part a. So we've we know that these different numbers that really mean something only in binary in their decimal. They don't mean much. But we are going to load them into a simulator. And we're going to do some binary operations on them again. So we're going to do that in order to decode them and do what they want us to do. So let's look at that. So like I said, we'll initialize everything to zero. And so let's say I don't think that that's in this code. But everything that is in the machine code file, we're going to set into our memory array. And I think in the the starter code that we give you before you execute any instructions, it'll print out just the initial state of memory. So you can see between the machine code and the initial state of memory, it should all be the same. So if you have any issues with that, make sure to put a post on Piazza, because there should be no difference at all between the machine code that you give it. And the numbers that pop out in the first segment of memory in this output. Then we are also going to give you the state before we execute any instructions or you should print that out rather. So we'll have all of our registers at zero. Our PC will be zero. And so that means that we are about to execute the instruction at address zero. So you should print this out and then the same state is what you'll print out before you execute every instruction until you hold. So you should see a whole lot of these print state outputs and that will determine the correctness on the auditor. All right. So now let's actually start executing some of these instructions. So remember that the instruction at PC zero, correspond to LW015. So this means that we're going to take five, which really translated into seven. And we're going to add it with the contents of register zero in order to get a memory address. And then whatever is at that memory address, we will load into register one. Well, since all of our registers begin at zero and by else decay convention, we're going to ask you to always keep register zero at zero. That means that we will take zero plus seven, which is a percent. And then we will get whatever is in memory at address seven, which is five and loaded into register one. And then once we execute that instruction, that five appears in register one. So that's a just the most basic type of LW that we can do. So the LW would do that. Also, it will increment our PC. Because if we didn't increment our PC or PC would say zero, and we'd execute that same LW instruction forever and ever. So instead we need to increment the PC so we actually execute the instruction and move on to the next instruction, which was on align one. By the way, in order to execute that instruction, I basically had to do the reverse of what we did in one a. So I'm doing some detranslation to figure out what it wants me to do. So if we remember that this number, this eight four five four one five one, we generated by following this binary format way back here. And our simulator, we're going to break down all these bit fields again, to do the opposite again with the ideas from lab one. And so we'll split them up into a numerical opcode, a number or register a number for register B. And then a 16 bit number for our offset that will pass to convert num. And then have basically a bunch of if segments in our simulator and check to see if the op code is binary zero one zero. Well, if it is then we do whatever we do for the LW instruction. So that's how we knew what to do with the LW. Let's move on to the next instruction. Our next instruction was another LW, but this time the register a was one. And so remember that we just set register one to five. And so now if we do the same thing from before we take five. That's our register a contents, then we add it with three, which is our offset. We get an address of eight. And then looking at memory and eight, we see there's a negative one. So that instruction will load negative one into register two, which you can see right here. And so once again, we're going to increment our PC in order to move on to the next instruction. All right, let's do that. So now we are at an add instruction. And so our PC is here. And so that's this this number here. So once we decoded, we'll see that the opcode for ad is binary zero, zero, zero. And then we'll get one for the register a two for us should be one for the destination register. So all we have to do is look at our previous state. See the contents of register one. That was five. And the contents of restrew was negative one. So we'll add them together to get four. We'll take that four and we'll place it back into our destination register, which is register one. Again, increment our PC, and then we go on to the next instruction. And now we have a beeq instruction. So we see that our registers for beeq going to be zero and one. And I say that two is not going to be a register because we'll remember beeq's an i type instruction. So this number over here is actually an offset is not a register. So what this is saying is that if the contents of register zero and one are equal, then we'll jump to PC plus one plus two. So PC plus three. And if we don't, then we'll just move on to the next instruction by incrementing our PC to PC plus one. Let's actually check if register zero and one are equal. So in our previous state, a register zero was zero and register one was a four. So they are not going to be equal. So that means we won't take the branch and we'll just go on to the next instruction. Let's do that now. So we increment our PC to four. And so the next instruction that we'll simulate at address four is this one right here. And that is going to be another beeq. And so it was beeq zero zero start. And if we look back at our our assembly code. And then we can figure out what this start would actually refer to. So this is going to go back to the similar. But whenever you decode this instruction in your simulator, this will actually be a negative three. Because our similar should take all the labels and translate them into numeric values. And if the beeq always goes to PC plus one plus offset. And we want the beeq instead to go to the line with the label start. Well, then we have to do some counting. So the beeq will go to PC plus one. And then we want to code back three from there in order to get to start. So that's why start will translate to a negative three. Let's see. So once we get back to instructions, this will actually be beeq zero zero negative three. And now we have a comparison between risk zero and rest zero zero. Well, it's the same register, which means that those values will always always be the same. And so this is really an unconditional branch. So we're always going to branch to start whenever we execute this instruction. So looking back at our assembly code once again, we saw that start was defined to address to. So our PC will actually become two. And that's how we execute that branch. Let's move on. And then we go back to that same add instruction from before we saw that a register to as it changed. And so we will still a negative one. And before it decremented, register one by just one. And so we will just do the exact same thing. I think the slide numbers wrong. Let's see. Last time we executed this instruction was on slide. 34. I should actually say 34. Once again, we're just going to document register one and then keep going with the program. So we're just doing that be queue again, the first one. We see that restures one and two are not equal. So we're not going to take the branch. And we'll just go back or we'll go on to the next instruction. Right. Right. We're at BQ zero zero. Start again. And so we saw that that's an unconditional branch. We don't even need to look at the registers in order to determine that we'll take that branch. So once again, update our PC to two. Now we're back at that document. So again, we'll document register one from three to two. Then we'll go on to our first BQ instruction. Once again, they're not equal. So we're not going to go back or go forward. I'm going to take the branch. We'll just move on to the next instruction. And then now once again, it's an unconditional branch. Set our PC to two. And then now bring us to that same add instruction once again. So document register one. I went from two to one. Then we get to that first BQ. Register zero and one are not equal. I have the values zero and one now, which is coincidence. The not equals or not going to take the branch. We'll go to the unconditional branch. Set our PC to two. And then once again, go back to that instruction. Now, the previous value of register one. So when we decrement it, it'll go down to zero. We have to be sliding. So now when we get to this BQ zero one to instruction, we see that register zero and one are both zero. That means that they're equal. And so now we're going to jump to PC plus one plus offset for this branch for the first time. So our PC it was three. And so we'll take three plus one plus our offset of two. And then that will come out to six. So update our PC to six. That is this instruction right here. And then if we look back at our assembly code. We will see that at address six, we had a halt. And so that means that our program is going to be open. So by executing this BQ here, we're going to jump over this BQ and this know up. And so that means that the not was never ever executed in a program. So that goes back to what I was saying about the difference between serenization and execution between one a and one s. We just saw an example of a loop where we executed this middle block of ad BQ BQ. I was in like five times or so. Those first two LW instructions we only executed once. And then this halt will be executed once, but the knock was never executed. And so we need to be okay with that and not worry that the knock was never executed. That's totally expected behavior. Anyway, once we finally get to that halt instruction, we are done. So do not forget to print out print state one more time. I also like to print out these three lines. You'll find this in the example output in the starter code. Just to tell us how many instructions we ended up executing. And then that our machine has actually halted. So that can help us to distinguish just an intermediate print state from somewhere in our program with the final print state. And so now that we've gone through all this code and we've actually simulated it by hand from the spec. We can translate this back into C. And really we don't even need to simulate in order to do this. So we can just look at the different instructions. And what it is, we can take some variable that we will represent with register one. And then we'll assign it to the value five as we did with that LW. So it's like this line here. And then we will keep decimating while this right this variable five or this variable X, which is in register one is not equal to zero. X is not zero. We'll keep doing this loop. And then once it is zero will be done. And I'll be the end of the program. So this helps us conceptually know what the program is doing. Alright, so that's everything with the spec example. I do always like to show this kind of table. This is a list of what the different op codes do on a high level. So as you are coding up your simulator. If you see, for example, like a memory access within your add instruction, you know that you're doing something wrong. And if you don't see a memory access within your LW instruction, you know that you're doing something wrong. So I would definitely use this table to gut check all the different operations that you're doing in your different instructions. Also, when I say write PC, I'm ignoring the PC plus one because all instructions should be doing that. So if you generally follow the table in that caveat for your simulator, you should get something that's pretty close to correct. So I mentioned that we are going to submit test cases in order to make sure that everything is working. I really recommend to start an entire project by doing your test cases. So the cool thing about test cases that is that you submit them to the auditor and we're going to tell you how powerful your test cases are. So if you're failing your own test cases, and then when you run it on your own computer, you can look to see what the output is. And if you think it's correct, but our auditor is telling you that there's an issue with it, then you can go through line by line, like I just did with the spec example to see why it's incorrect. Look through some of these questions in order to just generate better test cases. So you can ask yourself, did you make sure to test the program calculates the offset field correctly. So that's for both project one a and one s. Did you make sure to test the program updates or registers correctly. So you can do that for both one s and one m, which we'll get into. Did you make sure to test the program calculates the memory address in relation to the offset field correctly for given up code. So the keywords there is for a given up code because different op codes do different things with the offset field, so particularly be Q versus LW nest of you. And then do you have a test case or can you create a test case that tests a specific few lines within your C code. That would be a great way to double check, especially to make sure that you're executing every op code correctly. And that way you can verify your program in entirety instead of throwing just some randomness at it. You can look on piasas that we have a post that talks about the different types of test cases. I would definitely recommend to do that. There's generally three basic types. There's like small tests that just have a couple lines that and so that very small portion of your code. Yes, and this was some like random instructions in there. And then you also have some tests that represent actual programs. So the spec example would be an example of an actual program. First because we can show the seat code for it. And so you want to definitely write some of these because I think these are the hardest types of test cases to write. And so those three types of test cases are the actual like industry standard of how to make test cases. And so you should get really comfortable with how to do all of them. All right. So now let's move on. We're talking about C code and really only talk about assembly. So whenever we're doing some C code, we can just use this little asterisk in order to do multiplication. But in else decay, we do not have we do not have a multiplication up code. And so in project 1m, you're going to be implementing multiplication in binary instead. So I'm going to go over the algorithm and then a couple tips for how to actually implement that. So let's look at that before we get into that. Your program is generally going to look like this. You'll have a bunch of instructions up top. And then you'll have two dot fills. And one should be called in can't for multiple can't. And one should be called implier for multiplier. Because of course those are the two factors whenever we do a multiplication. And you can start off with any two numbers that you want. Maybe like three and seven or something. And you're totally free to add more dot fills down below. But your program is is going to be expected to correctly multiplying no matter what multiple can and multiplier are. Before we run your code on the auditor. We're going to edit the assembly code to replace multiple can and multiply with all sorts of numbers. And then whatever code is up here, whatever assembly code is up there should work for all of them. So in order for us to go in and edit with the values of the two factors are need to make sure to spell those labels correctly. Like I think probably the most common one is to spell multiply in PL E IR. In clear. So make sure that everything is correct. So let's do a little review before we talk about the multiplication. So we need to remember expanded form. This will be really important because whenever we do some. Like binary operations, we're always thinking about these these ones and zeros, right? And so these ones and zeros are all going to correspond to different place values. So in this example number of 94. We have like this zero corresponding to the ones place. This one corresponding to the two's place and then the fours and the eights and the 16s and 32s and 64s. And so in order to get that value in decimal. Remember that we just kind of multiplied each bit by its place value. And so with binary that was particularly easy because whenever you multiply one by some number, it's just that number. And whenever you multiply zero by some number, you just don't include that number at all. This is just zero. So once we took all the place values that corresponded to ones and then added them together, we were going to have our decimal value. And so in this project, we are going to have to look at each bit in our binary number and identify its place value and then do some decision based on that place value and based on if it's a one or zero. So that's kind of the basis for the project. To see why that's useful, let's go back to some like elementary school math and look at how to multiply decimal. So in order to multiply in decimal, we always pick one number either the top or the bottom. And that number, we are going to be going digit by digit. So let's say that we pick the bottom number 26. So we are going to do some multiplication digit by digit. So we'll take 104 times six at first digit and that comes out to 624. Then we move over to this two and this two really has a value of 20. And so we're going to take this zero and put it at the end of whatever we're about to multiply. So we take 104 times two and stick it in front to get 28. And I'll give us. 280. And then we'll add all these are these digit wise multiplication together to get our final answer. So this is what we did in decimal. So we're going to do the exact same thing in binary. Let's look at an example. Let's say I want to multiply 9 times 11. And of course is 99. And before we get into the algorithm. Let's double check. So 99 is 64 plus 32 plus 2 plus 1. And so if we look at what our final answer will be, this is the one's place. This is the two's place. This is the 32's place. And this is the 64's place. I'll show you this again. It's the same number as you are. I'll show you this one. I'll show you this again. And never algorithm. I'm about to show you at least works for nine times 11. But this really works for any positive numbers. Alright, so the actual algorithm will be the exact same. We will pick a number to go bit by bit. And then the other number will multiply by that bit and shift. Meaning adding zeroes to the end. my one that is in the ones place and I'll take one zero zero one times one which is one zero zero one. Okay now I'll move on to that next one. It's now the two's place which in binaries one zero and so I'm going to take that zero and add it to the end of what I'm about to multiply next. Once again one zero zero one times one is one zero zero one so we can really just copy this one zero zero one this multiple can't and I'll put it in front of this zero that we got from our place value. Next we have one zero zero one times zero. Even without looking at the zero we can add these two place value zeroes on the end but the actual value will come out to zero so we will have that and then we take our final one and multiply it by one zero zero one once again we just copy it put it in front of the place value zeroes and then once we have all these bitwise multiplications then we can add them together and we get our final sum so just to show you one plus zeroes is one one plus zeroes is one let's see one plus one is two so we carry the one there one plus one is two here the one one plus zero plus zero is one and we have a one down there so this is the correct addition results and this is what we'll do in our code so now the question is how do we actually translate this into code well we need a couple things we need to figure out how to isolate each bit from our multiplier this this bottom number and then we need a way to decide whether we are going to add the shifted top number or not so we add the shifted top number let's just like adding our one times that top number and if we don't then it's just like adding our zero times the top number and so in your code you are going to do that with some beacuse and some norm instructions and then in order to add your zeros to the end remember from lab 2 that we can just use the add instruction multiple times in order to double a number which is like shifting so let's look at how we do that I'll get to that in a second by the way before going too far into the different instructions I would recommend writing some pseudocode in C so see if you can write a function that multiplies two numbers together using that algorithm I just showed you without actually using the asterisk so no actual asterisk so this will make it much much easier to translate into your your final project but let's look at some things that we can do in order to go through this project the first one like I said is to use the add instruction in order to shift because if I do something like add 111 well I'm adding register one with itself and then storing back into register one of course anything plus itself is like multiplying by two and in binary that's like shifting by one so if we need to stick a zero onto the end of a number we can just add it with itself so if we do this multiple times maybe in a loop we can actually multiply by any power two which means that we can add any number any number B of zeros to the end of a number in order to do the masking you will want to basically simulate an and operation if I looked at in lab one in order to do that you can use three nor instructions because by demorgans law an and operation is like doing a nor with two at negated inputs and in order to negate inputs we can just nor something with itself we can also nor with zero if we want not because anything or with zero is just itself and anything more with itself is just itself now we don't need to do this for this project but if you ever need to do some or operation you can first do the nor and then do that negation so we can just double negate it and we get the basic rule so you definitely want to do that for this project also you don't really need to do that for this project but you might want to do this in some of your test cases for one a or one s you can do subtraction by negating a number adding one and then that that becomes the negative of your second number so if I don't see a negative B I can negate it and add one and then if I want a minus b I can take a plus negative B and so you see you don't actually need that for one m but you can do some setting and masking basically what we did in lab one in your multiplication and finally I do want to go through a couple examples for types of loops and if statements you might use in your project one m about really for this course you should be comfortable with all these different types which you can find in lectures four and five at least in the ARM version so let's look at them and this all depends on the B EQ always branching to PC plus one plus offset by the way so if we want to do an if statement in s2k we can copy it over pretty directly from our ccode we have our if whatever is inside of the if we can kind of treat that like a black box and do that translation separately same as whatever is inside the else statement but for our BQs we have to do a little bit of manipulation so if we think about like how our visual debuggers work whenever an if statement is true we go inside it and so that means we just like if this is line one if the condition in line one is true then we go into line two with our BQs we know that that is the opposite because whenever the BQ is true we go somewhere else so we have to force the BQ to still do what we want it by inverting the condition jack so if this condition is true and we want it to go to the next line well then we can negate it with an equality instead that means if these two are equal meaning this condition right is false then it will go somewhere else so that means that if these two are equal then it will go somewhere else and then if we have an if else we never want both of them to be executed so at the end of the if we should always have a unconditional BQ that skips over the else part now what if we have a condition that starts with a quality check well then instead of inverting the condition since we don't have any branch if not equal in else decay instead we can still copy over the insides of the statements directly but this time we switch the order that they appear so this means if these two are equal then we go to the next line in our C code well now that next line needs to be moved somewhere else so that the condition being true results in that code being executed so then we would also move the else up and then we would still have our unconditional branch similarly with our wild loops we'll have some inverted condition checking so if you want to have just a basic wild loop that ends when two things are equal then you can have a instruction that branches pass the wild loop whenever that condition is true and if you want to do something like a do wild loop where you go back up to the top every time two things are equal then you can have something like this so this is specifically non-inverted conditioning checking because it's checking at the end and then finally if we want to do like a for loop we can translate it very much like the wild loop except we have to add in the initialization and the increment and so that increment or really just go at the end of the for loop and then that initialization will go before the for loop ever starts so we can do that pretty easily so this in particular you probably want to do for project 1m because in project 1m we'll tell you that you only have to multiply 15 bit numbers together so once you've multiplied that 15th bit you want to end your loop and and finish the program now suggest a couple closing thoughts we've talked about a lot of different things that might not all stitch together well like I said this is not a replacement for the spec I definitely go read the spec but this hopefully fills in some little gaps here and there but I do have a couple closing thoughts I just to make sure that we can all do well on this project so one thing that distinguishes 370 from 281 we aren't testing for time usage or memory usage at least in your C code so like your multiplier shouldn't execute thousands of thousands of instructions but your C code we aren't testing from time and memory usage that doesn't mean that we should write egregious code in terms of time and memory usage so if you are writing good code and very well-commented code in particular that means it's going to be easier to debug when something goes wrong there's this suggestion to separate different opcodes or opcode types into helper functions when you're debugging actually don't recommend that I think my rule of thumb with helper functions is if you call a helper function more than one time in some sort of code so like if we call you know we'll call it convert num multiple times within our giant loop they'll execute our simulator I would use the convert num function instead of copy pasting whatever's inside the convert num into our code but if there's only one place where I'm calling maybe like something to handle the add instruction then I would just not create a helper function I think that actually makes it more confusing but that's basically what it's saying in this next line here create a helper functions if you are repeatedly doing the same calculation and the reason that we want to create helper functions in that instance is because we see all the time where you find a bug in that calculation and then you change it in one place and then you forget to change it in all the other places and it's still wrong in all those other places and it takes forever to figure out again so definitely write helper functions if you're doing the same thing five in the same code or copy pasting any code in any of your projects and also definitely add comments when working with us creating instructions it's really important to get the actual concepts we don't just want to do things robotically we want to know like the actual reasons why did we I generate the spec example in the way that we did with that do while loop so don't just if you modularize everything in your mind then the homeworks and exams in particular will be really really difficult so the projects have a purpose to actually teach the ISA and so we want to make sure that we're actually getting the concepts there if we don't mention something in the spec feel free to add a Piazza post about it and we'll try to answer that but if you think that there's something in valid that's not really in spec you can don't worry about it you cannot worry about it whenever we're testing your code on the autograder we're not going to give you any code that doesn't exactly conform to what is in the spec but we do list some errors in the spec for part A and there are no errors for part S and definitely definitely check for them or else you won't get full autograder points and then I really recommend getting your debugger set up I think we did that in the first lab for everyone if you want to know specifically how to test on Cain you can ask me during office hours VS Code has a really cool extension that allows you to use Cain without trying to use the the NC client it makes it as if the VS Code window is just the regular one on your computer I really understand that but definitely run on Cain if there's something on the autograder that isn't working the same as your computer but for regular bugs besides what we call undefined behavior which is the differences between the autograder and your machine staring at your code and trying to find the differences in your output versus the expected output it might waste time I would recommend constantly referring to the spec so whenever I do these projects I always have the spec open preferably on two different monitors if I can and so that means that we don't have to go through all the output because again in part one S can be really really long and then we also have some helpful resources on our website from converting from C++ to C since many of you have just come out 280 and so I recommend looking at that because C takes a whole bunch of useful stuff away and so we need to know how to do the same things all right and then last feel free to check the fact that we'll be posting in our Google Drive office hours are your friends piasas your friend so let us know just be sure to not share any of your code with any other students in piasa or office hours that is an honor code violation and that includes all test cases so make sure to not do that and then also make sure to go to office hours early because on the day that a project is due our office hours are always super super booked and we can't get to everyone especially if we are trying to give everyone more than 10 minutes so that's everything I have for the project and again good luck