 Okay, so we are going to, we're going to go ahead and start off with some just basic theory about pipelining. I think the, like, what is a pipeline and how is it different from single cycle and multi cycle structures for programming? The example that they give in lecture is like a drive through. So since we've already done that one, I had to come up with like a new analogy. This is a pancake buffet, like a breakfast buffet. You've got the station where you take your plate and the station where you take your pancakes and the station where you take your bacon and then where you pay for all your food, right? So a single cycle processor is where we have your first person in line. In this case, it just happens to be Abe Lincoln. So he would get his plate and then he gets pancake and then he would get his bacon and then he would pay for his food and then he'd go to his table. And once he's completely finished, then it is France's bacon's turn, who is the next person in line. So this is analogous to like the first instruction, getting the instruction and then reading from the registers and then like doing an ALU and that kind of thing. So the issue here is that Abe Lincoln gets his plate and then he was onto the pancake, but now the whole like plate taking station is completely open. So why not just have France's bacon start on that stage and get his plate while Abe Lincoln is getting his pancakes and then they each move forward and get their next Abe gets his bacon. France's bacon gets his pancake and then Julius Caesar who happens to be third in line can get his plate. So this is analogous to each of the instructions. Taking up a different area of the pipeline processor at each time in different stages so that we are like maximizing the number of instructions going on at once and minimizing our CPI as low as possible in the amount of time. It is important to note that even if like Abe Lincoln is vegan or whatever and he doesn't want bacon, he still has to be at that station. So even if he's not using all of the information, the instruction isn't using all the information that they still have to take out that spot, take out that stage, they're not allowed to skip or anything like that. So he starts to be at the bacon taking station before he can move on and everybody will move in line so that we have like everything in the processor being used at all times. So this processor is going to look somewhat like this. This is pulled straight from the processor simulator that they give you in the EECS website. So you definitely want to check that out. I think I put it in links and resources if you really need it. It's really similar to the processor that you're actually going to be programming. But there are a few key differences that I'm going to draw after I go over a big part of theory about the pipeline processor. So there is hopefully I'm not going too fast. I probably am, but it's okay. There's one issue in translating this processor into C++ and that has to do with these registers right here. So in a normal register, it will like hold some value. This is supposed to represent a register that's going to be like pink on the inside. That's awful. It's good enough though. So this register is going to hold some value like 10 and it's going to be outputting that value to whoever might need it in these wires. So maybe the ALU or it's an address, anything like that. But then coming into it is going to be a new value. And this new value could be like nine. So when we activate the clock, when the clock is moving from off to on right here, then we are going to update all of the registers at the exact same time to equal the value that is going into it. So here it will stop being 10 and it will become nine. And then because this relies on some register before, it will change to some new value. Six. Whatever, anything like that. So this way, all of the registers will be activated simultaneously and be set equal to the value immediately before them. Unfortunately, there's no way to simultaneously do anything in C++ because it all has to be done in like steps. So the way that we translate this in C++ is instead we have our, I'm just going to give this frame. We have our old register that equals 10. This is our regular state. So this is state. And then we have a new state over here. And at the beginning of every cycle, the state and the new state will look exactly the same. But during the cycle, you will only ever modify the new state. So the value going into this register is nine. So in the new state, we're going to change this to equal nine. And then we will do that for every register. That way, we still have the info that we need from the first state, but we can change it in the new state. And then at the very end of the cycle, we will set the state equal to the new state, essentially saying that we've moved forward one cycle. This is basically just to make up for the fact that we can't simultaneously change all the registers at once. This is close to the sub we're going to be able to get in C++. So you will only ever modify new state. And so new state will only ever be on the left side. We'll just write this out. I think they do have this in the spec. It's good to reiterate. New state will only be over on the left side. And state will only ever be on the right side. So this is saying you're taking information from the state and moving it into the new state. And then at the end, you will go ahead and overwrite what you had in the state with the new stuff. So that's how our register is going to work in C++. There are a few changes that are different between the pipeline simulator that they give you on the website and the pipeline that we are going to be programming in Project 3. The first one is that there is no mux in the ID stage. So this isn't here anymore. And instead it will get moved into the WB stage all the way up here. And this will come from the instruction and yeah, with the instructions and then that will equal your new destination. That will make more sense when you actually start programming that. But there's no mux here anymore because there's no longer a destination register in each of these. The second thing is that there is no equal register in XMAM this guy right here, which is weird. I kind of find this odd because you do need an equal register. My solution was to just create one like externally. So I added this on my own, not as part of the XMAM structure or anything like that. Other people have just used the ALU result as the EQ because you're not using it if it is a bee. So one way or the other, you're going to have to create or reuse something for the EQ register. And it's not going to appear in the source code that they give you. There's also one more full register line at the very end. This is called the WBEN. The WBN register. And this is just going to take whatever comes out of this box right here. So that you can use it for forwarding. Some of the forwards will have like a full three stages needed. So you're going to need this stage to hold the information at the end that's like write data. And that's already implemented for you as a structure. You just got to make sure that you use it essentially because the explanation that they give is that there's no forwarding done in the register file. That would, that there is in the process or simulator that they give on the website. And then the last change between these is that this mux is actually not in the WB stage anymore. It's in the one right before it. This is a pretty small change. It just means that the ALU result and mdata get muxed here and going to a new register called, this is getting really messy here. So we're going to like move it up here. This is your right data register. So those are the main changes between the simulated that they give you. And the one that you're going to be programming, it's really only four. But that means that when you're debugging, you should really go and check the processor to make sure that your programming, that your program is running at the exact same way that the processor does. I do have notes for like what each of these stages does. But unfortunately, I think like part of the project is being able to look at this processor and turn it into instructions that you could program in C++. So I think even though they're a bit ambiguous as to what they want you to do in all cases, it's good to just try it on your own, see what you can come up with, and then ask on Piazza and Discord when you reach an ambiguity because there are quite a few and it's better than doing trial and error. But when you're debugging, the handiest thing that I found I spent far too long doing trial and error and debugging by comparing what I got in my final result to the processor. So you'll notice some patterns really quick. You just want to compare each of these color coded sections to the section in the simulator. So you'll quickly check like, okay, PC equals this PC and the, I'm going to go ahead and get the, and then the greens, the instructions should be equal to the instruction PC plus one equals the PC plus one. These four numbers that you'll see right here should equal these four right here. And you'll quickly compare just to see if anything's different. There are very few cases where they should be different. It really only happens when there is a hazard that you need to deal with because the simulator and the program deal with one of the hazards slightly differently. Normally, if they look the same, it's totally good. And if they look different, then you either have a bug or it's like, it doesn't matter if they're different. One of the main different questions. Go for it, please. Can you go back to the slide right before this one? Yes. So is it a purpose of the WD stage just essentially for data forward and forwarding? So it just make our life easier when it comes to feeling the hazards? Yes. I, yeah. So you'll want to hold onto this data so that you can pull it all the way back and put it into this mux right here. I think normally it just like, I'm looking at this to see if there are any hints, but I can't see any. I think normally it just takes this right data earlier and puts it into the register file early. So that you don't need to do this extra step. But we're not doing that. That's too much work. So instead, we're just going to have another register that will bring it all the way back into these boxes. Awesome. Please. Yep, that's a really good question. Thank you. So that's the main goal of the processor and comparing it to your code. You're going to be doing it a lot if you want to make sure. I'm going to make sure I'm not missing anything here. I think that's the goal of that. I think this is just like a helpful little key to make sure you're comparing the correct parts of your output to the output of the simulator. So that is the basic pipeline. What we're going to do next is the hazards. And this is a big topic. So if anybody else has any questions about pipelining, now would be a good time to ask because hazards is like more than half of the project. I did have one small question actually. So I was looking at least through the version of the data path as appears in the lecture. So there was one specific lux that I was entirely sure what to make of it. So specifically, it's in the execute stage. So in the execute stage, there's a lux which compares what I believe is register B and the offset. So that one. So I was wondering what the purpose of that must is because if you're to the a use only meant to be used for primarily things like adding and going. Right. So the reason that you need that a you is for LW and SW or this much is for LW and SW in those you're actually adding the value of register a to the offset to get the address, the memory address that she'll use in data memory. So this is when you do LW 5 4 and then like 16 or whatever. This is adding the 16 to whatever is in whatever value is in register 5. This got really tight really quick. So for add and or you would just do the value B, but for LW and SW, you need to use the offset. Does that make sense? Okay. Yeah. That makes a lot more sense. Okay. Cool. I guess one last question I had. Go for it. So there's two extra smaller mox is inside that same execute stage. So those two mox is don't actually appear in the election version. Oh, good. Yeah. I wonder what those two mox is did since the lecture obviously doesn't mention them since it doesn't appear there. Right. Those are our forwarding mox is they take information from future stages so that you can resolve any data hazards that you might have. So the orange comes from the ALU result and the purple comes from data and then the green one which we're adding is coming from right data in the new register that we're adding in our project. So those are for forwarding and you can get them in the simulator by selecting like the data forwarding option in the bottom right corner. I can't remember exactly what it's called, but they want to appear first. You'll have to make them appear. I see. Okay. That makes a lot of thank you. Welcome. Any other questions before we move on to hazards because they're big. A quick question about the destination. Yep. Like we don't have them because is it because in C++ where in all our structs we have the instruction already? Yes. So I'm going to go ahead and replace that as a good catch. Instead of OPs and all of these we have instruction. We're carrying over the entire instruction into every register. So by the end we'll already have the stuff that we need for destination and we'll just do the mux there instead. All right. So we don't have to like carry it over because it's already being carried over. Correct. Yep. All right. That's the instruction. And our question on the field functions that are given in the project. Go ahead. Yep. So are those the actual values of the registers and the offset or is it like just the actual register and the off like the actual number of the register? I can't quite remember which field registers you're talking about. This is field zero and field one. Oh, okay. Parts of the instruction. Yeah. So in the instruction. Okay. The more time now that I know what you're talking about. Could you read your question, please? Sure. So are the I guess fields zero and one are they the actual values of Reg A and Reg B? Or are they just the numbers like of the registers I register one or two? They would be the numbers. So this would be field one or field zero and this would be field one and this would be field two. Okay. Cool. Yep. Thank you. Welcome. All right. I'm going to move on to hazards. So the thing with hazards is they tell you, okay, for the second half of this project, you're going to want to resolve the hazards. You say, okay, what hazards? And they say, you know, the hazards. Make sure you do all of them and you're like, okay, well, how many are they? And they're just like, oh, you can just kind of resolve the hazards. So I got kind of tired of that and I've colored code of the hazards. And here they are. I've colored them based off of a traffic light, actually, because I think it really helps me remember what each of them is, what each of them do, whatever. At the bottom, we're going to start at the bottom. This is with your data hazards, code green. So when you have an ad, whatever, whatever, into some register R, and then you have another instruction immediately after that uses that R or later, doesn't have to be immediately after. Then this R is not going to be set in the register file in time for the future registers to use it in our pipeline implementation. This is going to have a range of like three instructions. So if any of the next three instructions, one, two, three, use the register that you are, that is like your destination register, then essentially you're going to have a data hazard. This is a code green. You're going to want to go forward some information from future stages to resolve the data dependency. This is for ads, nores. I think it's just those two. I can't remember the exact details, but there are five conditions that you'll need to look out for to determine if you need to call a code green and forward information from a future stage. So you will, I might need to pull out my notes for this one, because I don't think I kept them. That's unfortunate. I used to have notes on where you would check for a code green, but I don't have them. That was poor planning, but that's okay. So code green is just forwarding information from a future stage back so that you can use it quickly. Then there's also a code yellow. This is the only stalling that you will be doing in this program. It is when you have an LW, like R, because R is your destination register, and then you are using it in the instruction immediately after the LW. This is because the LW actually doesn't get the information that you need in time for the instruction immediately before it. You had an ad followed by an ad, and there was a dependency between them. Then you would pull back this ALU result into whichever of these two moxes that you needed in order to resolve the data hazard. But for an LW, you don't need the ALU result. You need the stuff from memory, and you don't have that loaded until the very end of the stage. So you need to put a no-op in between them so that nothing is going on in the EX while the LW has time to pull the information from data memory. Once that's done, it just becomes like a code green, and you can pull information from your write data in the membub register back into the mox. So code yellow, if you have an LW directly followed by a dependency, then you need to do a single stall. Stalling means that you set the IDEX register to be a no-op, so that it doesn't do anything, and then you will prevent these first two registers from...is that right? Yeah. And then you will prevent the first two registers from updating the next cycle. That way you'll have a gap, and you won't need to worry about that. You know what I mean? I'm starting to lose my train of thought. The last hazard that you're going to need to log out for is the big code red. This is only for BEQ. This means essentially that you are branching, and you're going to check for this in the membub right here using your EQ, and checking if the current instruction is a BEQ. If both of ours are true, then you need to set... yep, making sure. Both of those are true. Then you need to set all three of these to no-ops, essentially like stopping Q. That's why it's a code red, stopping all of those instructions so that they're no longer executing and they can't write any data or anything like that. And instead, you're going to be changing the PC to the new target branch, and then you'll be starting back up with the new instructions at the new location that you've just branched to. So you'll be checking for this in the membub stage. Make sure you don't check it in the EX stage because that was the mistake I made. Check it here. And once you've done that, change the PC and change all three of these to no-ops. I think that's all you need to do. Sorry. Yep, go ahead. Did you mind repeating the two things you checked for again? Yes. The two things you check for are if that equal register that you set up earlier is true. And if the instruction in memb is a VEQ instruction. Cool. Thank you. Cool. Does the clarify is because we are assuming that we are not taking the VEQ? Correct. That's a good, yep, thank you. We are assuming that we are not taking the VEQ. We're speculating that we'll probably just be continuing on after this. We only need to call a code red if it is true that we're actually branching somewhere else. And that's when we'll squash all of the previous instructions and start where we start at the new location. So those are the three types of errors. I have a quick question. Yes. Allow yellow. So could you sort of repeat when we determine that we have a load dependency? How exactly it works that we can just add a no-op without it sort of fucking up whatever instruction was in that stage. Is that question made sense? Right. I think that does make sense. I'm going to take a bit of thought. You're going to be checking for it in the IF stage or I think I miss wrote that. Yeah, you're going to be checking it really early as soon as you get the instruction. If the next one isn't LW and there's a dependency, then you're going to overwrite this guy. Right? Nope. You're going to be overwriting. I was asking myself that. You're going to be putting a no-op in the IDEX overwriting whatever just got carried into here and you're going to be stalling everything so that it doesn't move forward next time. So then essentially your PC is going to increment so that it'll just push that instruction that was sort of delayed. Is that correct? Yep. You won't be doing anything here. You'll basically just have like if you were not stalling, then do this stuff. Okay. So then just to make sure that I get this, if we have our load in the IDEX stage and then the previous instruction in fetch, we determine that there's a dependency with fetch and load an IDEX. We would just be stalling with PC and inserting a no-op. Right? Is that essentially the process? I'm just thinking. I think you've got the right idea. I think the detail that we need to look out for, I'm going to have to answer this afterwards because I have to look in my own code now to figure out what I actually did here. This is definitely a bit, this is a lot more to like take in all at once and keep in mind. So I understand where we're coming from. I think you definitely have the right idea. Just do to make sure I know which registers you're checking the instructions of. Yeah, you get it. No, I'm just wondering about the process. It's actually a good idea. Okay. Oh, hello. Yes, I will watch that later. I don't know if that appeared for you guys again on notification. Is it is they are going or can I ask a question now? You I think you can go ahead. All right. So for the code red option, the BQ one in the specific case where a programmer and where the BQ statement wraps to the option for not taking, would that still count as a code red? Yes. If it just went on to the next instruction, it would still count as a code red. It would slow the program down for seemingly no reason. But that is an optimization that you do not need to make, which means you do not need to include it. Perfect. Yep. So it would still count as a code red. You only need to check if code red if equal and it's a BQ instruction. Thank you. Yep. I think that's how the non-piaz it is. That's a good question. No extra optimizations. These are good questions. Does code green make sense to everybody? I think there were. Is there haven't been as many questions about it? So it sounds like it's hopefully a bit more sensical than the other two. Okay. I think that was 30 minutes. So this should be a good time to wrap up. I usually stall for no reason. So I'm going to make sure I hold myself tripping up on time and within a reasonable amount of time. That is the outline for the project and helpful color coding for all the hazards so that you can use that to refer to them instead of whatever nonsense we were trying to use before. Thank you guys so much. Thank you. Thank you.