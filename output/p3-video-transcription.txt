 Okay, hello everyone. This is a new setup for me with a new computer, so hopefully everything goes smoothly. This is our tutorial video for Project 3, silly QL. And the first and most important thing I want to say is make sure that you read the tips and tricks and pitfalls section of the spec. There's lots of useful information in there, like easy ways to read and write a Boolean, how to use the field object correctly, which some of which is going to be repeated in the video. Lots of useful stuff in there. Next up, I want to tell you something not to do. Don't use string streams. And the reason is you end up processing the input three times. You get a line into a string, then you turn the string into a string stream, and then you use greater than greater than the stream extraction operator to pull things out of the string stream. Just go back to here, then greater than and read them from see it. For most of this project, you're going to be using greater than greater than because our language in silly QL is very well formed. What I mean by that is that once you read one thing, you know what's coming next. So the only times you should use get line is basically for a comment. Anytime there's a comment, use a get line, get rid of the whole thing. Anytime you encounter an error in a command, like we say to create a table that already exists, you get rid of the rest of the stuff on that line and ignore it and print out an error message. And a working project shouldn't need more than that. One get line for a comment, one get line for every error you encounter, and that should be it. Something that you should be doing is object oriented programming because we're going to be making tables because we're simulating what's happening in a database. And so you should have a table object, a table class and make a member functions of that class for the commands, most of the commands anyway. And when you start processing the command outside of the class, then once you have enough information to proceed like, hey, I've got a table name, then start calling member functions to do the rest of the work. Now, most of the commands, and I'm going to assume you've read at least some of this back here, we'll make it obvious. So most of the commands are going to need a member function. The ones that don't is a comment because it doesn't do anything. The quit command because it doesn't do anything with a table, it just quits program. And it turns out the remove function doesn't really need a member function. It just needs some higher level code to get rid of the table. Now, the other thing that's important about this project is it is meant to be built in pieces. Don't feel like you have to understand everything about indices and how indices affect other commands and how joint works in order to start working. You don't have to. In fact, even if you write code without even thinking or worrying about indices, later on, you're going to say, oh, now I've got an index. I've got to do the code for that. And then you're going to say, oh, my gosh, I've got to go back and rewrite everything. No, if you've done a good job, you're not going to be throwing away original code. What you're going to be doing is adding a little bit of code to say, hey, if there's an index and blah, blah, blah, then new stuff and possibly old code goes in and else clause, or maybe it's just new code that gets added. So for the most part with one exception, I'm going to warn you about that a little later, except for that one command, which I'll warn you about ahead of time, you shouldn't have to throw any code away when you get to indices. You're going to go and you're going to put that existing code inside of an if or inside of an else. And then you're going to have other ways to do things. Okay. So as you're writing this project, if you don't have a command written yet, you're like, that's going to understand that. That's okay. But at the very least, make a condition so that you know you've seen a join command and do a get line to throw the rest of that line away because otherwise you might process it as if it was a command. So for example, if you just read the word join and you go back through and read another command, maybe it was join cars market place, blah, blah, well, you see, hey, I read cars market place as a command. Oh, look, it starts with a capital C must be a create command. And then everything goes sideways after that. So if you don't have a command done, that's okay. Just recognize that this is the join command, do a get line, call it done for now. So starting point for this program, obviously the command line, there's only one command line option, you really have to worry about, which is quiet mode, help you can do, it's not a big deal, the other great and every test help. But I would still use get up long is the easiest way to do things. Get off long, quit and help, long version short version or sorry, quiet mode and help, long version short version. And then start reading input. And I want to talk about how to read input correctly because it's really important in this project and we're going to want to use something we haven't done before. Switch my inputs up over here, should be ready to go on my iPad. Okay, so I've got some code written up already, which is basically the starting point for the program. I'm going to need, oops, like I got ahead myself here, I forgot one thing, I'm going to need a string variable for the command. Okay, so I got a string variable for the command, I create that variable, then I start my loop. And the do while loop starts here and ends here, the do while loop is a post test loop. Four and while are pre test loops, they test the condition before they do anything. But in this project, I want to stop on a quit command. But if I haven't read a command yet, I don't know what the command is. So we have to read at least one command, so the do while loop is the right structure. So we say, do this stuff and then we test the condition. So what are we going to do? Now this part here is not necessary for a perfectly working program, but it's in the tip section, it's an important thing to put in there while you're working on it so that you don't get weird infinite loops of garbage output. Hello Spencer, now you're going to make me show cat. Okay, we have to show cat. So Spencer wanted to help. Oh no, he doesn't like to be held much, but this is Spencer. He had to come and say hi because of course I'm recording a video. So here, why don't you sit on your own chair next to me. Okay, there we go. So if you see me doing odd things with my hand, it's because I've got a paddock at to keep him happy. Okay, so when we start reading here, this, this is in the tips and tricks and pitfalls section, this if statement here, this is to make sure if things go really sideways and your program like thinks it's in the middle of a create command when it's not and you start trying to read integers when there's strings, we don't want an infinite loop producing lots and lots of garbage that's hard for you to interpret or filling up the hard drive on the other greater. So add this if statement in, it's in the tips and tricks section, you can just copy and paste it. Okay, so then after that, we print a prompt with C out, percent space, and then we read a command. This program is intended to simulate something that you would actually use like type and commands on the keyboard, not something that we would run with input files, but you know, for the process of testing it most of the time, you're going to redirect input. But a real SQL database tends to get used by people type and commands. So that's what it's intended for us. Proud them with the present space, then read command, and then this is where we go and start figuring out whoops, I got to get used to my new iPad here with the with the change of eraser and stuff. Okay, and then we start figuring out which command it is. And there's somewhere in the spec, I don't remember exactly where, that tells you that you can look at just the first letter of each command. Like if it starts with a number sign, it's a comment. If it starts with a capital C, it's create, etc. So you can depend on that. So you really only have to detect the first letter of everything. And then you start processing all those commands, and then we get to the point where the while statement here at the end, which for some reason my iPad wants to highlight, the end of the do while loop is saying keep doing this stuff while the command is not the word quit. And again, you could just check the first letter here if you wanted to. Okay, so that's the basic, basic loop to get things started. So then let's go back and switch inputs again. And then okay, so let's talk about. Okay, so the when you start with commands, what's a good order to start processing commands in? Well, quit command. The quit command is almost done on the screen. I just showed you the only thing is in the start figuring out what command it is, you're going to have to have a a trailing else for an unrecognized command. Like if something starts with a capital Z, we don't know what that is. So there is an error for an unrecognized command. So to make sure you don't unrecognize command for quit, you need like if the command started with Q, well, don't do anything, but it's not an error. Okay, so then so quit is almost done. The next command I would say to do is comment because it's pretty easy. When you see a number time, you do a get line, throw that stuff away, read in your door, come back through that do while loop, check if C and failed, print another prompt, go get another command. Okay, so that's the that's that takes care of the really easy ones. Quit and comment. After that, to be able to see that anything is actually working, you need the create command. So that way we can set up all of the other commands that would happen with tables. So you've got to be able to create a table before you can put stuff in it, print stuff from it. So get create working. Now after that, you might want to jump to print, but resist the urge to remove first because remove is it's not exciting, but it's easy. It's pretty pretty short. And this brings us to an point about the create and tables is this program is intended to keep track of potentially lots of tables. And so you need to have at the high level, you need to have an easy way to go from a table name to a table object, which I told you you should create a table class on a table object. Sounds like an ordered map a way to go from a string to the data that's associated with it. So the remove isn't going to be too bad. You're going to check and see like, oh, if this table doesn't exist, remove is an error. But if it does exist, tell the unordered map, get rid of this thing. Okay, so remove not not too exciting, but easy to code up and easy to test. After that, the next two biggies are insert and print all because that's where you can really start seeing that things are working. So insert puts data into the table, print all to see that the insert worked. Okay, and that's not terrible to do either of those. Insert will be a little bit of work and we're going to go through these in more detail later. But insert going to be a bit of work, print all not too bad. And after those things work, then you can start worrying about the more complicated stuff, which is delete, which gets rid of rows, print where, which only prints some of the rows, not all of them generating an index and join. That's all the complicated stuff. Okay, so I already mentioned the high level stuff. Okay. Now when we've done things before, like with a vector, everything had an index. The index was the key. But now if I've got 20 tables, I want to get to a table really fast. That's where the unordered map comes in to get to that table fast and not have to look it up. It'll linearly search it. We're paths to linearly searching stage. We want to avoid that whenever we can. So like I said, we want to have some sort of unordered map that maps from strings, table names to big table objects. So big table objects. What goes in the table? Well, the the window here is actually pretty useful. The car is marketplace. So the table name, it turns out in the, yeah, the table name is going to be in the unordered map, but I'll give you a hint. I found it was a lot easier if there was a little bit of redundancy in the data. And every table knows its own name because when you get error messages, you have to say, like I was in the middle of print all command and this column doesn't exist in car's marketplace. So for that member function to be able to print its own name, the name of the table should be a member variable. So that's a little redundant, but I'm going to save you some some grief later on. Okay. So then another way to think about it is the stuff that has to go in a table object is basically everything you see in the car's marketplace here. You need the great stuff, the table name, you need the blue stuff, which is the column names, those come from the create command, the column types, which also come from the create command. They're they're invisible here, but we can kind of infer from looking at the data that vendor contains strings, model contains strings, miles looks a lot like integers and prices contain doubles. So the table should know its own name, what the column names are, what the column types are, and then that's what you need to do to get the create command working. Later on, you're going to add the the stuff with a white background, the data that comes from the insert command. So that stuff's all has to be in the table class. And how you store that stuff is not as critical because it tends to be the case that databases tend to have a lot more rows than they do columns. So whether you have like a vector of column names and a vector of column types, or you're like, I need an unordered map in here to make things faster, it's not a huge deal. I've written it both ways like with two vectors I've written with like a vector in an unord map and stuff like that. Not a huge deal there. So do it whichever way seems easiest to you. Okay, so the the important thing is you can't, you've got to make sure you have a way to know which column something is like I have to know that model is column one because when later on I get to like printing stuff and someone says like print the model column, I've got to know that model is index one of each row of the white stuff. So you've got to have a way to know the column names, know the column types, and be able to know which column name goes with which column number. Okay, so when you do the create, you remember all that stuff and you create the table object, and we'll talk a little bit more about that later. And the the stuff that comes from the insert command is really should be a lot like what it looks. So we're getting us into more more important stuff here. So it really should be a 2D vector. You don't want to start saying, oh well, each column should be a separate data structure that's going to produce a lot of grief for you when you get to the delete command. So don't let's not do that. So we really do want a 2D vector to represent that. The white background stuff there. Now the data types here, so it looks like a 2D vector should be a 2D vector, but a 2D vector of what? Well, it couldn't be a 2D vector of doubles because you know the vendor names are strings. It can't be a 2D vector of strings because the miles have to be as integers. And it's important to store them as what they are because later on, like if you say, oh, I don't want to do what they said. I'm just going to make a 2D vector of strings and call it done later on when you get to indices and binary indices. Things are going to come out in the wrong order because the string, one, two, is less than the string containing three. But really, if it was integers, three would come before 12. So we can't make a 2D vector of strings, we can't make a 2D vector of events. This is where starter files that we gave you came in. So we gave you a bunch of header files, a bunch of starter files with like inputs and outputs, but there's also field.h and field.cpp. And that's, there's two important things in there. I wouldn't look too closely. There's some really ugly stuff in there. But if you look in field.h up to about line 20, that's enough. So what you know by line 20 is there's two important types going to be defined in there. One of them is called field and one of them is named field.h and field.cpp. So there's the field class and there's the column type. So column type is just in a numerated type. You've seen those before. You should use that for the create command and to remember what the type of each column is. You have to read in the type of the column as a string like the word double, but don't store it as a double because that's big and it's slow to test. So read it in as a string, remember it as a column type, that a numerated type. Now the field is what should be in the 2D vector that's the result of the insert command. So remember the column type is just in a numerated type. It can tell you the type that a column is, but it doesn't actually hold anything else. It just remembers like, hey, the vendor column is strings, the model column is strings, the miles column is integers, the price column is doubles. Now the field is actually what's going to contain the actual values. And field is called a variant type. It is a type that can hold multiple other types and it's done as efficiently as possible and there's cool stuff in there. But what it does is the field type can be constructed from anyone of the four column types, which are string double, int, which we've seen in this table and bull, which isn't in this table, but is the other column type is Boolean. So once you have a field object that holds one of those types, it will then behave as if it was one of those types. And what that means is if you've got a field containing a string, you can compare it to a string or you can compare it to another field which compares a string, contains a string. You cannot contain a field with a string to an integer. Bad things happen. In the debug executable, you'll get assertion failures. They're like, hey, you're trying to compare a field that contains a string to something else. And that's not allowed. So do run the debug or valgrind executable, the release executable like not slash silly, that one won't give you errors if you mix types inappropriately, but the debug and valgrind executables will warn you about that. So the other things you can do with them is you can output them. So you can output them, like if it contains a string, it'll output like string contains a double, it'll output like a double. The one thing you can't do, so like I said, it behaves like a variable of that type except you can't change the value. Once you make a field that contains Corvette, that field contains Corvette forever. There's no place in this project where you can change values, which makes it not quite as cool as real SQL, but a lot easier to code. So there's other things you can't do with fields. One thing you cannot do with a field is you cannot default construct it. And the reason is a field is designed to hold one of those four types. So it can't hold nothing. So there is no default constructor for the field object. So and another thing it can't do is it cannot be involved in an assignment operator. You can't change it and you can't set something else equal to it because that would be too much copying. So if you get places where you're writing your code and you try to compile it and you get compiler errors, that tells you like you're trying to do an assignment operator and it doesn't exist, that's why you're not allowed to copy field objects. Now the the most I shouldn't say that you're not allowed with sign. You can copy them like you can pass one by value if you want to really should pass it by reference or const ref. So you can pass a field by const ref, you can pass it by value, but you can't equals it. Like it can't participate in an equal sum. Now one thing that means that's really important actually for the create command is you can't say hey when I write the create command, I forget that member function stuff. I'm just going to create this table temp and I'm going to put all the table name and the column names and the column types inside temp and then I'm going to take temp and I'm going to copy it into my unordered map. It doesn't compile because if you're copying a table object, you're copying a 2vd vector of fields, which means you're copying fields and fields can't be assigned like that. So that will not compile. So instead what you should be doing, remember, I said member functions, you should be doing things like hey you know if they're trying to create a table that already exists, that's an error. But otherwise I can be like square brackets that table name call the create member function because as soon as you square brackets that table name bam the table exists, you call the create member function and create does everything else. Like the stuff outside of the member function should read the word create, it should read the table name, figure out if it's a valid create or not because it already exists, it's bad. But otherwise square brackets call the member function, member function does everything else. Other thing it means, there's going to be something when we get to insert. So I'll talk about it and there's something else we can't do when we get to insert, talk about that. So actually yeah, we're kind of at this point let's talk about insert. So when you do insert, you have to do it efficiently of course it's 281 right. So you can resize the number of rows like you know like cars market place here right now it's got one two three four has it it's got seven rows worth of data. Let's say I said insert 100 more rows. Let's do 102. I'm sorry I'm off on my numbers. Yet let's do 130 more rows. So if I say hey insert 130 rows, if I just let it grow organically it would grow up to like 137 but not really it would have 137 behind the scenes there'd actually be 256 rows and almost half of them would be wasted. And if I let the columns grow organically with four not too bad but what if there were five it would grow by doubling and I would be using five out of eight columns in each row and I'd be using 137 of the 256 rows I'd be using like one quarter of the data. So we do want to resize the number of rows. So I'd say like hey I've got seven now they want to insert 130 let's resize it to 137 and then let's start at row seven and start inserting some new data. Now when you get to row seven you can't resize the row because if you were to resize the row you would have to default construct every column and that won't compile. So you can reserve the number of columns. So you resize the number of rows, reserve the number of columns in each row that you have to put data in and then you do the reading the data and putting it in there. Now as we're working with the insert command what we're going to have to do is we're going to have to say basically for every one of those new rows reserve the right number of columns then for every column that is going to exist because the insert command has to have data for every column for every column that's going to exist I've got to read something and put it in the 2d vector in the row. So I'm going to have a for loop for the rows do a reserve for loop for the columns. Now when I get to the columns I've got to do a four way split because the column type could be one of four things. You're like well can't I just read that double as a string yes you could but that's going to mess up so do a four way split if this column can take a supposed to contain a double create a double variable we read C in into a double variable and then add stuff to the row and add stuff I'll get to that in just a second. Now this four way split is important because it's going to come back again in the delete command because there's a way or clause in the delete command and it's going to come back again in the printware command because there's multiple types there it's going to come back again in the join command because there's multiple types there. Now now that we've got something like a double it's time to learn something important that you may not know already. So we need to learn the difference between pushback and in place back. So what we've been using up until now is pushback and what pushback means is basically let's say I've got a vector of type int and I have an int I use pushback to I've got an int put the int in the vector. Now suppose the vector doesn't have that type. Suppose I've got a vector of say fields but I just read an integer and I want to put integer inside of there but I want to turn it into a field. The wrong way to do it is to create a temporary field object containing the double then pushback the double. That's the inefficient way of doing it and it's the way that doesn't show employers that you really know your stuff. So the way to show them that you really know your stuff is like you say hey I've got a double but this is not a vector of doubles it's a vector of fields but there's a constructor that can take a double and produce a field that's where you use in place back. So you in place back the double and basically in place back says I've got this thing hand the thing off to the constructor at the exact right spot and construct it where it belongs and it's really super efficient. So we want to in place back what we read not pushback and we can't push back in a double because it doesn't contain doubles we don't want to create a temporary variable we just want to in place back the double constructor that converts from a double to a field runs automatically at the right place. Okay so we do that for every row for every column I do a four-way split on the column type read that type in place back go back through another column check the column type read the stuff and then when I move to a new row reserve the right number of columns loop through the the columns within that row read read it four-way split etc. Okay so now we've got insert done now is the time to print all because then we can see that the insert actually happened. Now technically you could do this with your debugger if you're really excited you want to know if that insert worked open up your debugger open up your unordered map open up the table object open up the 2d vector data whatever you call it open up the stuff in there and it's going to be a little bit hard to read because there's these variant types have basically every field object has four member variables but only one of them will make sense so it might be a little bit hard to read in there but it's it's there okay so print all let's talk about print all so when we do a print command let's just forget forget print all just a print command itself when we've got the print command it's like print from table name okay so I read print I read a junk word I read a table name make sure it exists if it doesn't have print there and now here's the place where we want to start doing some member functions and helpers etc so you're not going to need all of this to begin with but you're going to need when we when we get to that actually let me just go through the spec let's get to the print command so we can see the syntax here okay print okay if we say print from table name okay so I read the table name and then I call the member function then the member function can read and the number of columns and is the number of columns to print so when I read a three here I know I can loop three times and read three column names make sure all of those column names exist if any of those don't exist there's an error for that but if that succeeds then I read the next part which is either going to be the word where or the word all and now here's a great place for a helper function make a helper function for print all make a helper function for print rare code it up later all right so then we want to do a print all command so now for print all they want what all means is it refers to the rows the wait where my mouse go okay so the the column names here these are what in each row they want to print but the I looks like I've got a little bit of a problem with the with my screen the width of the share okay yep so I've got the so these are the names of the columns I want to print with any row but the all means I want to print all of the rows so if someone said like going back to our cars marketplace if someone said print two things vendor and our model in price if someone said print from cars marketplace two things model price all that would mean we want to print every single row is the all and we want to print the model and the price for each row that we see so then we would start a loop outer loop is for every row of the table inner loop is for whatever columns they want print print out the data in those columns oops yeah there we go multiple windows open here and actually have multiple monitors to keep track of my recording software and everything else let me actually let's make sure the recordings okay it's still recording good okay so print all is going to have those loops make sure you get a backslash in after every row but not in the middle of it also after every column print a blank space even after the last column print a blank space so if I said like you know it would print like clorvette space 25965.00 space and then it would go to the next line so so you can have a space after the last one you don't have to code that up special so then with the print all now we can see that the create worked we can see the insert worked we can see print all is working try it with you know multiple different commands of what if I print this column then that one what about that one followed by that one make sure everything comes out in the right order do it with tables that exist with tables that don't exist do it with columns that exist that exist columns that don't exist test all those things before you move on to the next okay so then after we got those done also make sure to test it I mentioned this earlier but in staying out loud test it with multiple inserts I've seen people's code work perfectly fine with one insert but as soon as they do two inserts stuff starts breaking so make sure you test it with more than one insert do like create print all better print nothing because there's no rows right then do an insert then a print all then do another insert and another print all to make sure that that second insert worked properly it didn't overwrite the first one didn't produce garbage data make sure that works okay who's up next and after that I would say delete command now the delete command again we're probably might want to have some maybe a helper function and the reason is we've got to do a four-way split so if we look at let's bring over our spec here let's go to the delete command and I wish I'd realize the the width thing let me see if I change okay just second let me try changing oh now that's a little too narrow okay I'm trying to get the width to the point where it doesn't it doesn't wrap okay that seems okay so now all right here we go wait there's right I've got too far okay where's my delete command okay there we go so here's my delete command so delete command you say delete from table name where column name some operation and then a value so you you read the delete from table name make sure it exists if it does start calling the member function member function reads the junk word where read a column name read an operation and then you have to do a four-way split because depending on the column name and the column type how you read this value is going to be different so the operation is always just single character but the value is different so we need a four-way split here so that we can read the value so like if it was a double I'd read a double and then I call the helper now and the reason I want to have a helper function is that helper is going to have to do less than greater than or equal to and what I don't want to do is I don't want to code up delete 12 times right you could you could code up delete once and be like oh I just copy this 12 times change this type to that type change this equals to that greater than you could but don't do that resist the urge to write delete 12 times so instead in the starter delete function we do a four-way split on the type we read what we need like an int or a double or a string or a pool and then we call the helper function like the delete helper all right so like for example back in let's go back to the example the cars marketplace if someone says like delete from cars marketplace where price is greater than 50,000 like we just know they're not selling let's get rid of all right so that's what I did in the command to the program so I read the delete from table name it exists called member function read the the word where is junk read the column name or which is price and then I read the greater than it's always a character then I got to do a four-way split read up that double now I want to call my delete helper but what do I give it do I give it a double no if I give a double I'd have to write it four times you could give it a template type we don't need to instead simpler way is if you read a double just create a temporary field variable containing that double you're like field temp field of temp double done you got you got a temporary field object now you can pass that field object to the helper the helper doesn't have to be templated it just has hey I accept a field object by reference don't pass them by value okay so the helper accepts the field object and then the helper can then do this three-way split on type to figure out hey I do less than this way greater than that way equal the other way so in the delete helper I'm going to have to be passed the field object and I'm going to have to be passed the comparison and I got to have like the column name or something something but something I need to know which column I'm supposed to be working on because I got to know the type has already been read but I'm going to have to know the column number later on okay now when we do the actual work of getting rid of those rows um you want to use the STL so there's an STL algorithm and it's one of the ones that's listed in canvas files resources algolist.pdf it's one of the ones in there so think about what you're trying to do you're trying to get rid of things from a container and only you don't want to get rid of all of them you want to get rid of some of them based on some conditions so look for the one that does it and what that algorithm is going to have to be given is basically like your 2d vector begin your 2d vector end and a fork door to help it decide which rows need deleting and basically you need a fork door that's going to return true for the rows that should be deleted now the reason you want to do it using the STL instead of coding yourself is if you code this yourself it's very easy to end up with delete rows being o-of-n squared and the STL algorithm is going to do it in o-of-n time so we want the o-of-n time so the func doors this is where it's going to be a little tricky that's going to be like the trickiest func door you ever wrote so it is not a comparator so let's think about what's going to happen right we give this STL algorithm the beginning and end of our 2d vector it has to loop through that container and everything it sees it's going to show it to the func door and say hey func door should we get rid of this yes or no true false so the func door has to be accepting something from iterating over the entire table now let's do a simple example if I had a vector of like strings and I wanted to get rid of like everybody named Bob right the vector of strings I would loop through the vector of strings or I wouldn't loop the STL algorithm would loop through the vector of strings and it would be like here's time hey func door should we get rid of time okay here's Mary func door should we get rid of Mary oh here's a Bob func door should we get rid of Bob so the STL algorithm is going to loop through the strings it's going to hand a string off to the func door if it was a vector of integers it would loop through the vector of integers and it would show an integer to the func door well you've got a vector of stuff it's going to loop through your vector of stuff and it's going to pass a stuff to the func well what is your vector it's a vector of vectors so what the func door has to accept is actually an entire row an entire vector of field objects oh boy you better pass that by reference const reference right so then so the func door has to look at a row and go hey this is a row it's got this stuff like Chevrolet Corvette 67000 25965.00 should I delete it well wait a minute now the func door already knows what type of func door it is right like if you created a a get rid of equal rows func door it it can do equals but what it doesn't know is what column should I look at and what value should I be comparing it to the stl algorithm cannot give those to the func door the func door has to know the the func door needs some member variables inside the func door it's got to know what value to compare to and what column number to compare to it's got to know oh you should be comparing column three to this 50,000 because that's who we want to get rid of we said we're going to get rid of any row that has a price greater than 50,000 so it's got to know column three it's got to know then when it looks inside of that vector of fields at column three it's got to have something to compare it to wait what should I compare it to a field object a field object that better contain a double because I'm comparing it to a column that contains doubles okay so you're going to write write one func door like write one for equal or greater than or less than get it compile and get it working and then once you got it working the other two func doors are just going to be copy the func door change the name change the comparison write some new code to create the new func door off you go so the first one is going to be the hardest so it's going to have to have some member variables it's going to have to have a constructor and it's going to have to have an overloaded operator parentheses that accepts a row now one other thing you have to be careful of once you find the STL algorithm that gets rid of stuff the name is a little misleading because it doesn't actually get rid of them it rearranges them it rearranges it so that the rows we want to keep come first and and the rows after that are who knows what they're not well defined so for example in the cars marketplace here if we got rid of the ones over 50,000 we would be left with the first corvette the first Malibu the second Malibu and the third Malibu that's all that we'd have left we'd get rid of the second corvette we'd get rid of the Mustang and we'd get rid of that fusion which I just realized has a weirdly high price but oh well too bad videos videos have done okay so so it would rearrange it so that we had like corvette Malibu Malibu Malibu and who knows what's in the other three and then we have to we have to actually do the work to get rid of those other rows now we did something like this in lecture nine after we called set union we did some code to remember hey where did set union leave off and let's get rid of everything from there to the end same idea this stl algorithm is going to tell you where it left off it's basically going to give you an iterator to the first row that you don't want to keep it's going to give you an iterator just past the last row that got kept so if there's four rows kept you would give you an iterator pointing to except it basically pointing to row four so I want to be three it'd be an iterator point this one get rid of everything from there inclusive to the end of the 2d vector exclusive so look at the lecture nine slides when we after we called set union look at the harder version not the one that does it that does the the wrapper class that does the back and certain that's the wrong one look at the top half of that slide okay so after this the last two things to do is printware and generate indices I would say printware is the hardest code to do I like I think the thing was last time we gave this project I decided I'm going to write this project from scratch brand new inflow implementation from the ground up I'm going to write a really good one that I can give to the staff that like we've got staff members who are good but you know they did a different project three maybe they're kind of heavy workload this semester they don't have time to write at C Cili QL but I go on to give them a really good well written one and I just started coding I'm just like sit down burning off code and I got halfway done with printware and I realized I'd coded myself into a dead end and I threw out the code and I started rewriting it and I coded myself into a dead end and then I went you know what I should be doing what I tell my students to do which is plan it out before you code it so I got out my tablet I drew it out I'm like okay this is going to this function is going to do this then it's going to call this function and then it'll do that and then after planning it out then I was able to write it so so the printware is the most most complex function so I'm going to do that one because at the beginning it's going to be more straightforward than join join is going to be the most foreign to you I think so we'll do printware and then we'll come back and do join okay so when we do the printware first of all you have to do a because it's going to be a printware like something is greater than something printware prices less than 20 thousand so you need to do a four way split on the type then you have to read that type in call a helper function give it a field containing that type and the column number that's on and the column numbers that need to be printed give it all that stuff and then the helper function can then start doing like oh wait well now I've got to do like a three way split on the less than and greater than and equal to and and then there's going to be other things that come in with indices there so make sure that when you write up the printware do the do the four way split call helper start doing then then helper functions beyond there now before we go any further we're really going to have to talk about indices and generate so generate is we need to do generate because generate is actually not that hard to code up it's the things it's going to do after that so let's talk about generate before we come back to more printware stuff so let's talk about why a database has an index basically the indices there are are there to speed up future commands running a generate index takes time but it's going to speed up future commands and so for example if I'm a person who sells lots of used cars I might know that lately prices are really important to people and I bet I'm going to be doing lots of queries today that involve prices you know that people are doing that less than they come in looking for a specific vendor or specific model so I might say hey let's generate an index on prices that's going to make all my queries later on faster especially if you know there isn't seven rows to the table but maybe there's seven million rows in the table so I want them to fast now if I'm going to be doing things like price less than 20,000 a hash index isn't going to help me hash indexes only speed up equals they can't do less than or greater than at all so if I'm going to do less than I want to generate a BST index so BST helps with any comparison less than greater than it helps with equal but a BST index is a log and look up so it does help with equal it's not quite as fast as a hash on equal would be but a BST is nice and versatile now if I get to if I get to you know a time in a month from now where like people are buying lots malibus maybe the next day I come into work I'm like okay today I'm creating a hash index on model because that's what people are asking for they're asking for specific models a lot so if I'm going to be doing lots of equals I'll generate a hash on that column if I'm going to be doing lots of less than and greater than and maybe some equals I'll generate a BST on that column now to simplify your life a table can only have one index now I could have multiple tables each table could have its own index but a given table can only have one index can never have more than one so you could have two member variables one for a hash one for a BST but they can't both be full they can both exist and be empty that's not wasting too much memory but only one of them can be full at a time so if generate someone generates a new index on a valid column clear them out generate a new one make sure you clear it out if you don't bad things happen up okay so we'll need an unordered map for a hash index we'll need a standard map for the BST index so then once the generate command is started it's going to have to remember right I do have an index what type is it or do I have an index you know I start out with no index I could have no index could have a hash could have a BST hmm sounds like another enumerated type so I have no index that's where I start out I could have a hash later I could have a BST but I can only have one of those three types I need to know what column it's on remember column numbers don't remember column names once you know that a column number is valid you or not you know that a column name is valid you know what column number it is remember the column number so then to finish the generate you've got to make sure the index is correct right you got to loop over that data and go hey if someone generated like a BST on price I've got to add 25965.00 to the hash and refer them back to this row of the table do not make a copy of the row that would be way too much data you got to have an easy way to get to the row well what is it it's part about 2d vector right so what should you store as where to find the price 295.006.005 think about that simple think P1 what do we do okay so then you go through all these like 25965 this one 72 73 that one etc you go through every row and do that now what you're going to have to do is you're going to have to go back to the commands you already wrote and make sure the insert if someone does like an insert and a generate another insert that second insert has to participate in the index so you've got to go through the new rows and make them part of the index if someone deletes rows after deletion occurs like if everybody if someone deletes everyone where the price is greater than 50,000 and then you say like print where the price is less than 20,000 you got to find the right ones now turns out I'm going to be a hint here turns out that indices are not your friend when you're deleting rows um they hinder you more than they help you so don't try to use the index to get rid of the rows when you've got an index and you're like oh I got to redo the whole generate or the whole delet command not too much do the delete like you already did it and then fix the index uh oh you're hungry now we will get you in a little bit oh great now we got to show cat again come here let's show everyone you this is yuki she's a main tune she's completely deaf and she is very very food motivated and it is her dinner time but she'll get fed after videos done okay so when you do the delete um so do the delete normally and then go back and fix the index it turns out fixing the index is hard think about something that's easier and think about this if you try to fix an index it best it's going to be all of the old number of rows well now that you've deleted there's probably less rows we want all of new number of rows so think about an easy way to do that it's it's easy it's don't make it too hard okay so now we've got it we've got an index generated now let's go back to talking about print uh print again now print all is not going to change whether there's an index or not I don't care I'm not even going to look at it print all remains the same and this is a place where maybe even more member functions would help like hey I've got a print all member function I've got a printware member function all right so in the printware what you want to do is you want to start by checking doesn't index exist whether it's on the right column and whether the index helps me how can an index exist in this table on the right column and not help me if I say printware greater than and it's a hash you do it as if there was no index so we're going to need basically we're going to need like a printware when there's no index a printware when there is a hash that helps us a printware when there's a bst that helps us and maybe even that one will go through you ways for the less than greater than equal to you might do three helpers there you might not it's not too bad either way so you basically you want to say in the in the printware if there's a hash and it's on the right column and I'm doing an equal new code else if it's a bst and it's on the right column new code else code that doesn't worry about an index so if you want to do the print where without an index that's fine do the printware without an index put it in its own function you're going to call it when there's either no index or the index is on the wrong column or it just doesn't help you so this is a place where code doesn't get thrown away it just gets moved around all right so when we do a printware with a hash basically if someone said like printware model equals Malibu I'd be like hey hash does Malibu exist at all right if someone says like printware model equals navigator right I go are there any navigators nope we're done here fast but if there are navigators maybe I'll loop over the 10 navigators instead of the 10,000 rows in the whole table really speeds us up okay so we do that for the hash for the bst we're going to do it different if it's less than greater than or equal to the equal to is going to look a lot like the hash version hey bst do you have a navigator oh you do okay let's print those let's print all the navigators oh you don't okay I'm done no rows to print okay then for the less than and greater than you're going to want to do it differently because the bst has you can you could loop through the whole bst but that would be a waste of time because the bst has some member functions that can find you this place or that place so you could print from like this position to the end when it's greater than or you could print from the beginning to this point if it's less than so the the bst the hash table has some member functions that the the bst standard map standard map has member functions that standard hash does not to find places that maybe don't even exist right I could say printware model less than I'm trying to think of some of the some that doesn't exist that is in this range I should have thought in more cars before I got here I don't know cars that encore printware model is less than an encore right you can't do a find on it because it doesn't exist there's member functions that'll help with that so look at the look at the standard map and look at its member functions for looking stuff up there's a find and there's two others that'll really help you there okay so this brings us to join now first thing about join is join does not create any new rows it doesn't create any new tables it just does the result of the join and prints a bunch of stuff the other thing about join is that it is called with two tables and you know like wait a minute how do you do member functions with two tables well you could say hey assuming they both exist table one member function here's table two oh better better definitely pass it table two by by reference of course okay all right now I got to rearrange things on my desktop here and then I'm going to start sharing differently so that we can go through a join in a minute okay so the basic idea of join is that we're going to match up things in the first table with things in the second table okay so I think I got this ranged well there we go wait wait let's do this and I got no that's just worse okay let's go back see if I reduce the size this a little bit no that doesn't help any it's still in the same place okay this is not going to be perfect but it's going to be it should be good enough move over just a little bit we'll crowd it a little bit there we go okay so we can see and I've got sample output below and the input and output to produce this is in the starter files so there's like there's like join input and join output it's all in there all right so the idea of join is what I want to do is I want to do the same effect that would basically happen if I was to write the naive implementation of join it would basically say hey let's loop over all the rows in table one cars marketplace so that's my command here so it says I've got oh I forgot to I got to intro this better okay so I've got a new table over here called prof cars in the prof cars I have three columns name vendor and color and some of these are true some of them are made up so anyway then I so I've got these and I said join cars marketplace table one and prof cars table two so right we got table one table two where the capital vendor notice capital vendor over here in table one is equal to lowercase vendor lowercase vendor in table two so what we have to do is print the results the naive approach would be and this is too slow but the naive approach would be loop over every row in table one and then loop over every row in table two and say hey I've got a Corvette in table one table two row zero are you a Corvette no row one are you a Corvette no row two are you a Corvette no row three are you a Corvette no so row zero oh wait I did this on vendor sorry I did this on vendor so I say hey I've got a Chevrolet row zero are you a Chevrolet no row one are you a Chevrolet yes okay so that matched row two are you a Chevrolet no row three are you a Chevrolet no okay let's go back to row one row one Chevrolet go back to table two are you a Chevrolet no yes no no so you have to that would be the naive approach that would give you right output it would be way too slow so we have to produce output as if we had done that this is a place where if you write the naive approach you're going to have to throw it away because it's going to be too slow so what you need is you need an index to speed this up so if the if the index that you need doesn't exist make a temporary one in like a local variable inside the join member function make a temporary hash table to make this thing faster now as I said the order has to be the same order as if I had gone through every row of table one and gone through every row of table two so then think about which table and the example I just did which table would it be helpful to have an index on obviously it would have to be on the vendor column uppercase or lowercase it would have to be on the right column but which table would it help me to have a hash table on one of them yes one of them no so think about that now let's run through our example here and I've got I've got this prepared so like I said so we run through when I get down to cars marketplace row zero one two three four when I get to row four it gets a little more interesting I go hey I've got a Ford table two do you have a Ford here yes that matches no yes this one matches I get two matches for this one so if we look at the output there should be nine rows of output one row here two three four five six seven eight nine and I know this is a little bit they are a little bit off the screen there I don't have an easy way to make this better let's just move it over a little bit we can overlap the price of there because really we care about the models okay yep so we can say hey this produces one row one row one row so it's one two three four five six seven eight nine rows of output and here's what it should produce so I said join cars marketplace and profit cars now really the joint command should be all one line I put it here on two lines just make it more readable but in the input it does have to be all on one line but a well written programming really shouldn't matter a well written program should just be greater than greater than everything here and it should work just fine actually okay so the output for this I said and print oh and you should understand this it says and print print three things print capital model from table one print lowercase name from column two and print lowercase color from column two which is name up here and color up here so I'm going to print the model from table one and then I'm going to print whoops and then I'm going to print the name and the color from table two and you don't have to put them in this order you could print you would say and print three name two model one color two the columns would be in a different order but otherwise you'd have the same rows okay so here's the output of that first things is the names of the columns and to make this project easier we didn't make you figure out like how wide each column was make it line up pretty too much work so that's so we print the column headers and then we print all of the matching rows there's a corvette up here that matches because it's a Chevrolet we're not printing vendor we matched on vendor but we're printing the model so we say they hey there's a corvette here in table one that matches pay a letty's data in table two it really it matched the Chevrolet part and it prints the color blue and then it goes through and there's the output so like I said this one in that in that and at the end we get a summary line what what's what it would be and and we haven't talked about I didn't realize until right now I haven't even talked about quiet mode so if quiet mode was on you would basically see this you would get the summary I know you wouldn't get the rows I'm pretty sure you don't even get the column names I can't remember make sure that one but um but you would really you wouldn't get the rows you'd only get the summary line so that's what quiet mode does is basically it shrinks the output so it doesn't fill up the hard drive on the autograder so that's why quiet mode exists so quiet mode is really going to come into play in print all printware and join is the ones that really have to worry about quiet mode but you got a print summary it printed nine rows yet we printed nine rows there the headers the column headers does not count as a row it's just the names of headers there's nine actual rows of data there okay so like I said over if we look at the spec again over in the starter files so we've got the tarball error messages there's only two of them field.h field.cpp like I said don't look at these too close field.h has the like the first 20 lines is the important stuff make file give you project identifier it's it's in the spec also we gave to you here we got the checkpoint one two and three the checkpoints exist as test cases on the autograder they're sort of ways to gauge your progress and also extra small inputs join input and output comes from the one we just did and spec input and output come from the one that's in like the spec example and then also like I said make sure you look at the project video obviously wait a minute I'm gonna even say that I'll remind you to watch the video that you just watched at the end of the video you just watched okay anyway that's the stuff you've got the project spec is big but very useful this is a very useful very cool project so enjoy yourself with the project good luck on it will be there for you and off-sours