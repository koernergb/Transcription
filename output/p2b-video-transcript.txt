 Hello, I'm going to record some videos to get ready for Project 2 and this one is about Project 2 Part B, which is I'm going to talk about the sorted PQ, binary PQ and pairing PQ. Now in the past what I've been doing is referring to students to a video that's already on YouTube that you can find. And I'll write with the link in there also because it never hurts to have more resources. But I had a student in the past make sure a recording of me during office hours and posted it to their YouTube channel. And it's fine except that now that we've got our own EX281 YouTube channel, I'd like to have it living with our stuff instead of with that students. Also that recording was all about pairing heaps, so we're going to start by talking a little bit about sorted and binary, which will help you on those. And this is the order I would suggest doing them is sorted then binary then pairing. But don't wait to start understanding pairing until you're done with the others because you want to start understanding the pairing PQ and the pairing heap is really probably the hardest part of Project 2. So let's begin with things that they have in common. So all the priority cues have two constructors. They have a default constructor and they have a range based constructor. They all share this. Now the pairing PQ has more than this, but they all have these. So the default constructor is pretty easy for most of them. We create an empty priority queue. And the range based constructor is saying, hey, I'm going to give you two iterators. And in the slides in the begot starter code, I can't remember if they're called like start and end or something like that. Let's just call them start and end and hope I'm right. Okay, so we're given two iterators that point to somewhere, inclusive, exclusive. Now when you start on the sorted PQ, what you want to do is look at the unordered PQ. So the unordered PQ is already done. We wrote that one for you. And it's more simple than the sorted PQ, but some of the things in there will be very useful to you. Like what does the unordered PQ do to get the data from these two iterators into the underlying data, which is a vector. So how does it get them into that data vector? How's the range based constructor for unordered work? And you can start there and then do a little bit more because in a sorted container, when I copy a bunch of data out of somewhere else, I have to make sure it's in the right order. It can't just be left in the original unordered state. I've got to get it in order. And, excuse me, anything else that we would need for in terms of like a big three, copy constructor and operate equals binary and sorted, we don't have to write those. We will therefore get a default copy constructor and default operator equals that will copy all of our member variables. Well, the only member variable we've got is a data vector and it's got its own copy constructor and operator equals that does things properly. So for sorted and binary, the copy constructor and operate equals exist, even though we don't write them at all, but they just rely on the fact that the underlying data vector is going to be copied properly. It's going to do a deep copy of that underlying data vector. Okay, let's talk about sorted PQ now a little more specifically. In sorted PQ, you've got to be careful of the complexities of the different operations. Like for instance, if you look at sorted PQ push, it'll say that it is log out. Or sorry, start not log in or about. So the sorted push is O of N. I've seen countless people who they just say, hey, if I need to push into a sorted vector, I'll just push back to the underlying data vector and then call sort or call update priorities, which is O of N log N and that's way too much. So you can't just push and then call update priorities or do a sort. It's too complex and it'll be really, really slow. So instead what you want to do is you want to get it to the right place inside of the vector. And the other thing you don't want to do is you don't want to be writing loops in the sorted PQ. If you find yourself writing loops to get sorted PQ doing, you're doing it wrong. What you want to do is you want to use pieces of the STL. And in fact, when you write the sorted PQ, it's going to be line for line of code. It's going to be the best points to lines of code ratio like this whole semester. The sorted PQ can literally be written in like six lines of code. That's including lines that, that doesn't include lines that we put there that you have to delete. But lines that we put there that you've got to modify and and lines that you have to add adds up to about six lines of code. And what you want to do is you want to use the underlying STL. So there are things in the STL that will say, hey, where is the right spot inside of this already sorted vector? And once I've found that, how do I make a data vector put a new element in the middle given? Ooh, I don't know, maybe an iterator. So there's a data vector, I should say vector. There's a vector member function called insert. It says you give me an iterator and a value and I put it in there. And so then only you have to do is find an iterator to the right place to put something in there. Do we want to do a linear search to find that correct position? No, it's sorted. Would it still end up being O of N if we linear search? Sure, it's still O of N. But it's too big of a constant of O of N, you'll go over time. When you want to do the update priorities, all you're going to be doing is using sort. Now there's one thing special about how we implement these. And I'm going to mention it, I should have mentioned a little bit earlier, but now's a good time, because now's when it's important. When we call the underlying STL functions that do things like sort or find where the right place is for something, they're going to need an optional parameter. So like sort is required, you're required to give it two iterators, beginning of range to sort and end of range to sort. However, if there's an underlying data type that has a special comparison, you've got to give something of that comparison type to the sort function. And when you do the push, you're going to have to do this in the STL function. I'm going to make you a fine name, but that thing is going to accept two iterators of value to find where it should be. And the fourth one optional is the funk door to tell it, how do I compare the data type? Now part B here really, we are looking at the internal view, internal meaning we are the priority queue. Somebody gave us some type and we have to make it so that when they say push this in, we know where the highest priority element is when they ask us to look at the top, we can show them the highest priority element when they ask us to pop, we can get rid of the highest priority element, but we have no clue what that data looks like. What we're going to use is this arrow compare. Where does that come from? It comes from the x281 pq, which is our base class. So all of our classes here that we're writing sorted binary pairing and unordered, which we already wrote for you, they all inherit from this base class. And this base class has a member variable called compare. Now you would think that because we inherited from base class, when we want to use it, we could just say compare, but we can't. The reason is that we are writing sorted pq is a template, a templated class that inherits from something, which is also a templated class. And so when we inherit from a templated class and we are a templated class, we are in what's called a, you don't need to know this for the exam or anything. We are in what's called a dependent context. And when you are in a dependent context, you can't just say compare to get to the thing in the base class. You've got to say this arrow compare to get to the thing in the base class. Some compilers, if you leave off the this arrow then, some compilers will accept it. Some will reject it and some will reject it and remind you that because you're in a depended class, you should be using this arrow not just compare. So if we use this arrow compare, it will work with every compiler. Okay, so when we want to call sort like in update priorities, we'll give it the beginning end of of what of our data vector. And this compare and it'll do the work. When we do the range based constructor and we get everything into the vector, we can just call update priorities. And you could say, well, why don't I just set why don't you sort it range based constructor? Why don't I just write that sort line over again? We're getting ready for binary. So in the binary pq, the getting things in order is going to take more than one line. So it would be easier in sorted pq and binary pq if we just say, hey, range based constructor call update priorities. Now, remember me now and believe me and remember this life, when we get to pairing pq, you cannot do this. We'll talk about pairing pq's range based constructor a little bit later, but this works for sorted and by. So we get everything into the underlying data vector and then we call update priorities to get it all in order. Okay, so that mostly takes care of the sorted pq. We're going to maintain it so that it's always in sorted order. One other thing that's important about sort pq is when we do pop, it says that the complexity of sorted pq pop is supposed to be. It might say amortized, I don't remember, either way, it doesn't matter. It's basically all one, which means that the highest priority value better be at the back of the vector. And it turns out that the sort and the comparator that we want to use for the priority queue and the and the functional one use for the sort function for the STL, they all work together great. So when you sort by default, you're going to get a sending order. And if the highest value is the highest priority, then when you pop, you will get rid of the highest priority because it'll be at the back of the underlying vector. You'll say, hey, underlying data vector pop back. Now, if the functor reorders in a different way, let's say the functor produces a min pq. Well, then when we sort it with the sort function, it'll be in descending order. The smallest value will be at the back of the underlying data vector and that will be the highest priority value. So the the functor that we use to make the pq and the functor that we give to the sort work really well together. Okay, now let's talk about binary pq. Binary pq is not going to be super long, but the thing about binary pq is, let's say, change times our hero. So in binary pq, what you want to do is go to the heaps slides. Now, it's called heaps and heaps sort. Heaps sort, as I'm going to say this now, remember, heaps sort has nothing to do with binary pq. So if you start putting a heaps sort in here, you're doing it wrong. We don't need heaps sort for binary pq at all. We've learned it while we learned the binary heap, but it's just another way to use a binary heap. Here we're using a binary heap to create a binary pq. We have nothing to do with binary for it. Sorry, we have nothing to do with heaps sort. So we're going to look at the heaps slides and we're basically going to do what they do, except we've got to translate two or three things. The biggest hardest one is the slides use one based indexing. They assume that you've got some array and array sub one is the very first element. But when we start doing this, the binary pq is going to have a vector vector vector of some type data that we have to use. And that's one of that's our member variable. And it says you must use this member variable. So when we translate the one based indexing to zero based indexing, there's three methods outlined in the projects back. We can translate everything in the slides to zero based indexing and make every formula work. That's the hardest way to do it. A an easier way to do it is to put a dummy element in the data vector. So I would put a piece of garbage at index zero that I'm never going to look at and never let anyone use. And then I'll fill a little bit when someone asks me what is the size of your binary pq? I'll say, well, my size is data dot size minus one. And you ask me if I'm empty. I say, well, if the data vector says it's size is one, then yes, I am empty. And then I'll just make sure that I never ever access element zero other than getting it in there. That one's a little bit harder to get right than it sounds because of the, how do I get a piece of data in there when I don't know what this data type is? Third way, and it's in the projects back, is we gave you some code for two functions called get element. There's two different versions. There's a cast. There's a cast version and there's a noncats version. And those you can just type them in. Please don't copy and paste from PDF file. If you do, it probably won't compile because PDF files do funky things like they put in little invisible characters to make things line up in a pretty way. They turn a minus sign into an extended hyphen that looks better, but will compile. So if you use the get element method, the hardest part of that is just retiping. And then like everywhere in the slides where we say like K that array sub I, you would say data vector square brackets get element parentheses, I say things like data square brackets, get element. parentheses, I. Now the other thing that's hard about translating the binary heap slides into the binary pq is the use of this compare. So you have to use this compare in the slides where you see something that says like if a is less than b. And these are and you got to be careful here. We're talking about data. If it says something like if I is less than J and those are indices, you leave it alone. Those are indices. I know what they are. But if it says something like if if something like let's do another example, if data sub I is less than data, subject, you have to translate that. So what you have to do is you have to use this compare. So what I do instead, I'd say, hey, this line becomes if this arrow compare of. Oh wait, I can't say data sub I might have to translate that with a get element. First thing, comma, second thing. So this one goes here, this one goes there and we might have to translate it with the get element, et cetera. That's what this compare does. This compare answers the question. So if we pass this compare. Just change colors here. So if we do this compare of a comma b, whoops. No, I don't want my keyboard. I don't want less than a comma b. So if I do this compare of a comma b, it answers the question. Is the priority of a less than the priority. No, I don't need the keyboard priority of b. Okay, so that's what this compare does. It answers that question for you. So if you see something in the slides that compares indices, you're just comparing disease. But if you see something in the slides that contain compares data values, you've got to translate it to using this compare. Instead, okay, let's see. What else do we have to do about binary pq? Like I said, range based constructors just going to get the data into the data vector and it's going to call update priorities. What does update priorities do? You ask. What's update priority is going to do? It's going to do what's in the slide is called the heapify. Now that thing is not in the slides. That thing is in the video. You've got to go look at the video, find that part and look at how the heapify works and make it happen. And what heapify and the other things in here are going to do is they're going to use the other things in the slides, which is fix up and fix down. And what you should do, these should be private function, member functions. So when you modify the binary pq, there's a section down there in the private part that says to do add stuff here. That's where you'd put the fix up and fix down code is down there. And the other thing you have to do to translate from the slides is remember the slides has an array and it has a variable called like heap size. Well, do not keep a separate variable called heap size. If you want to know how big the heap is, look at the underlying data vector. Or you can call your dot size member function. So don't keep a separate variable for that. Don't use an underlying array. You've got to translate it to using an underlying vector and the vector always knows how big it is. And if you're doing the dummy element where I keep an extra one in there, that's why we would use the binary pq version of dot size is because it would translate, you know, the data vector says five, but dot size says four. We want to base it on the number of elements in there, which is four. So when we do the push, so basically when we do the push for the binary pq, what we're going to do is we've got to take this value. And whatever we do, and we've got to put it into the data vector. And then we've got to do a fix up. And when we want to do the pop, we got to say, Hey, pop. Get rid of something in that underlying data vector and do I fix down. And I drew it like an accept the beginning. We're not actually going to erase the value at the beginning. It would be all of that. Remember what the slides do. The slides say, Hey, let's replace this value with the last one. And then let's get rid of the last one. And then we can call fix down. OK, so that should take care of our sorted pq and our binary pq. Now it's time for pairing pq. Now remember when I told you in project one, don't use pointers in project one. You don't need them and you'll get more than you want in project two. This is where. So in the pairing pq, the basic idea of a pairing pq is we're going to have what's called a pairing. Keep. And we're going to do use this to produce the pairing pq. So what's a pairing keep? One thing about it is it's all held together with notes. Every node in here is going to have a child pointer. It's going to have a sibling pointer. And then later on you're going to have to add one more pointer of your choice. And that one more pointer of your choice is going to be either you're going to add either a parent or you're going to add a previous. I'll talk about that a little bit more later on. So every node is linked together to other monodes. And the rule is the thing that makes this a heap is a node never has a higher priority than its parent. Now when you look at the papers about the pairing heap and pairing pq, one of them will talk about having like a vector or a deck of child pointers. You cannot do that. If you do that you're going to go way over on time. So what a pairing heap looks like is we've got a root pointer. That root pointer points to a node. And that node there's a special rule for this one. This one is the root node. The root node is not allowed to have a sibling. It's not allowed to have a parent or a previous. It may or may not have a child. Now the root might not even exist. You know root could be null pointer or the root node might not exist. So if root is null pointer then my pairing pq is size 0 and there's no nodes at all. If the size of the pairing pq is 1 then I would have a node here. It would have no sibling and no parent previous and it would also have no child. And when I say no I mean they would all be null pointers. And the pairing pq is you're going to have to add your member variables yourself. You're going to have to add something like a root and you're going to have to add something which is the number of nodes. Don't call it size because there's going to be a member function called dot size that's going to return this value. So if they both are named size the compiler gets a little confused. So you can't call them both size. So you name yours whatever you want. It can be count, num nodes, whatever you want to make it. Of critical importance. As soon as you add these member variables go modify all the constructors. Default constructor, range based constructor, copy constructor, must initialize these two variables. If you've got a constructor that doesn't initialize one of these it's not a constructor. I've seen people in previous semesters where they'll have they've got one constructor that initializes one of them, one constructor that initializes the other and a third constructor that initializes neither of them and they have zero valid constructors. So as soon as you add these member variables go modify all three constructors. Default constructor, range constructor, copy constructor, make sure they initialize all these member variables to null pointer and zero. Okay, so then if we had if the number of nodes was greater than one then this root node would point to a child and that child might have other siblings. So I might have a node here like 81 has children 18 and 42 and 25 and 42 has a child 37 and you say whoa wait a minute 37 is bigger than its parent 25 no it's not 25 is not its parent. Whether I have a parent pointer or previous pointer doesn't matter logically 37's parent is 42. 37 cannot be a higher priority than 42 and assuming I've drawn a max heap here it's valid. Now who is 42's parent logically 42's parent is 81 everybody at this level their parent is 81. Everybody at this level down here might have a different parent so 10's parent is 18 37's parent is 42 etc. So whether you've got a parent pointer or a previous pointer doesn't matter logically everybody has a parent. Now what is the if we had parent pointers so let's just draw them and then it's going to get busy here but we'll redraw this later on. So if we had parent pointers let's put parent pointers in black. So if I have parent pointers what would happen is we would have pointers like this. That was a wiggly one that pan bumped the edge of the tablet. Okay so that's what parent pointers would look like. If I had previous pointers this green isn't the most legible thing that it'll do. If I had previous pointers 27 or sorry 25 would say my previous is 42 42 would say my previous is 18 and 18 would say my previous goes up a level to 81 and then 37 would say 42 is my previous 10 would say 18 is my previous. The only reason we need parent or previous is when we get to update out. So until we get to update out we don't really need parent or previous but once you add that parent or previous to the node you've got to add it to the node constructor to make sure it gets initialized and then you're going to have to go back to any other function that you wrote that deals with parent or previous and make sure to fix them. And I would say the two big ones to look for there are mel definitely and anybody that calls meld. So meld and anybody that calls meld is a you're going to have to check them for their proper use of parent or previous but the only difference in the code see in other functions you'll just have to make sure they point to the right thing. The biggest difference in the code will be in update out is how you'll use them will be very different in there. Everybody else is be just a matter of keeping them consistent. Okay, let's see. Another don't for this product for this part of the project for the pairing pq do not use recursion. If you feel yourself getting an urge to use recursion there's a better way to do it and we'll talk about that in a few minutes. How did we get this pairing heap that's drawn here and has all these arrows and stuff on it. How did we get to that point? We got to that point by calling push. Push is a really simple function. It's going to call add node, add node is going to do the work and add node is going to depend on another function named meld. So meld is going to be given two things. So it's going to be given two node pointers, pointer a pointer b and it's going to return a node pointer. So we're going to give it two node pointers. It's going to return a node pointer and what it's going to do, what mel does is it says hey, I'm going to put these two pairing heaps together and make them what. If it's going to do that, these two nodes have to follow some rule before we ever call meld because these are effectively the roots of two individual pairing heaps. They have to have no parent. Now why is it when I've got the thing for my, oh there we go. I've got to have no parent or previous and I've got to have no sibling. So we've got to make sure everything that we give to meld, those two nodes that we give it must have no parent or previous, they must have no sibling. So let's do an example. And let's start from the beginning. All right. So I've got a root pointer that's a null pointer and I've got a number of nodes. Let's just say n n n is zero, number of nodes is zero. So someone says push this thing, push calls ad node and ad node has to start doing work. What does ad node have to do? Oh, it's got to do node creation, right? So if someone said thing dot push of let's say 18, what we've got to do is we've got to create a node that has 18 in it. We've got to create a new node using new, we just can't just declare a node and link it together. We've got to do a new operation. We've got to create that 18 and when we are done with ad node, what's got to happen is this has got to go to one and this has to point here. Now I don't really need nel just yet. When the number of nodes is zero or when root is a null pointer, the two are equivalent, I can just set root equal to new node and return whatever I have to return none done. But then later on somebody says thing dot push 81. They say, oh, right, now I got to do work. So when they do that push of 81, what we're going to do is we're going to create a new node holding 81 and we're going to call melt. We're going to call meld with what? We're going to call it with root and our result of our our temporary node. Let's call it new node. We're going to call it with root and new node where this is. Here that's new node. And now I realize the difference by why nn for number of nodes is bad idea. Okay. Anyway. So I call it with root and new node and meld has to do some work. Meld has to figure out which one of these two should be the root. How does meld know? It calls this compare. So meld is going to call this compare with those two node pointers. Wait a minute. This compare can't know anything about node pointers. I've got to call this compare. I've got to do something with like if this compare. Arrow compare. I can't give it like a pointer to a and pointer to be. Those are pointers. I would give it pointer to a. The element stored in the node and pointer be the element stored in that note. So it's going to tell me true or false. Remember it's answering the question is the priority of the first one. So is the priority of the first one. Less than the priority of the second one. That's what this compare tells us. And if it says true what that means is the second one should be the root. And if this compare returns false that would mean that the first one should be the root. And what we've got to do is we've got to make the pointer right. So right now I've got like let's see. So if I call it with root and new node, okay, so that mean that PA. So PA right now points to a node containing 18. PB points to a node containing 81. And then what I've got to make happen is I've got to make it so that hey 81 says this is my child. 18 has to say this thing is my parent or previous, whichever it is. And then I've got to return something. I want to return a pointer to the bigger one. So I would return in this case, I return a pointer to PB. And then add node can do what it needs to do. Now I had no one could say, hey look now that now that 18 is a child of 81. And now I can say, hey, root isn't there anymore. Root is whatever meld returned. And oh look, I can up that to. So meld is going to do the work of putting together. Meld is going to return a pointer to the bigger one. And then add node is going to take care of changing the root. We don't want meld to change the root. I see people all the time. They want to make meld have a void return and modify the root all the time. And that's a little inefficient because we don't always modify the root. Sometimes we put things together and we put it somewhere else. And we don't change the root for a while. So we don't want to have meld change the root pointer. We just want to have it link the sibling and parent previous and child and stuff like that together. Now you're going to say, well what if that root node had a child? Okay, let's draw what we got. So root, root points to 81, which has a child 18. And I'm not going to worry about parent or previous anymore because I'm not going to draw both. And you're going to have to figure out some code to keep it straight. So that's what I got right now. And my, let's just call it count. That's going to be easier. Count is two. And someone says dot push 42. Okay, we got to do some work. And so dot push push calls add node, add node does all the work. Why is there these two levels? We'll talk about add node in a bit. Okay, so we call, so something called dot push 42. So we create this new node. New node contains 42. And now we've got to call melt. Now remember one of the rules about melt. Let's scroll back a little bit. Well, back a little bit, scroll back a little bit. What was our rule? No parent or previous, no sibling. Have we met those requirements? Okay, we call it with the root and new node. Root is a valid root. If we written the code correctly, root has no sibling, no parent previous. This new node has no sibling, no parent or previous. It's valid to melt. Now, we got to get, we got to figure out. Who's supposed to be on top? 81 or 42. Okay, that's easy. 81 should still be the root. But we're not going to change the root. We're just going to rearrange things. Now, we got to get 42 in the right place. Where do I want to put 42? Do I want to put 42 to the right of 18 or the left of 18? Here's a hint. What if there were a bunch of other siblings here? I don't want to have to go thing, child sibling, sibling, sibling, sibling, sibling, sibling, sibling, sibling to go put it at the right. It's easy to put it at the left, so we don't want to do that. So we don't want to put it at the right hand end. We want to put it at the left hand end. So what has to happen is, oh, hey, 42, you didn't have a sibling. Now you do 42, meet your new sibling, 18. 81, meet your new child, 42. And so now it looks like this. Just redraw it over here without moving that off. So now root, points to 81, which points to its child, 42, which points to its sibling, 18. And there we go. And you'd have to fix the parent previous, et cetera. So if it was parent pointers, 18's parent wouldn't have to change. It's still 81. But if it was previous pointers, 18 would have to say, hey, my previous is now the person that's calling me their sibling. Now one thing you're going to want to do at the beginning is you're going to feel like, hey, I've got to make sure when I call meld, meld's going to have to do a check. Before I call this compare, I got to make sure I didn't get any null pointers. And that's good. That's good for testing and getting it working. Eventually, efficiency wise, when you're done, you want meld to have no checks for null pointers. When you're done, what you want to make sure is that people call meld never give it null pointers. And then meld won't have to do those checks. Well, well, if someone's calling me, there's two real nodes here. Neither one of them is a null pointer. And that if we make meld a little bit faster, we make the whole parent people a little bit faster. So look at who could call meld with a null pointer and make sure that they deal with null pointers themselves. Okay, let's see. Oh, add node. I said we got to come back to add node. What does add node return? Look at what it returns. Why does it return something? Why is there push that returns nothing and add node that returns something is because we're making a real pairing here. If we wanted to make one that was just compatible with our sorted peer pq and binary pq, we wouldn't need add node. We wouldn't update out. But we're making a full pairing pq just in case we want everything we're going to have it. So push doesn't have a return type. Push is void. Add node returns a pointer to a node. Read the description for add node. Make sure you return the right thing. But the reason that add node exists is so that update out can be told things like hey, I called add node. I got a pointer to a node and later on, I want to change this value. I want to change this 18 to a 90 set. And I've got a way to do that. I say pairing p. Here's the thing that add node gave me before and here's new value. Make it happen. And so it'll take care of making that one node a different value. And there's a rule about it. You're not allowed to call update out with a lower priority than it already has. You're allowed to move the priority up. You could leave it the same, but it's kind of silly. But you aren't allowed to lower the priority. So we'll get back to how update out works in a little bit. So we got push calls add node. Add node is going to be calling meld. About pop. OK, we're going to have to draw a little bit bigger pairing heap to get pop. Or to get a good look at how pop is supposed to work. OK, so I've got a new pairing heap. It's going to be similar to the old one. OK, so I've got a root. And I'm not going to care about the count anymore. I'll assume you can take care of that. All right, so root's got like an 81. 81 has children. 18. Whoops, two, sure. 42. 25. 37. The values here can go up. They can go down. I don't know how you got this way. They just are. OK, that's good for now. All right, so now someone says pop. Now, one other thing. These nodes could have children also. 18 could have a child 10, which could have siblings. And it could have children. 42 could have like a 39 here and 39 has children and siblings, et cetera. So all of these nodes could have children below it. But because of the pairing heap property, I know after I get rid of the root, my new root is going to have to come from this level. It has to be at that level, because everyone at the level below it has no higher priority than anyone here. So like there's a 42 here. There can't be anyone on the level below with a priority higher than 42, because 42 is the highest priority here. So when we're done, we want 42 to be the root. But how we get there is really important. OK, so let's remember I've got a pointer p, p, points over here where the root child was. OK, now I can get rid of that. I can delete that node. Remember, I add node did a new node. Now I can do a delete to get rid of it. All right, so now I've got p. Now, what if p was a null pointer? What if there was nothing down there? Then it would be pretty easy. I set root equals a null pointer. I'd decrement the count. I'm done. But let's do the hard case. The hard case is there's a bunch of, and also if there was one thing there'd be pretty easy. But if there's a bunch of things there, it gets harder. So let's do the hard case here. So what we want to do is I want to put all of those node pointers into a container. Let's make it a deck. And you're going to see why in a little bit. So in my deck, I'm going to put a pointer to 18. I'm going to put a pointer to 2, a pointer to 42, a pointer to 25, and a pointer to 37. So those go all going to my deck. Now I have to determine the new root, and I have to pair. Here's the critical part about the pairing heap. And this is what makes it a pairing heap. It's, we can't just take, let's say, hey, let's take two of those meld together, take the result of that, meld it with another one, meld it with another one, meld it with another one. We cannot do that. That would be a one pass pop, and that gives us horrifying inefficiency. And in the other video, I mentioned, I saw someone in office hours that day who had, they did a one pass pop, and their test of pushing and popping stuff was over 100 times too slow. So we cannot do that. We can't just, I call that growing a snowball, right? We take two things, and we roll it bigger with three, roll it bigger with four, roll it bigger with five. We roll it into a big snowball, but that's not a good pairing heap. What'll happen is, if we did that, it would look, our pairing heap would end up either looking like this, where it's a big stick, or it would look like this, where it's one flat level. And either way, it would get really inefficient later on. So we don't want that to happen. So here's where we have to do the two pass or the multi pass. So I'm going to draw both of them. I find the multi pass is easier to code. And the efficiency is not the issue here. I wrote four versions of pairing heap. I wrote it with a choice of parent or previous pointer, multi pass versus two pass. I wrote all four combinations of those two choices, and I base the timings on the slowest up them. And from like the slowest to second slowest, not too big, and then there's a gap, and then there's the other two. But if it doesn't matter as long as you pick them and do them correctly for what you pick, you'll be fine on types. So let's look at how two pass works first. So what two pass does is it says, hey, let's take two of these and meld them and put them in a new container. Then let's meld another two. Let's put them in that container. And then I ended up with one. And this is the pairing part. See, here's where I make pairs. Okay, so two pass we would put, we would go basically two pass goes left to right, putting them in, and then it goes right to left, taking them out. It says, okay, now take two things, meld it, take one more thing, meld it, until we get down to size one. So we go basically from left to right, then we go from right to left. That's how two pass works. Now multi pass, I'm just gonna erase a bunch here. I'll just undo a bunch of times, then we'll draw multi pass. Oops, I wrote the word pairs, that took a lot of me erase. Okay, now let's draw how multi pass works. So what multi pass does, and this is where the deck comes out really handy, is I'm gonna take two things out. I'm gonna meld them, and I'm gonna push it at the back. I'm gonna take from the front, and I'm gonna push to the back. So I'm gonna take two things off, I'm gonna meld them, and I'm gonna put it at the back. Then I'm gonna take two things. Oh, these two things ends up being 37, and the result of this meld, I take those off, I meld it, I put it at the back. I take two things off, I meld it, I put it at the back. Oh look, there's only one thing in there. Once that deck is down to a size of one, that's my root. You could call it, when I'm all done melding, we could call this deck sub zero, you could call it deck dot front, you could call it deck dot back. They're all the same, it's size one. It's guaranteed to end up assuming, we didn't have a case where like the root node was the only thing. So if there was anyone below the level of the root, we are guaranteed to end up with a size of one here. Can't be zero, if there was one or more to begin with, we'll get down to a size of one. Now, there's one other thing about this that I skipped over, really super important, whether you're doing two pass or multi pass, is this melding. Wait a minute, we've got a rule. Rule says you're only allowed to meld things that have no siblings, no parent or previous. So before the meld happens, we've got to break those relationships. Now, if you try to break the relationships as you put them into the deck, it gets a little painful because like I'm trying to say 18, you don't have a sibling, but I've got to remember the pointer too. And that gets a little bit problematic. I find it's easier just to put them all in there, put them all in the deck, then as we take them out, we don't just meld. This meld, really, I have to break the connections. I take two out. I say 18, you've got no sibling, 18, you've got no parent or previous. I took two out, two, you've got no sibling, two, you've got no parent or previous. Now they're safe for melding. If they have children, leave them alone. Leave them alone. Children go with them because everyone below them is a valid parent heat. So 18's children go with it, 18 gets meld with two, 18 comes out being on top, two goes below 18, two would say 10 is my sibling. And meld will take care of all that as long as we make sure that before we meld, we've got a break, we've got to break the sibling and the parent or previous. So we've got to break those and do the meld, take two out, break them, do the meld. Leave the child pointers alone though. So that's pop. All right, now let's talk about things that are gonna be similar. Now, remember I said that everybody was gonna have a default constructor, copy constructor, or sorry, default constructor, range-based constructor, and then pairing heap is gonna have to have a copy constructor or a query equals destructor, all that stuff. So let's talk about this. So in the range-based constructor, for sort of binary range-based constructor was easy. You just said throw it into the underline data vector, call update priorities I'm done. In pairing pq, you cannot do that. First of all, there's no underlying data vector. And second of all, you don't wanna call update priorities because, probably because they haven't written it yet. So when you do the range-based constructor, it's actually gonna be really easy for the pairing pq. Range-based constructor is basically gonna say, hey, you gave me a bunch of stuff. Let's loop over everything in here and I'll just call my push function, put it in there. You might see people who want to write sorted pq range and binary pq range that way, just saying, hey, let's loop over that thing and call push. It's gonna be inefficient. Sorted to be somewhat inefficient, binary would be hugely inefficient. Remember, binary range-based constructor has to be O of N, that's what heapify is. But if you loop, if binary loops and pushes, the loop goes M times and each pushes up to log N, that's N log N here, you're over the required efficiency. But in pairing pq, you have to, obviously initialize your root pointer and your number of nodes to zero, then you've got to loop over everything in that range, pushing a copy of that value into yourself by calling the push member function, the one that we just wrote a little while ago. Okay, so that takes care of range-based constructor. Now, copy constructor and destructor and one of the thing called update priorities that we haven't talked about with pairing heap yet are all gonna use the same basic idea. So whether we're talking about the copy constructor, destructor, or update priorities. All of these are gonna use what I'm gonna call the, project one approach. What's the project one approach? I make a container, let's say I make a deck. So I make a deck, I add the starting location to the deck, and then while not dq.empty, I add the next one. What do I gotta do? I gotta get the next one. So I get the next one from the deck, and here, simpler than project one, I don't have to worry about stack motor queue mode. Just get one out. Get one out, this is a, this is a, like, a front on a pop front or a back on a pop back, whatever. So I gotta do a look at it and pop it. I'm gonna add things nearby to the deck. What am I gonna add? What is nearby this node? The child, and simply. And then I gotta do something. I gotta do something with the current one. And that do something is gonna depend on whether you're writing the copy constructor, the destructor, or the update priorities. If you're writing the destructor, what do you do with the current one? You delete it. If you're doing the copy constructor, what do you do with it? Well, wait a minute, what am I copy constructing? I'm trying to do it. What am I copy constructing? I'm trying to make a new pairing heap. So let's look at a copy constructor. So copy constructor starts out. I've got a root that's a null pointer and I've got a count that's zero. And I've got some other, some other pairing heap got passed in and that other pairing heap has a root that points somewhere and it's got a count, let's say 23. It's a pairing heap with 23 nodes in it. What do I gotta do? I've got to do a deep copy. So when I look in, so where is my starting point? My starting point isn't my root. My starting point is the other pairing heap's root. So I put that other pairing heap's root in. I loop, I take the pointer to, let's say 112, point at 112 comes off. I push its child, which points to like 99. I don't push it sibling because it's a null pointer. And then what do I do with this 112? I say, hey, I need 112, let's call push. With 112, with 112 in me, count goes up to one. I get a new node, points to a node containing 112. Keep looping. I loop through the other heap and I push stuff into me. So we took care of destructor, we took care of copy constructor. What's update priorities? We're gonna come back to update priorities, but it's gonna do the same approach here. Walk through, do something, add the child and the sibling and do something with the current one. We're never gonna push the parent or previous. If we push parent or previous, that would get us an infinite loop. I take something out and it's parent, get that one out and it's child, take that out, add that out and it's child. So that's how we make sure we don't walk through any node more than once. I only look at child and sibling, I never go backwards up the parent heap. Okay, so we'll come back to update priorities. What we wanna talk about now is operator equals. Because hey, we just wrote the copy constructor and the destructor, now let's write operator equals. I'm not gonna write operator equals much. It's gonna be pretty small. What you wanna do is you wanna look in lecture six and you wanna search for best copying. And what we're really looking for is called the copy swap method and although this appears in the slides, the PDF refuses to find it. I don't know why, if you search for dash swap, it finds it. If you search for copy dash swap, it doesn't find it, but you can see it on the slide. So there's some funky invisible character in there that even the PDF messes up. So if you just look at lecture six and search for the best copying, you'll find the copy swap method. You do not want to write the operator equals because it's a waste of time. We just wanna do the copy swap method. Get through to the idiot check. All of our operator equals from now on will all look the same. They'll look like the ones in those slides. Okay, we gotta talk about update priorities and update out. Let's see which one's easier. They're both hard. I would say update priorities is a little harder, but it's related to what we're already doing. So let's talk about update priorities first. Okay, so what's happened in update priorities is I've got a pointer to a root and I've got some count. I don't care about the count anymore. Okay, what's happened is somebody messed with a bunch of values inside of my parent heap. How did they do that? Oh, they didn't put values in my parent heap. They put pointers to values and they remembered the pointers to the values and they went and changed the values. So what update priorities the idea of it is is that my underlying data has changed and I don't know how, but someone's telling me it's very likely that you are not a valid parent heap anymore. And from this drawing, we can see this isn't a min heap because 10 is below 27. It's not a max heap because 118 is below 81. It's just not a valid heap anymore and we need to fix it. So the basic approach here is like the copy constructor and destructor. We pick a starting point. We add it to the deck. Well, the deck is not empty. We take something out, add the sibling a child if they're not null pointers and do something with the current one. And what we're gonna have to do is we're gonna have to tear this thing apart, one node at a time and rebuild it. Now, let's say I've got a deck. Okay, so I've got a deck. It's got point to 81 in there. And now, what is my root? My root is a null pointer. My count, one, two, three, four, five, six. My count is six. That hasn't changed. Now, here's one thing you cannot do. You cannot delete nodes and push new ones. You cannot reset the count to zero and delete nodes and push new ones. Because if you do, you're breaking the promise that AdNode made. AdNode made a promise when something was created and it said, I gave you a pointer and I promise you. If you don't pop this value or destroy the entire pairing, your value is always gonna live here. So update priorities and update else are not allowed to delete nodes. The only people that can delete nodes is pop and destructor. Okay, so that's our rule. Now, what we've got to do here is we've got two fixed things. So what I'm gonna do is I'm gonna take this 81. Okay, that becomes my current. My current is pointer to 81. My deck is empty. I add things nearby, pointer to 118. And oh, look, this one doesn't have Cipley. Then what do I do with 81? I say 81. You have no sibling. You have no child. You have no parent or previous. Now you can be melded with the root. So now root doesn't point there. Root points to, and I'm just gonna redraw it. I'm not gonna create a new node. I just don't want to point or there. So now root points to the node containing 81. Then I take that 118. Okay, so my deck's not empty. I keep looping. So I take pointer to 118. Becomes my current one. Take it out of the deck. And I add things nearby. I add a pointer to 200. I add a pointer to 27. And then I say, okay, 118. You've got no sibling. You've got no child. You've got no parent or previous. 118, you can be melded with the root. And then I end up with root points to 118. Which points to its child 81. And then we just keep doing this. We take someone out of the deck, add things nearby, break all their relationships, re-mel them with the root. And because some of the values will go up and some will go down, the tree, the pairing heap one, will not be a stick. If we somehow came upon all those values from like small, we could have a small, somehow came upon all those values from like smallest to largest or largest smallest. We'd get a stick. We'd get something that looks like this or something that looks like that. But as long as the values go up and down, it'll start producing levels below them as we meld more things with it. Okay, last thing, update out. Now after update priorities, update out isn't going to seem too bad. So what happens in update out is I've got a root pointer and it points to like 81, which points to 18, which points to 25, et cetera. Okay, and somebody gave update out. It gives, let me just erase that parenthesis up there. Update out, it gives given two things. A pointer, whoops, I'm using. A node pointer and a value. So what it's saying is I've got a pointer to a node like hey, maybe I point to this node and I'm saying make that value 120. Yeah, we've got to make that happen. What we want to do is we've always got to put the value in there. I've seen people that have like this really complicated update out. And it's like, if this then change the value, else if that change the value, else if this other thing change the value, else if this other thing change the value and do a bunch of code, else if this other thing change the value and do a bunch of code, let's just change the value. Okay, I've got to change that 25 to 120. Now I've got to make it a valid pairing. I'm not going to call update priorities way too long because we know there's only, there's at most one node that's bad. At most what I've got to do is tear this out and whoops, whoops, whoops, let me just redo that. I've got to tear this node and it's subtree out and re-mailed it with the root. That's the most I have to possibly do. And when I say tear this out, I've got to make sure that things are valid. Like 18 would now say, my sibling is now 37. If 37 has a parent pointer, it doesn't need to change. But if 37 had a previous pointer, let's go to green for that. If 37 had a previous pointer, 37 would have to say, oh, I've got a new previous. The node containing 120 would say, hey, I don't have a sibling. I don't have a parent or previous, let's meld with the root. And here's where your choice of previous come or parent comes into importance. Depending on whether you choose previous or parent, you will write, update, out differently. And you will have to write it efficiently for your choice. However, either way, you might find yourself wondering, where am I? This node pointer, this node pointer, where is it? Is it the leftmost within its level, or is it not the leftmost within its level? Either way, you're gonna wander this. So if we wanna know, am I the leftmost in my level, what I can take advantage of is the fact that if I were to go and follow my pointer here, whether it's previous, or parent, doesn't matter. I follow that one and I look at that one's child. If following that gets back to me, I'm the leftmost. So if I went from 18's parent to 81's child, I'm back to where I started. I'm the leftmost. If it was previous, if I went previous as 81, look at its child as 18, oh look, that's me, I'm the leftmost. But if I was at, let's say 37, or let's say this old 25, if I was at the old 25, I'd go up a level to 81, down to 18, that's not me, I'm not leftmost. Or if it was previous, I'd go 25's previous as 18, 18 doesn't have a child, well that's not equal to me, I'm not the leftmost. So you configure that out when you need to. So that's everything I've got for the part B and way longer than I intended this to be, but hopefully this will save tons and tons of time in off-soulers.