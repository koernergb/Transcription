 Hello, everyone. I want to go ahead and just make this quick video going over P2L. Office hours, I recorded them, but the recording got corrupted. So sorry about that. This should hopefully be a bit more useful because it's like, you know, a bit more organized. So yeah, we're supposed to go into basically how you can approach this problem. We're even asking in the first place and just some coding techniques you can use to solve it. So the purpose of the linker is we're going to be given a certain number of files in the command line. And our job is to go ahead and combine those files into just one complete file. The files given to you are going to be in the format like this. So it's basically going to be some assembly code assembled with your P2A assembler. So here we have the header, our entire text section, our data section, simple table, and the location table. So for this, we're going to go through and figure out how we can link these two files together and what that process looks like. So the main thing that's happening here is we're going to go ahead and identify that we have two files. We have file ones. I'll call that f sub one and we have file to f sub two. Our final file should look like this. We're going to have the text from file ones. I'll call that T sub one right below that. I'll have the text from file to call that T sub two. And then we'll have the data from file one like this is D sub one. And then we'll have the data from file to we'll call that D sub two. Notice here that's all we have. We don't have a header or simple table. We basically want our output to look like our output from the P1A assembler. The only difference here is we have to go ahead and work with multiple files here and resolve differences. So when I say resolve differences, what does that mean? So going back to the example over here, we can see that we have this item in the location table right here sub adder undefined zero. Was that tell us this tells us basically what global levels are going to be defined within this file. So right here we reference sub adder, but it's not being used. So we really don't care about that. What we care about though are these two entries inside the real occasion table. The real occasion table basically tells us what entries we have to adjust the offset for or maybe do it to adjust what the fill is. So in the case of this, we can see that we have zero lowered five, which basically means that online zero of this file. We have a dependency on the label five and that's for the load word instruction. So our job is to basically go through and resolve those differences. Right here we can see we have two entries right here we have neg one that basically means that online zero of this file. There's going to be some op code load word that has a dependency on neg one. And right here we can see that we have a fill statement, which dependent upon sub one existing. So the interesting thing here is to understand there's two big differences happening here. The first one happening is if we resolve a local label versus resolving a global label. So the process looks something like this. So first I'm going to go ahead and delete these header sections because they're kind of just below right now. You will want to use these to go ahead and do calculations for the offset, but I'm going to delete them for now. So our first line right here, we have this machine code. The first thing I recommend doing is going ahead and determining. Okay, is there a dependency on line zero for this op code. So right here we can see that we have zero load word five. So that means our first dependency is going to be on load word at line five. Before we do this though, I just wanted to go ahead and highlight what our actual like assembly code looks like. So I know we give it to you guys in machine code that's the objectives here, but we can actually look at it like this. So this is our main file right here and this is sub one of this is all before the assembly process. Our final product is going to look something like this or first I'm going to go ahead and again going back to this right here. So we have text one text to data one data to sort of end files going to look like this. Go ahead and take text one will go ahead then and take text to. Take data one. And then we take that to sort of final files going to look something like this. The big thing to understand here is let me go ahead and send these over. So what's happening here is for example, load word zero one five originally in this filing compiled it or assembled it. We said that five had an offset of zero one two three four an offset of six. So we're going to go ahead and resolve this six. So we already did this in P two way. The big difference here is what line is five out of find that it's now defined at line nine. Actually, this is line nine. So we have sex right here, but we need to update that. So whenever we go to this line in our machine code for the first file, we want to figure out is there going to be a dependency inside of this line right here. And there is because we see zero load word five. What that means is that online zero and it's load words that implies it's in text so online zero text. There's a dependency on the label five. And this is line zero in text. So we have to go ahead and adjust this. Now notice here how this is five as a local label. What that means is that five has to be defined within the data section of this file right here. We can see it's right here, but we need to figure out what line is actually out within a data section. The trick to solving this is noticing whenever we put these two files together like this. We can see that again going back to this graphic right here. If text one text to data one data to so I'm going to go ahead and go back to this. And the question I have for you all is what is the only thing separating this call to five right here from its definition right here. Originally said the offset was six, which is basically the distance to go from all of this to right here. So notice here the only thing we're actually adding in between these files is going to be text to. So the length of text to is three in this case. And if we go back to assembly code right here, we can see that the only thing again that we added is this load word add and JLR statement. So we go ahead we take the size of text to and we add this to our original offset. So in this case we said this was six we do six plus three and then we get nine. So going back to this example right here, what we do actually is we go ahead and take this line right here. Calculate its new offset, which we said was going to be three more because again going back to this graph right here. We have text one text to data one and text to is the only thing separating this local label from its data section. So we'd go ahead and add text to size and so text to size is three we get up in the header. We go ahead and add three to this and we get that. Cool. Next line right here we're going to go ahead and do the exact same process. So we look at a relocation table. We see that online one. We have load words instruction that has a dependency sends load words and data and we're looking at line one of text. Then we know there's a dependency that exists here. This is a dependency though on a global address. So what to do here is first of all figure out where is sub adder to find that. So we'd go ahead and look through every single files symbol table. So this one here sub adder exists its reference but it's not defined because we have a U right here. So we go ahead and look at file to symbol table. You can see right here that it's actually defined at data one. So based upon that we go back to this right here. We have a reference to the sub adder. Yes, a better cool sub adder right here. And remember if we have a global address that we're not is not defined in that file. We're actually putting an offset is zero in. So right here. For this right here our offset is actually zero right now. But going to the file we have now actually defined where sub adders defined at. It's defined right here. So it's new offset is going to be whatever line number. This is defined at and this is defined at line zero one two three. 11 cool. So we want to happen is we want to go ahead and change sub adder to be 11 instead of zero. The question is how do we go about doing that. So what we can do in this case is again we see there's a dependency that exists right here. We then go ahead and loop through all the simple table entries. We see that exists right here. And we see it's defined in data. So we're looking at file two right now we're looking at file two simple table. So what that means is that sub adder is located right inside this section right here. It's inside files to symbol table at data one. So that means it's right here. So to figure out what line number is that. So first starting at line number zero in text one. And we want to figure out where it's located at. If we go ahead and take the size of text one size of text to size of data one. And then we know what line it's at in data to because it says right here. It's that data one of file two. So based upon that what we can do is go ahead and take again size of text one size of text to size of data one plus that offset given to us in the simple table. And I'll give us a answer. So we have six plus three. I think the next one is just one. And we add one to it. So we got six nine 11. So we then go ahead and change the offset from zero to 11. So I'd go ahead and do this plus 11, which is going to be 63. Cool. And then for the next four we actually don't do anything because look at the assembly code again it's just going to be. Jlr be Q be Q halt again be Q don't need to be adjusted because they're PC relatives. So and also they're not inside the relocation tables, but you can just go ahead and directly copy over these four. No changes need to be made. After that we go ahead and work on text to so text to again. Again we have the text file stacked like this. So we have text one text to data one data to. So we just went ahead and resolve text one. Now we have to go through and resolve text to. We do the exact same process. Look at our location table. We see that the tendency exists online one of text because we're using a word instruction online zero. So this instruction right here is a dependency on neck one. We would do the exact same process of determining. Looking back at the diagram. We're currently looking for a word. So we're going to go ahead and assume that. That is. Reference right here. And then it's the fine inside data to. Again we know it's the fine inside data to because it's a local label. Otherwise it won't compile. So we know that neck one is inside of data to. And it's being referenced in text to. So this is the key mistake people make. They'll go ahead and assume that okay to calculate our new offset. We're going to go ahead and just add data one to it. So we can go ahead and just go ahead and just. We can go ahead and just go ahead and just. And then we can go ahead and just. It's an empty code. If we look at this right here, neck one. It's actually going to be defined online three. So if we just go ahead and we add the size of data one to it. We would say that it's online four. But that's not accurate. Neg ones actually defined at line. This is line 10. And we're saying right here that it's at line three. So it's happening here. What we didn't account for is the fact that text one exists on top of this. And that's taking up line space. So if we do want to go ahead and figure out where this is actually located at. We had to go ahead and also add in text one. Remember, if it's a local label, we're already accounting for the size of text to end data to because we already have. It's relative address resolves for that file. We had to go ahead and add in the stuff separating it. So text one and data one are both separating it. So we have three already there. We had six. And then we add data one, which is going to be one. We get 10. So then our new offset is going to be 10. So in reality, all I'm doing here is adding seven to it. So I would go ahead and take this and add seven to it. So I get 90. Cool. And then the next two we actually don't resolve anything for. Even though it fills in a real occasion table, we resolve that for the data because fills in the data section out of text section. So I just go ahead, copy these two over, put it right here. And then our text is done. That section. Again, we'd look through data one first, see if it dependency exists. No dependencies exist in data for file one. So I just go ahead, copy over the five, put that here. And then we can see that we have a dependency at line one of data. So I'd copy in this right here. And then we have a dependency on sub one, which is going to be a local label. So what this means essentially is that. So this is very similar again to just like the load word and store word for local labels. What we're doing here is again, we're figuring out where is sub one defined. It's going to be a local label. So it has to be defined either inside of the text or data section within file two. Right here, we can see it's a finite line zero. So from that, we can infer that it's actually defined within the text of file two. So what we can gather here is that. We erase these real quick. We have. There we go. Sub ones being referenced down here. It's in data. And it's local. And then it's being defined somewhere up here. And again, I know that because it's was located at line zero before we actually went ahead and. I don't know. I don't know if it's a. That's a. Or during the linking process, or during the assembling process sub one that fill sub one, which is all to be zero. So what that means again is that we know our text size is going to be three from the header file. So since zero is like less than three. That means that sub ones located inside text. So from that, we see if you're out. Where is sub one located now? So the question is like, what stuff was added above where sub ones defined and that case. It's just going to be text one. So our original offset plus six. Look at this answer. It's on this case. We have zero. It is zero plus six. We get six. And a couple of things on this because again, it can get the confusing. If we had sub one defined. Let's say. The one was defined inside data to. That will change our process because instead of us going ahead and. Having to add in just text one, we also have to add in data one. So you can see here that wherever your label is defined that depends on like what you add to it for the new offset. You have to calculate where it will be located in a new file and then account for that fact. So since sub one we originally said. Well, for the case of the spec sub one. Is to find side text to right here. And it's being referenced in data to. We see figure out what line of sub one located at. From. Our file. We know that it's located at line zero with respect to file two. So it's located right here. And it would be zero for file two. But the quats rush it. That was once we link it up. We add inside text one up here. So we had to go ahead and add in the six right here. So you do zero plus six. We get six. If it was sand line like three or four. Inside file two. That would imply it's inside the data section. So we then had to go ahead and. Account for the size of text one and the size of data one. So. All right. Hope this helps. If you have any questions, leave it in piazza. And yeah, good luck in the project.