 Okay, well, hello, everyone. I came back to campus at night so I can make a recording for you for Project 4. So I've got a whole list of things here I want to go through. So first of all, make sure that you've read through the projects back and the Project 4 tutorial. There's a lot of useful stuff in there. Hold on, I'm going to adjust my mic. It seems a little bit loud. Okay, so then when you start working on it, do the parts in order. A, B, C. So the first part A is MST. Part B is fast, TSP. Part C is optimal, TSP. So part A pretty straightforward with what we've done in lecture. You want to make sure that for every part you read in the coordinates, they're all going to be in the same format and just save the X and Y. And it would also turn out to be really helpful for part A to save for every coordinate or location, whatever you call them, the terrain type like water versus coast versus land. And then if you need info for a prem's table, keep that separately because part A needs it. Part B might not need it. For every part, watch the auto-grader for any hints. Just search when you get the feedback. Just search for the word hint in the feedback and there's some really useful information in there. And I'm going to go over some of them tonight that I know will happen to many people. And if you watch out for them, though, you'll know when it means you. For every part of this project, your output can be different than ours and still be right. If you did an MST, let's say I said, here's your graph. It's got four vertices and four edges. Make me an MST. So, assuming that I could draw a square and that all of these sides are of length one, you could choose to leave out any one of those edges. And it would still be an MST. You could list the three remaining edges in any one of six possible orders. So there's 24 correct outputs just for these four vertices. Auto-grader has a program called the judge that judges your output as right. So it checks to see, do you have the same total weight as we do? If you have the same total weight, do your edges that you list add up to the weight that you report. And does it make sense? So for part A, you can't ever connect vertices that are already somehow indirectly connected. And in parts B and C, you have to produce a tour. You have to use every vertex exactly once. So when you work on the part A, when you're working on Primm, make sure that Primm doesn't know anything about land or sea or coast. It'll make Primm really easy to write. What you have to do is calculate the distances in a way that makes sense. So if I had a graph like this and I've got points like, let's say A, B, and C. Primm has someone to help it calculate distance. It could be a function. It could be a functor. It calls its helper and says, hey, what's the distance between B and C? And the functor says, let's say two. Okay, what's the distance between A and B? Well, it can't calculate that distance because they can't be connected. But the distance helper has to return something as a double return infinity. In Primm, you don't even have to check to say if the distance returned infinity. Just check whatever you got from the distance. Is it better than what you already have? If not, it doesn't get used. And so this makes it really easy. Primm is going to be just like in the slides of the lecture, but it needs the distance function to worry about land versus sea. Don't try to separate them into three vectors. Just make one vector run through a straightforward Primm and check the, when you check the distance, report infinity for anything that cannot be connected. When you are checking is something coast or not. Don't make the test too simple. Lots of people goof up that test and make it too simple and report things as coasts that are not. When you do calculate Euclidean distance, make sure that you're careful about integer overflow. The X and Y coordinates you can read in as integers makes it simple, makes it small. But when you report the distance between the negative double, however, if I had two coordinates, let's say A and B, and this one has X equal to negative 25,000, and this one X is equal to 25,000. Well, if we calculate the difference in X, 25,000, minus negative 25,000, is equal to 50,000. What's 50,000 squared? That's equal to negative 1.5 billion because of integer overflow. So be careful when you calculate distance, don't overflow an integer. You're going to want to convert to a double before you go squaring it. For the project for tutorial, there's a part that gives a talking about, hey, if I gave you some points and made you calculate the Euclidean distance, let's say my, we were calculating like delta X squared. So I calculate delta X squared plus delta Y squared. And I told you that I had two sets of points. So for points A and B, that distance delta X squared plus delta Y squared was, let's say, 58. And for C and D, the distance, so the distance between C and D, if I told you that the squared distance was, say, 53, I ask you which set is closer together, you'd say C and D. But if I ask you what is the square root of 53, you don't know it exactly off the top of your head, but you know, if 53 is small and 58, the square root must be smaller. And this is a hint on part A, you can save some time by delaying the square root. When you're making decisions, you don't need the square root, you can just take the sum of the squares. This does not work in part C. If I said I've got the sum instead of just AB, let's say I had AB plus CD versus EF plus GH. Okay, and I've got for these, I've got 100 plus 1 versus 49 plus 49. This one looked better, 98. But if we took the square roots, we'd have 10 plus 1 versus 7 plus 7. This one is actually better. So in part A, you can delay the square root to save time, part C, you cannot delay the square root. When you're calculating a sum and comparing a sum to another sum, you've got to have exact values. In part B, when you're doing heuristics, can you do this? It depends on your heuristic. If you're only comparing one edge versus another edge, you can delay the square root. But if you're comparing sums, you need the actual numbers. So in, where I am on my list, okay, in part B, so we're down part B. So when you're working on part B, you want to look up TSP heuristics, stick to something that's O of N squared, or we could say O of V squared, because that's what the important den is, is the number of vertices. Stick to things that are O of V squared. You want to, you might have to implement more than one heuristic. They don't tend to be more than say 50 lines long. All of the heuristics are greedy in some way. They all differ in how they make their greedy decisions. If you look at the simplest, the simplest is called greedy nearest neighbor. Pick a point. I don't care where it is. Pick a point and we've got a bunch of other points around it. So if I picked this one as my starting point, I would say, well, the closest one is that one. Then you pick, so now I've, because I picked a first point and now I picked a second point, I have an edge. Then I say, well, pick the closest one to the most recent one and add an edge there. It looks like probably that one there. Then you say pick the closest one from there. Let's say it was, it doesn't look like, let's say I had one more point over here. I'd go to this one next. Then the closest one to there is over here. Then the closest one to there might be all the way up here. Well, then the closest one to there. It's got to be the closest one that we haven't used yet. The closest one to there is over here, over here, over here. But wait, then I've got to go the closest unvisited one is way up here. Then over to there. Then back to the starting point. Then there's a couple of places where the lines cross. This is obviously not the best we could do to visit all those points and get back to our start. So greeting nearest neighbor does an okay job, but it's going to be too long of a path in many cases. You can add in the Project Four tutorial slides something called two opt, which is an attempt to remove crossings that involve two points versus two other points. If you do greeting nearest neighbor versus two opt, you can get like 99% of the points for part B, which is certainly enough to move on and get part C done. Then you can go back and change part B. Or pick a different heuristic. So you know greeting nearest neighbor plus two opt is going to be either just a little bit sob optimal or very hard to get optimal. Pick another heuristic. Go out and look at. Let's see where I'm on my list. Okay. When you're working on part C, so we're down to part C. Part C is going to be covered in class lecture 22 material. One thing about part C is we gave you a starting function called GenProms, which we talked about earlier in the semester. Make sure you use the version from Project Four and lecture 22. Earlier in the semester, we showed two different version that used a vector and a deck and shuffled stuff between them. This one accomplishes the same thing, generating all permutations of the input, but it runs faster. It uses one container instead of two. And it does it a bit faster. So make sure you're using the most recent version from either lecture 22 slides or I put a text file on canvas that you can download with the code for GenProms. When you start working on part C, you'll notice that not everything you need is in the GenProms parameter list. For instance, you'll see the path. But at some point, you have to say, do I have a better path than the best one so far? If so, I need to remember it. Well, there's nowhere in there in the parameters for the best path so far, the best path length so far, the current path length or anything else. So don't add more and more parameters. There's no list of coordinates. So don't keep adding parameters to GenProms. If you do that, GenProms you'll see is not tail recursive because it's not tail recursive every time it calls itself. All the parameters have to be pushed on to a stack. The function is going to call itself on the order of V factorial times. So an extra five or six parameters pushed onto the stack, V factorial times is a lot of work. So what we would like to do is actually cut down the number of parameters. The way you do that is not make global variables. The right way to do it is make part C a class. And you can make basically everything but per length. You can leave per length as a parameter. Right now the parameters are path and per length. Instead of adding more parameters, let's make the current path of member variable to the class. You can make per length a member variable to but it doesn't help much because it's just a size t. It's easy to write if you leave it as a parameter. But make everything else member variables of the class. And this will be a member function of the class. So your coordinates will be a member variable, your current path, your best path you've ever seen, your current path distance, the best distance you've ever seen can all be member variables. If you look at the code, there's nowhere in there that has a current path length. Keeping the current path length as a running total is going to save time. Because if you keep getting promising is true. What will happen is I've got a starting vertex and I add another edge. I'm sorry, I have another vertex which adds an edge. Does that look promising? Well, there's not enough to be too long to be not promising. So let's add another one. If you don't keep a running total, what you'll do is you'll say, okay, let's add up my current path length. That's one edge. Is it promising? Yes. Okay, let's add another edge. Is it promising? Well, I don't know. Let's add up those two edges. See what the total is. Oh, that's still promising. So let's add a third edge. Is it promising? I don't know. Let's sum up those three edges. Instead, you should add one edge to the running total, add a second edge to the running total, the weight of that edge, add a third edge weight to the running total. And then if you find out that that one is not promising, whatever you add before the recursive call, after the recursive call is over, you take it away. So in the GENPROMS function, you'll see the recursive call. There's right before the recursive call. There is modify the path. Then you can calculate the weight of the new edge that just got effectively added right before the recursive call. And then after the recursive call, do them in the opposite order. Right after the recursive call is done. Subtract that edge weight. And then the line of code that swaps the variables back to where they belong. So that will save a lot of time if you don't keep recalculating the path length over and over. When you look at the ways for parts C to go wrong. So part C is going to use both parts A and B. So it'll use part A. So when you want to do an estimate of the remaining unvisited region, you one way to calculate the cost of connecting that is with a TSP. And that's where most people get part C wrong is they say, I've got a working part A. If I just give this data to part A, it'll get the right answer. And it doesn't all the time. So one way to go wrong is you reused part A directly and part A is still worrying about land versus C. In part C, up TSP and part B, you don't care about land versus water. You just want to know the straight line distance. So that's one way to go wrong. Another way to go wrong is to forget to like you maybe have your prims type table. Maybe you forget to go mark things as false and infinity and you leave the values that are already in there and you can't improve upon them. And so things don't look promising that are. So inevitably most people are going to have problems with either TLE in part C or getting wrong answers or getting both. And sometimes the same mistake can cause you to sometimes go over time, but still get the right answer and sometimes you get the wrong answer. And so the way to debug part C, first of all, make a smaller test. Second of all, look at the read me that came with the sample files. It's got some hints about different things to try in there like use this sample and compare it to the output of that sample. And another thing you can do is this is one where doing some debugging output can help you figure out what's going on. So one thing you can do is if we said that the correct path was, let's see, I wrote down an example here, 0, 5, 2, 1, 4, 3, and your output is incorrect. And your path length is too long and you know that. But let's say that your path that you output was 0, 5, 2, 0, 5, 4, for the reason. OK, so 0, 5, 4, and then 1, 3, 2, for example. Well, your program, your genperms ran through every permutation. At some point, it was 0, 5, 2, and you said it's not promising prune this branch away even though it happens to contain the best path length. So things to do is check set a break point. You can do things like add an if and say if path sub 0 is 0 and path sub 1 is 5 and path sub 2 is 2, I've got an if statement here just so I can set a break point on it and know that it'll stop here. Another thing you can do is produce some extra debugging output. So what you should produce in the debugging output, I made a list here. OK, so you want to output the current path length. You want to output the, let's see, so the current path length, what is your MST weight of the unvisited. What is the connecting edges. And by current length, I should have explained that by current length, I meant the real edges. If you look at the slides for lecture 22, the black one is the current length. The gray one is the MST and then the connecting edges are the blue ones, looks BLE. So print all of those out and see as it'll be kind of spammy with a lot of those values flying by, but look for it to go wrong. Like at some point, what if the MST weight says it's infinity? We know that's wrong. Look at what went wrong when that, when you had that case. Another thing you can do is after you print out all of these things and it'd be nice if you print all of these numbers on one line, it's easy to see. And then what you can do is when you find one that goes wrong or just add in some more code to print out things like for the unvisited. What I'm going to do is I'm going to print out how many vertices are in the unvisited, like let's say four. And then I'll print the x, y coordinates. Could you look them up? Yes, but bear with me. So I'm going to print out that there are four vertices unvisited and I'll print out the x, y, x, y, and x, y for those four coordinates. Now what I can do is I can take this and run part A on it. If you're careful, if these x, y coordinates, if the original data involved c versus land or water versus land, that's not going to work because part A should give a different result. But if you choose, and I forget now which one it is, I think it's part sample D, I think sample D, sample E, look at it'll tell you one of them has been moved up to all the coordinates are in the quadrant one. They're all the same type. So if I take this and cut it, paste it into a file and run part A on it, if my part A says like 125.43 and over here my debug output said like 157.21, something went wrong here. So then you've got something you can debug what went wrong with this one, why is that MST wait way too high. I know my part A works. What went wrong in the handoff from part C to part A. Another common mistake people make is you're going to have to be. Sorry about that. I didn't think of changing out of my sweatshirt before I came over here. It works better with a regular shirt. Anyway, where was I? Yes. One thing you'll find in part C is when you were doing part A, the vertices were always 0123456, etc. But in part C when you handed off to part A, you might be saying here give me the MST of vertices 751511 and 4. What many people make a mistake is they say I'll access vertex I and vertex J. But really you need like something like vertex sub path sub I. So path is the path variable and this is the index into the path variable. So the path variable had like 0, a bunch of stuff that is already in the path and then I would be like the index of the first unvisited vertex. That's another common way to go wrong is to forget to double index that. You'll find you'll say isn't all this handing off to the MST isn't that costing a lot of time. Yes, but remember it's n squared time. If we do the MST and the other stuff and promising says false, if I can do let's say there's K vertices unvisited. If there's K vertices unvisited, if I can spend on the order of K squared time and promising says false, then I've saved myself K factorial time. Now this is something important I forgot to add it to my list, but something really useful to think about is in promising. It's not always useful to run promising. Let's look at why. So if I had a let's say I've got different values of K, let's look at the cost of finishing the TSP. K is how many unvisited vertices there are. The cost of finishing the full TSP of this is K factorial. Well, what's the cost to do my estimate? Well, the estimate cost is K squared for the MST plus the two connecting edges is plus two K. Now, if you don't see why go look at the lecture 22 video, which I'm going to be doing tomorrow on Tuesday the 26th. So if I look at like let's say K range of one to let's say 10. When K is 10, finishing the TSP is around 3.6 million. The estimate cost me 120. And if the estimate says yes, it's still promising, you've got to keep going. I only added 120 work to 3.6 million, not a big cost increase. But if promising says false, I just did 120 units of work to save myself 3.6 million. That's a great savings. But what if K, the unvisited portion is really small? Well, as K gets smaller, if K is 1, we're talking 1 versus 3. Or if it's 2, 2 versus squared plus 4 is 8. If K is 3, this is 6 versus 15. Okay, 24 versus 24. Okay, we're at the break even point except I have to do 24 work to either do another 24 work or skip the 24 work. Still not really a savings. If we've got K is 5, I've got 120 here versus 35. That's starting to look better. How about 6, 720 versus 48? This is definitely a savings. That's definitely not. At some point, your promising function can say, hey, if the length of the unvisited portion is kind of small, small enough, just return true. If promising returns true, TSP picks up and says, oh, it's promising. I've got to go down this path. I've got to finish my TSP tour. If promising always says true, you will always get the right answer. It'll just be too slow. So we want to say true when it has the chance of saving us work. Oh, also, if you're having trouble getting wrong answers, also make use of the visualization tool that we provided. It runs only on AutoGrader 2. The link to it is not on the AutoGrader itself, although I thought about adding it to the FAC. I'll try to remember to do that tomorrow. But it is a link is in the spec. If you just search the spec for P4Viz is like the end of the link that we provided. We ran it only on AutoGrader 2 because AutoGrader 1 does the SQL server for both machines. So we added the P4Viz to AutoGrader 2. So in there, there's some menu choices where you can say, I want to select a file to give to you. I want to select an input file. I want to select an output file. You select a mode and hit visualize it and it will show you what the graph looks like. Either the MST should look kind of like a tree because it is a tree and part C should look like a cycle. Let me see if I can think of anything else that I checked and I list of anything else I've missed. That's everything I've got right now. So hopefully this will be helpful. Save you time, get you answered before you come to office hours and help us save you time in the project. I believe I scheduled this recording to last about another 16 minutes. So if you see this part, I'll edit it off later. Anyway, good luck everyone.