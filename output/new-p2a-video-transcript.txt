 Okay, hello everyone. I'm making a video for Project 2 Part A and it may look slightly odd with the chat window because I scheduled the video ahead of time as a live stream just so I could get the link ahead of time rather than waiting until I was done and uploaded before I had the link to put in the projects back. So I'm going to talk today about Project 2 Part A, the Galaxy simulation and this one is going to be predominantly about Part A. There's going to be a little bit at the beginning here about A and B and then I'll switch over to Part A entirely. Now, first thing is for the Part B there's going to be another video, there's a link, I'll try to remember to put the link in there, it's also in the projects back. And there are going to be two different parts that you submit, two different entries on the audit rate or two submit to. So there's going to be a Part A Galaxy simulation, there's going to be a Part B priority queue, each part allows you to submit per day. If you earn, sorry if you find enough bugs on Part A, you will earn an extra submit per day for Part A only. So if you submit a late extension using one of your late days for either Part it will extend both parts. So you don't have to use like two days to get one day, you use one day for one part, it doesn't matter which you enter it in, it'll give you an extension for the other part. Now, for the overall project, I would suggest, obviously at first, start learning and reading about it, don't try to finish one part before you understand the other part. So start reading about the Galaxy simulation, start working on like understanding it, reading input, making test files, submitting test files for Part A, but also start understanding Part B. In Part B, you're going to have the sorted PQ that you have to implement is going to be pretty easy and there's a whole other video for this, but there's going to be Part A is pretty easy, Part, or sorry, for Part B, one part of it is sorted, it's pretty easy. Another part is binary PQ, which is mostly translating the slides. And the third part is pairing heap, which you're going to have to read a paper and turn it into an implementation. So don't try to finish one part before you start the other part. Be willing to go back and forth, oh, I'm stuck on Part A while I'm going to go get some work done on Part B and vice versa. Because if you leave, like, say, 10 days where you're just working on Part A and don't even start Part B, that's 10 days of submits for Part B that you never submit it. So it doesn't mean you have to submit both parts every single day, but don't waste every day on it while you're working on just one part. Okay, another part that's important, that's another topic that's important for both parts here is Funk Doors. So because we're going to be dealing with priority cues in both parts, you're going to have to deal with Funk Doors. In Part A, you're going to be dealing with the external view. Like I wrote a Funk Door and the priority cue of the STL uses it. In Part B, you're going to be taking sort of the inside view. Like I am the priority cue and somebody gave me a Funk Door and I've got to make sure that when they ask who's on top that I show them the right highest priority element. But in both parts, it's important to understand what a Funk Door does. So a Funk Door for priority cues is always going to have two parameters. We could call them A, B, we could also call them left comma right. Names aren't important. What's important is the question that the Funk Door must answer. So the Funk Door always has to be able to answer the question, is the priority of A? Less than the priority of B. So a Funk Door always has to answer that. So like in Part A, you've got to have one priority for Seth on a different priority for Jedi. You will have two different Funk Doors and they will make their priorities calculation in a different way. They will break ties the same way. We'll talk about that in a bit. But how they determine priority will be opposite for the force values. Okay, so let's talk about Part A stuff specifically. Okay, so Part A, we've got to do the Galactic Simulation. One thing that's important about this one is there's a flag dash V or dash dash verbose. You want to implement this all the way through the project because it's going to help you debug. And it's just a matter of like if verbose mode is on, I have a C out and there's no else. So if you don't implement verbose mode and you get to the implement everything verbose mode and you get wrong values, you don't know why. But if you have those values, those verbose things printed, you would get an idea of where it went wrong and when things changed. So work on that as you go through. We'll talk a little bit more about the other three modes later. Okay, so now when we start doing the simulation, we've got to match the highest force Seth with the lowest force Jedi. So the highest force Seth, think of it this way, the Seth are kind of cowards. They only want to fight when not only when the odds are in their favor, but when the odds are overwhelming in their favor. So if you had for instance on a planet, there's a Seth with force sensitivity 10 and there's a Jedi with force sensitivity 20, the Seth will hide behind a rock and he won't even let the Jedi know he's there, he will not fight. So it's a matter of priorities if there's multiple Seth. So if let's say there was multiple Seth, there's a Seth with a force 10, there's a Seth with a force of 30 and there's a Seth with a force 100 there. If all three of them are there, the one with the highest force Seth would fight the Jedi. Oh wait, which Jedi? What did they say? There's two of them. There's another Jedi with a force sensitivity of 25. The highest priority Seth is the highest force sensitivity. The highest priority Jedi is the lowest force sensitivity. So Jedi are very brave, possibly foolhardy. So even though her force sensitivity is the lowest, she's the one who charges into battle first. She's the one who has to prove that she can take this Seth out. So we're going to have two different priority cues, right? If we throw them all into one priority cue, then we can only say this one's on top. Well who do they fight? I don't know, they're hidden in the priority cue down below that. So we got to have two priority cues, one for Seth, one for Jedi. They will have different funcdors. Should we make two different types of deployments of Seth deployment and a Jedi deployment? No. Make one type of deployment and two different types of funcdors. Now so we've got, we've got to have a separate priority cue, one for Seth, one for Jedi. So wait a minute, what if the highest force Seth and the lowest force Jedi are on different planets? Then they can't fight, but maybe, let's say this one is on planet one, this one's on planet zero, this one's on planet zero also. So hey, that force 30 Seth is willing to fight that force 20 Jedi, but that force 30 Seth is not at the top of the PQ. We need more priority cues. We don't need just us Seth priority cue and a Jedi priority cue. We need them on a per planet basis. So think about this, we got to organize our data, right? I think I should have besides like a deployment and a highest priority Seth, a higher priority Jedi funcdor. So there's three types so far, deployment type, Seth priority, Jedi priority, planet because I've got to keep track of all this stuff on a per planet basis. Well, right now a planet has two priority cues, but maybe when we implement some other stuff we'll discover that a planet needs more things with it. So if I were to make a planet object, put those two priority cues in it and then make a container of vector of planets, then later on if I discover, oh a planet needs more stuff added to it, I can add more member variables, I might add more member functions to the planet class. So we're going to have to keep two priority cues per planet just to make battles happen. Now when you read things in and you store it in that deployment structure, you want to make sure it's efficient though, because if I read in a string containing Seth, the string or Jedi, the string, do you want to store a string in my deployment object? No, that would be kind of a lot of space. I mean a string is like 32 bytes minimum. And I don't want to compare strings if I don't have to. I want to say, hey I read in Jedi, I've got a deployment that's holding a Jedi, oh let's put it in the Jedi priority cue. So once it's in that priority cue, if you're in the Jedi PQ, you must be a Jedi. You don't need a piece of data to say that. So if you're in the Jedi PQ, you must be a Jedi. If you're in the Seth PQ, you must be a Seth. So I have to read that in, but I don't necessarily have to store it with the deployment. What about the planet number? If I'm in the planet zero, Seth priority cue, I must not just be a Seth, I must be on planet zero. So there's going to be things you read in that may or may not have to go into a deployment. Okay, what if two deployments have the same force sensitivity? So let's say we're doing with some different planets. So I've got a Force 20 on planet five, and I've got a Jedi with Force 20 on planet five. They will fight. So if they have the same force sensitivity, the Seth is still feeling like they've got a decent shot at this. So it'll fight what happened. But what if there's another Force 20 on planet five? And also there's one thing I've shown you before this. There's also a quantity. There's a number of, so let's say there was a number sign, ten of these, number sign, two of these, number sign, five of those. So a fight will occur, in fact more than one fight will occur. The question is, and which one comes first? Let's assume, let's assume that the Jedi arrived first. The two Jedi arrived then, five more Jedi arrived, and then a Sith arrived. Well now a battle can happen. But the question is which one of those Jedi fights? The answer is whichever one came first. So everybody's equally polite in this way. So if there had been two Sith who arrived at first time, Sith are also polite. The first Sith with the same force sensitivity has a higher priority. So being there earlier helps. Now wait a minute, I've also been drawing this without timestamps. Oh my gosh. What if these were, it's in a different order, put it at the end here. What if this was timestamp three and timestamp three? Oh wait a minute. Now the timestamp doesn't help me make a decision to break a tie. It might need to be in there for other reasons, but it does not help me break a tie because the timestamps could be equal also. So who's fault is this? So think of it this way. I'm the funcdore. I'm inside of priority underscore, I'm in your code and I get used by priority underscore queue. Priority underscore queue calls me and says here's two things, these two right here. Here's two things, which one is the priority a less than the priority b? And I must say true or false. And I have to make a decision. Now if there's not enough data there, it's not my fault. I'm just the funcdore. It's not the priority queue fault because the priority queue fault just put stuff in that was in there. So if there's not enough information in there, that's your fault, the coder. You've got to add into a deployment enough information to make that decision. So if sufficient information isn't in there, you're going to have to add it. You're going to have to add something that can break a tie. Think about and let's call it an ID number. If everybody had a unique ID number, then we'd have something we could break ties on. Okay, so I think that's the basics of our galactic simulation. Like I said, get the verbose mode going as you work on it. Then there's a few other modes. So general info mode. Now general info modes, all the info on that's going to be in this video. Some of the other modes we got separate videos for. So in the general info is pretty easy. One thing about it is there's going to be general info. The number of generals might be different from the number of planets. And they don't have anything to do with each other. So like I could be general seven, I might issue troop deployments to planet zero, planet three, planet twelve. So you're going to need like a vector of planets, like we said earlier, and a vector of generals. Now when you read the command line, get first, when you start reading the file, and it'll tell you how many planets there are, how many generals there. So you can resize your vectors up front. But if general evaluation mode is off, I don't really need to resize the general vector because I'm never going to look at it. So but if there is, if general evaluation mode is on, then that vector of generals would get resized. The vector will all exist. But only if general evaluation mode is on, we resize it. An empty vector doesn't take that much room, about 24 bytes. A pointer, an allocated memory size, the capacity, and the current size. So it's about 24 bytes for an empty vector. No big deal. The general leave out mode is basically you keep track of how many troops are general deployed, how many troops. I think you can do it a couple of different ways. But at the end, you have to print out the general evaluation. I should look this up first. Now I got to look it up on here. Because I can't remember the exact output. So it's how many Jedi and Sith this general deployed and how many total survived. So it is possible. It is possible that there's generals that we don't know that we think the generals are on our side. But hey, maybe they're doing deployments for the other side also. So you keep track of how many Jedi were deployed by this general, how many Sith were deployed by this general. And at the end, you have to somehow be able to output how many survived. So you either have to keep track of either how many are still alive or how many have died. Either way, you can get the result at the end. Okay, so that's the general leave out mode, median mode. So median mode is keeping track of along the way. That's the median number of troops that have been lost on a given planet. Ooh, that sounds like whatever I do to make a median, I'm going to have to have median data in every planet. So my planet structure, my planet structure had the priority queue for the Jedi, priority queue for the Sith. And it's going to have to have data for median mode. Now if median mode is off, that variable or variables will still exist, we just won't fill it up with data. That's okay, not much wasted. Even though it's on a per planet basis, still not a big deal. There's a whole other video for fast running median mode because we use it in several different projects with several different themes. So there's a separate video for the fast running median that I'll put a link to when I'm done and this is uploaded. Okay, last thing that we're going to talk about today, which is another mode and it is going to stay in this video, is movie watcher. So movie watcher mode is a little bit hard to understand. Think of it this way. Here's our basic description. You are a very avid star wars fan and you want to watch the movie and you're going to write down a few notes about this planet that you're most interested in. So if movie watcher mode is on, there would need to be a separate movie watcher for each planet. So you're a movie watcher. You are watching, say, planet zero is your most interesting planet. So you're watching planet zero and what you're trying to do is you're trying to keep track of the most interesting attack or ambush that could have happened. We'll talk about what those are in a minute. Now, one thing about it is you cannot bring a laptop with you to the movie theater and have it shining in the eyes of the people behind you. That's very rude. So you have to just bring a notebook and write things down with a pencil on your notebook and you have basically O of one space. Okay. And remember, you're a per planet. So you have basically as the movie watcher per planet, you have O of n time and O of one memory, where n is defined as the number of deployments. To your planet. Okay. So you've got a fixed amount of memory and you've got a, you can only spend a fixed amount of time considering each deployment. Now, what we're going to do is we're going to discuss attack mode. Attack mode is when a Jedi arrives first and a Sith arrives after that. They could be the same timestamp, but just we're talking like sequentially. There has to be a Jedi on the planet, then a Sith arrives, then the Jedi attacks the Sith. In ambush mode is the opposite, the Sith arrives first. And what we're going to do is we're going to run through a big example using attack mode as our example. And what we're going to keep track of is some important data, but more importantly, we're going to keep track of our state. And this is a really, really powerful tool that's really important for some things. And it's what we're doing is called a state machine. So we're going to keep track of what state we are in. If you don't keep track of what state you are in, you can still do this, but it'll just be much more confusing. So we're going to have four states and I'll add the states in as we go through the example. Okay. So make sure I've got enough room. Okay. So I'm going to give a timestamp, which doesn't really matter. Sith or Jedi and the four sensitivity, because that's all that really matters for our movie watcher. Okay. So let's say timestamp zero. And this is all, and we're restricting ourselves to our planet zero. We're just assuming I'm only looking at the planet zero once. So at time zero, a Sith arrives, I'm just going to write S. I don't want to write Sith and Jedi for every one of those. Okay. So I've got a Sith arrives with a four sensitivity of 50. And the question you have to ask yourself for every one of these deployments that you see is, is this deployment interesting to you? Now you are a movie watcher who's paying attention to attack mode. This isn't interesting. It doesn't matter if there's a Sith, it's when there's a Jedi who arrives and then at some point after that, a Sith arrives. So this one is not interesting. Now what we can think of in our state machine is, I am in my initial state. I'm in my initial state. And if I see a Sith, I don't change anything. I don't change my state. I don't change any values at all. I just stay put. Okay. Time stamp one. A Jedi arrives with four fifty is that interesting. Yes it is. The start of the interesting stuff is that I'm not in my initial state anymore where no ones arrived and we could rename this state if we want to. Instead of calling it initial state, we could label it no one here or whatever you want. So we've got our initial state. When we see that Jedi, I'm going to remember, I've got to remember the time stamp and the four sensitivity of this Jedi. And I'm going to have to change my state. So my state is going to change to let's call it the Cine Jedi state. Okay. I'm in the Cine Jedi state. I made a state transition. How did I make a state transition? I have a variable which changes its value to tell me what state I'm in. We'll talk about what kind of variable in a few minutes. All right. So I got my initial state. I've got my transistors to my Cine Jedi state. And I've got to keep track of this one. I've got to keep track of the fact that I've got a Jedi with four fifty at time one. All right. Now next deployment. Time to. I see another Jedi with four forty. Question is, is this interesting? Yes it is. It doesn't cause me to change state. But remember, I'm interested in the most exciting fight. The most exciting fight is going to be the lowest Jedi with the highest Sith arriving after that. So this one is in fact so interesting that it will replace the old one. I don't need extra variables. I just update my variables. I say, hey, I'm still in the same state. Instead of a Jedi with four forty time or four fifty time one, I've got a Jedi with four forty at time two. So I update my best Jedi's force and my best Jedi's time. Okay. Now time three. Sith appears with four twenty. Is this interesting? No. Because when this Sith arrives, this Sith will hide behind a rock and will not fight because that Jedi is more powerful. No fight happens. That's not interesting to me from a movie water. It's more in the Jedi or when the Sith hides behind a rock. Okay. So next time time four. Time four I get a Sith with four eighty. Is that interesting? Yes. It's very interesting because I now have a pair here. I've got a Jedi arrived at some point later. These could be all time stamp two. It wouldn't matter. But it's arrival first. So there was a Jedi arrived after the Jedi arrived a Sith with a higher equal to or higher force sensitivity arrived. So now I've got to make a transition to a new state. Where I've seen both. And I would have to keep track of both. I have to remember, oh, my best Sith has a force sensitivity of eighty arrived at time four. Okay. So that caused me to do a state transition and update a few variables. All right. Now time five. Let's say a new Sith arrives with force one hundred. Is that interesting? Oh, yeah, that is. Oh, wait, I forgot it. I forgot a state transition. You've probably been noticing that. I forgot it. When we did, when we went from Jedi to better Jedi, we did, we stayed in the same state. We didn't change states. That transition occurred because we had a better Jedi. This transition occurred because we had our first Jedi. And this transition occurred because we got our first Sith that would cause a fight. Okay. So now when I see this new Sith, hey, I've got a better potential fight here. Instead of a potential difference of forty to eighty, which was forty. So this used to be a difference of forty. But now I've got a potential fight with a difference of sixty. A difference of sixty is better. So what I'm going to do is I'm going to stay in my same state. But I saw a better Sith. So I'm not going to change state, but I'm going to update my best Sith is Force 100 at time five. Not eighty at time four, 100 at time five. So we get, forget that one. We remember this one. Okay. Now here's where it actually gets tricky. Okay. Time six. We see a Jedi arrive on this planet with a Force 10. Is that interesting? Well, if that Force 10 could attack the Force 100, that would be really interesting. But that can't happen. This Jedi can only be matched up with a Sith who arrives at some point afterward. So I can't replace my best Jedi. But this could potentially be a more interesting fight. So I've got to remember it. I need a new state. I'm going to have to transition to a state where I've got a maybe a better Jedi. So I've got this new state. I transition over here because I saw a better Jedi. Now if the movie were to stop at this point, I would print my 60 pair between this one and this one. I would say, hey, a movie watch would like to see an attack on planet zero with a Jedi at time two and a Sith at time five. So if the movie were to end here, I've got to report the old pair. But I've got to remember, hey, at time six, there's a Jedi with Force 10 who might be better. So I need a couple of variables for that. I've got him on my maybe Jedi. Now what happens if I saw at time seven, I saw Sith with Force 70. Okay. So that one was potentially interesting. Now the Force 70, that would be a difference of 60, but I've already seen a difference of 60. You go with the earliest one. So if there's a tie on the difference, you always go with the earliest one. So that's not interesting. Okay. At time eight, I get a Sith arrives with a Force of 80 and now that's strictly better. That's a difference of a 70, that's more interesting than 60. So what I'm going to do is I'm going to transition back to this state. And now this, my maybe Jedi becomes my best Jedi. This becomes my best Sith. I forget about that one and that one. And now if the movie were to end, that's the one I would print. And I have transitioned back to the scene both because I saw a better, whoops, while that was raised that. Okay. I transitioned backwards here because I got a better difference. My pens get a little sloppy there. So I made the, so I made that transition because I saw a better difference. In the 4.50 values. Now what if, let's do one more. What if I had at time nine, I had a Sith with Force 90? Oh, this one's better. I would just replace that one and I'd stay in the, in the scene both state. So that one wouldn't cause a state transition. It would just stay there. Now what do we do for these variables? Okay. So for an attack mode, I would need to know, or is it right? This is on a per-plant basis. So I'm going to need to know my best Sith time and force, my best Jedi's time and force, my maybe Jedi's time and force. That's six variables. And I would also have to remember which attack state I'm in, which state of my state machine I'm in. Now how do we make a variable at that type? You could make a string, except strings are slow to compare. Because you have to compare character by character. So see if, like if I say like, if state equals equals double quote initial, if my state really is initial and you say are these equal, it would compare the lengths because if the lengths are different, it's different. Then it would have to compare I am I T I A L. I'm an oh and every time so that was that was like eight comparisons. But for every one of those letters, I also had to check am I at the end of the string? No, let's increment an iterator or a pointer. Let's increment another one. So we're talking like 30 operations to compare two seven character strengths. You could make them characters, which would be slightly more readable. You could make them integers and you could look at my code. My code might say, ah, if the state is equal to 873,212, then do this. And that makes no sense at all. So we need a new type of variable here. Enum. Okay, so enum class is more powerful than an enum, a little bit cooler, more C plus plus C. So we could make an enum class like state. And then what we do, so that's the name of the type. We are creating a new type. It's like creating struct, except instead of saying this is the collection of things it can contain, we are going to make a list of the values it can contain. So then we do curly braces and then we could make a list of states like initial. I like to use capitals for things I create because then it's impossible to confuse them with stuff that the STL create. So when I create variables, I do a more case, but for types, my types always start with a capital letter. So I always know it's a user declared type. So I've got my type state. It can take on the new value initial scene Jedi. Scene both. And maybe maybe better. And I'm going to make this generic because remember I've got to do the same thing for attack mode and ambush mode. So they will have different variables, but the same idea. So let's just call this is the maybe better state. Let's keep it generic curly brace. So I'm going to call it. So then what I could do is I could declare later on, I could say, hey, I've got a variable of type state called state. And I said it equal to state colon colon initial. So we have to say the type name colon colon the value name. And then we can use it in F. So I like to let it run. I can say like if. Like yes, what would I be doing here? So that's my state equals equals state colon colon initial. And then I could do inside of that, I could say like if the deployment type is equal equal to Jedi. Or I could even do something I could go a step further. And I could say, hey, because I read it in, right? I read it in as a string. But then I remember it as an enum. Like if deployment type is equal to side, whoops, I don't select that all equals equals side colon colon Jedi. I could do have any numerated type for a type of deployment. So I read it in as a string, but I remember it as an enum or type. That one's not important. You don't have to do that. But you do want to do the states as an enum. Okay, last thing we want to talk about is ambush mode. Am bus mode is going to be a lot like this except who you've seen first. And oh wait, scene Jedi. Oh, that's see that scene Jedi is generic. Okay, so instead of scene Jedi, let's go back and change that instead of scene Jedi, because we got to make that generic, right? Scene, let's call it scene one. And scene one, right? So I've seen one, I've seen the first one. Like an ambush mode, it would be that I've seen one. I've seen a sif. Okay, so I'd be a little bit more generic. That's better. So thought of that to begin with. Haven't looked at my code for this in a while. Okay, so we've got, so if we're doing ambush mode, we would still have the same. Many of the same things. We would still have a state variable for ambush mode. We would have our best sif, our best Jedi time and force. But instead of our maybe Jedi for ambush mode, we would have a maybe sif. Force and time. Okay, did a lot for this. You'll have a lot to watch. I'm going to go find my window. Where my YouTube window go. Okay, so I'm going to finish this up and add some links to it and I'll add some timestamps for where the interesting parts are. Good luck on the project.