 I also go in everyone happy Thursday. Want to go ahead and make quick video about how to do P2C. So, this is just an overview of how combinations work. So, if you're sort of confused about how recursion works and how we can do this in LC2K, this overview should basically just cover how combinations work and then how we can translate that logic over to assembly code. So, first things first, let's talk about first of all what a combination is and how we can think about it in terms of C code. So, right here I have this function called combinations. Let's go ahead and change this to N and R. So, essentially we're going to go ahead and calculate the combination of N comma R. And the way we can define combinations of N comma R. So, let's just go ahead and say what we call combinations of N comma R. What is that equal to? What that E is equal to is the combinations of N minus 1 plus combinations of N minus 1 or minus 1. So, just refreshing about how recursion works. So, you can sort of think about this like traveling down a staircase. So, let's assume real quick that we are at the top floor of some building. We'll just go ahead and draw a door right here, some windows like this. And we're at the very top of this building. And we want to go ahead and basically find an answer to a question. Let's say for example, we want to know what is the temperature in the basement of this building? Well, we don't know that because we're at the top floor. So, we have to go to this thing called the base case in this case, the basement building, right? We're going to travel down a staircase, say, are we at the basement? No, we're not. Keep on traveling up until we hit this base case in the basement. And that case, cool, we know the temperature, right? And then we can use that information to go ahead and build up and solve other subproblems through to calculate. This analogy is kind of weird, but I think the way you can visualize this is sort of like we traveled down, there's a curse of stack, right? We traveled down the building and then we go ahead and we use our solution at the base case. So again, going to the basement in this case. And we can use that solution to go ahead and leverage future solutions, right? So I don't have a problem statement for this, but let's just go ahead and assume that we have to go to the basement. We find some information. We can then use the information to go ahead and solve maybe the problem, the first row of the building, right? And now that we've solved this problem, we can go ahead and solve this problem right here. And then we can solve the problem on the third story and then we can finally use the information to solve the problem on this story right here, aka what we called the function from. So what does this look like in terms of combinations? Well, let's go ahead and talk about combinations of three combinations. So I'll go ahead and say three C two like this. This basically just means combinations. So say right here, combination of three, two. So it is for a sort of like a treat question. So we first need to go ahead and determine, cool, combinations of three common two. What is that equal to? And that's going to be equal to combinations of n minus one. Pretty I put it in R right here, so about that. This, so we'll go ahead and say combinations of n minus one, which is going to be three minus one, it's going to be two. And then R is going to be two plus combinations of two comma one. Again, all I'm doing here is taking the value pass in. So three in this case, subtracting one, two, two minus one, you got one. So in order for us to solve combinations of three comma two, we have to go ahead and solve basically again the building analogy, we have to go down a floor and solve that problem. So for this, we have to go ahead and solve two combination two. And we also have to solve two combination one. And then from that, we have to go ahead and solve those sub problems. The question is, when do we actually stop? Like when do we stop recursing in our analogy before we talked about, oh, we hit this basement, right? That's going to be our base case. Our base case is basically saying, okay, we don't need to travel further down the building, right? We've already hit our base case. We now have a solution for a given step. So for the combination question, our base case is going to be if our value is zero, our value of n is equal to our value of r. So in this case, this right here is going to be a base case. That is because our value of n is two and value of r is going to be two. So in that case, we can go ahead and say that, cool, two equals two, that's our base case. There's no more recursion that has to happen at this step. However, at this step, there's no base case, right? For two comma one, that is because two is not equal to one and one is equal to zero. So in this we have to keep on recursing down, right? We have to go ahead and solve one combination one as well as we could go ahead and decide one combination zero. These two are both going to be base cases. That is because one equals one this case. So we can stop going down if it's that basement floor and then right here are equal zero. So we don't have to recurs down any further. We can then use these solutions to get better solution, right? If I asked you what is two combination one, we don't know the answer, right? If I asked you what is one combination one, we know the answer from the base case. So essentially we're doing here is you're going to go ahead and say cool, one combination one, that value, I'll go ahead and use green for this. The value of this is just going to be one. I'll put a one right here, same thing for this and same thing for this. That is because they're all base cases. We also know, and go ahead and pull this back up. That combination of two comma one is equal to combination of one comma one plus combination of one comma zero. We just want to add and solve combination of one one and one combination zero like this. So we know that this value right here is going to be a one and this right here is going to be a one. So let's do that. We now know that two combination one is going to be one plus one in this case, aka two. We also know that combination three two is combination two two plus combination two one. We've already decided what two two is because that was a base case. It's going to be one and we just want to have calculated combination of two one, which is going to be two. So if one plus two, and it's going to give us three. So our final answer is going to be three. Now notice here how this is a tree question and this is really important for understanding how this our code should be structured. The idea here is we went ahead and we solved from left to right. And if you guys have been taking two 81 yet, don't worry about it. I believe we do cover trees in 280, but this is a good way of you to problem, right? Basically here, we want to go ahead and solve all of the left sub problems first. So first one ahead and solved two combination two. We can't solve anything else because it's a base case. So we go back up the root right here and then we solve this combination problem right here. Two comma one. We don't know the solution immediately. Let's go ahead and solve. It's left leaf problem. So one combination one, we solve that. It's a base case. Cool. Return that. Solve the right problem right here. Cool. We solve that. And now we have a solution to this. And then we sort of work away back up the tree. That's something you can visualize or curse in the sense. So I've had to run through on the actual C code. What's happening? Again, pull this this side. Cool. Yeah. So again, we go ahead and we calculate combination three two. So the combination of three minus one is going to be two, comma two plus combination of in this case two comma one. We go ahead and we next calculate this right here. Combination two comma two. We first go ahead and check to see is it a base case. It is right here. So we go ahead, smile face, where the base case. Go ahead and say it's going to be a one right here. Next thing we do is calculate again, this right problem right here. So do combination of two comma one equal to combination of one comma one. What's combination of one comma zero. Let's go ahead and calculate this one first. This is going to be a base case. It's going to be a one and same thing for this right here. That's going to be a one as well. Consisting, I guess. Cool. We get a one right here. One right here. When we return back up, we're going to go ahead and take these values of one plus one. Get a two right here. We've now resolved combination of two comma one to be a two. And then we've already resolved this to do one plus two. Now let's figure it out, it's a bit confusing. How do we know, right? When we returned from combinations to one, how do we know there was a one right here? Back and get pretty confusing, right? Like where are we storing this one at exactly? Can we put it in a register? Like what are we doing exactly? Here's the issue, right? If we're making, let's say for example, 100 returns of calls, which you can on very large inputs, like 14 combination seven, then we don't have enough registers to use, obviously. You only have eight registers and most of them we're going to be using for storing the dice and stuff like that. So we really don't have enough values for registers to store values. So how do we work around that? What we're going to do here is use a stack. The stacks are pretty powerful tool. So visually what it looks like is right on here. We have our text, we have our data, and then we have our stack right below here. So our text is going to be our instructions. So say for example, it's like on a BQ, 00 like label, right? A bunch of text, right? And then down here might as well data, like 1.fil 1, all this stuff right here. Right below this is where stacks don't live. And our stack is useful for saving information we need later on. So on the stack we can stay stuff like our current value of n, our current value of r, our address we want to return to you, as well as what is our current solution so far. So let's go ahead and talk about how we can use a stack to go ahead and implement P2C. All right, so let's go ahead and work through the example three times a two, but this time we're going to visualize what's happening on the stack. So let's go ahead and put inputs in three comma two. So the first thing we're going to go ahead and do, and this is the first step you should always be doing, check your base cases. So in this case, I'm going to put right here, n is equal to three, and r is equal to two. So we're going to do first is check to see are either of these things true. Does n equal r? Nope. Is r zero? Nope, it isn't. Cool. Well, we're then going to do, and I'm going to draw my stack. Let's do it right here. The stack is so far empty, right? Remember, we have our text right here, we have our data right here, we have our stack. Our stack is going to have nothing on it so far. What we're first going to do is go ahead and save n to the stack. So save n to stack. So I want to say n, I mean the current value. So it's going to be a three. We're then going to go ahead and save r to the stack, which is a two. We also want to go ahead and save our return address. So return address to the stack. After that, we're then going to go ahead and calculate, let's go ahead and put steps right here. There's a lot of sticky track ups right about that steps. So one save relevant, can't spell, save and save important info to the stack. Cool. So we do that step zero, I guess, is check the base cases. So again, before we actually save anything to the stack, we want to make sure like, do we actually have to recurs further, right? In the case of, let's say for example, 2,2, there's no need to make any more recursive steps for that, right? We already know that 2,2 is a base case, which means we don't have to go down any further. We pull this back up real quick. 2,2, it had no like leaf children. It basically means that from that, there's no value. It needs to calculate, right? It's a base case. Whereas 2,1, it's not a base case, right? We have to know what 1,1,1 is zero is. For us to calculate that. So again, 3,2 check our base cases, they're not true, they aren't true. So cool, we'll go ahead and save NR in our return address to the stack. And we'll then go ahead and call a subroutine. So go ahead and put this in the work. Call subroutine. So, yeah, I don't know how to spell it. Call. You guys are laughing at me. I can't spell, sorry about that. I think that's right. Cool. Who cares? Call subroutine to calculate combinations of N minus 1R. So in this case, we need to go ahead and decrement N. So that's going to look like us basically doing something like, up on right here, N equals N minus 1. And we're going to go ahead and repeat that process over and over again until we hit some base case. So in this case, what we did is we went ahead, we saved 3 to the stack to the stack, return address to the stack, and we went ahead and we tried to calculate 2,2. Perfect. We jump into 2,2. So our N is out going to be 2, or R is out going to be 2. Remember, 3 and 2 are saved to the stack, but our values, the registers that hold N and R are going to be changed. So it's our duty to recover those once you return from this function. So once we do this, if N is 2R is 2, we first go ahead and check our base cases. N equals R is true. So we actually want to do here is instead of doing steps 1 and 2, we're instead going to go ahead and put indentation here. If base case is true, we are then going to load in the value of 1 into register 3. And then return back to return address. So what does it look like? In this case, it looks like we go ahead, we first went ahead and said combinations of 3,2. That's not base case. We're going to take these values right here, push into the stack alongside the return address. We're going to go ahead and say N equals N minus 1 and go ahead and calculate combinations of N minus 1R. So go ahead and calculate combinations through counter 2. We check to see if it's a base case. It is a base case. We're then going to go ahead and the base case has to turn 1. So we're going to go ahead and put the value of 1 into register 3, just like that. So our next step is to go ahead and after we calculate this is, we return back to this, every comma 2. Remember here, we said the value of this is dependent on 2 comma 2 plus 2 comma 1. So we're going ahead and we solve this for 1. The issue here though is that we can't guarantee that register 3 is going to be change or we're going to say the same, right? It's going to be changed eventually, right? Some other recursive calls going to modify the base case and it's going to change that value. So we can't have that there. What we're going to do instead is, we're then going to make this new section for combinations of N minus 1R minus 1. For this, we're going to go ahead and push our result of register 3 to the stack. It's sort of like our running total so far. So in this case, that's going to be 2 comma 2, right? That's what we have so far. There's two parts to making combinations through comma 2. There's N minus 1R and N minus 1R minus 1. We've gone ahead, we calculated N minus 1R right here. We've gone ahead, we put that inside of register and then we returned, we went ahead and then pushed that to the stack so we can see for later, right? So now we don't really care what's inside of register 3 so we've gone ahead and pushed the stack. So go ahead and put this right here. Push, read 3 to the stack. So in this case, it's just going to be a 1. After that, what we do is we go ahead and we go ahead and calculate N minus 1R minus 1. We've already had N decremented to 2 right here. We have to go ahead and decrement R to be a 1 and then we go ahead and calculate again, right? We're now looking at this function right here. We are now in this scope, right? We're going to go ahead and get a pen call out. Feel in orange, there we go. We're looking right here. We have to go ahead and again repeat that entire process over again. We first go ahead and look to the left leaf and then the right leaf. So the left leaf, we're going to go ahead and again, look at this right here and check our base cases. This is a very hard thing to grasp. I'll make a few analogies here. There's this idea called the recursively buffade and basically that means when I'm saying combinations as you count one, I'm sort of saying, okay, cool. I don't know the answer yet, but one of my base cases will and they can build up a solution that I can use. So even though there's no solution to come of one, we're basically calculating that on the fly. And once that we get a return value that is some number, right? Once one comma one returns, we can then go ahead and calculate one comma zero and then we can go ahead and get an answer. And that's the goal. We don't immediately know the answer of two comma one. We have to go ahead and keep on recursing further and further down until we hit a base case or in the building analogy, we go down off staircases, we can go to the basement eventually, we can hit the base case. So we go ahead, we go to combination of one comma one, we do these steps now because we're calculating n minus one r. So we first go ahead to our base cases and equals r. We repeat that exact same process over again. So in this case, we go ahead and again, we put one inside register three. So push register three to the stack, which is going to be a one in this case. And then we go ahead and then we go ahead and calculate n minus one r minus one. So we've decrement r. So we're going to go ahead and change. So it's going to be a one right here. Go ahead and calculate r. It's going to be a zero. And from that, our base case will fight again because r is going to be zero. So in that case, we go ahead and this is where it gets bit tricky, right? We can now combine two solutions into one. The question is how do we do that? Remember, from n minus one r, we went ahead and we pushed our current solution to the stack, right? Look right here. Save current results to the stack. So when I return from one comma one, I put a one inside register three. And before did any calculations here, I went ahead and I pushed this one to the stack. So our stack has a one in it right now. When I go ahead and I return from this base case right here, it's going to be inside register three, right? The base case result is. So what we're doing here essentially is we're going to say the value inside register three, which is kind of in sense, the return value of combinations of one comma zero plus the value. Let me go ahead and end this on the stack so far. Remember, we pushed this one to the stack. So we have to go ahead and pull it off the stack, right? So what's that look like? So basically we have the stack plan. And the way this works, our stack again begins at m plus n where m decides a text and n is the size of our data. Sorry, m decides a text and static cool. And if we add something to text, we take it ahead and have a stack plan, which basically keeps track of where we currently at in terms of like what level of the stack are we at? Whatever we pop something off the stack, we're going to go ahead and basically get that value and that commenter stack plan by one. If you want to go ahead and add something to the stack, we'll go ahead and add one to our stack plan. So in a sense, what we're doing here is we put it on the stack. It's like right here. We go ahead and we grab it and decarment our stack plan. We're now we're down here. Cool. So we go ahead and we go ahead and make this big cleaner erase all this stuff. Cool. So on the stack, we have this one floating around from this right here, right there. We just went ahead and we returned from this function right here. We returned a one inside register three. That's an R by the way. Cool. There's a three has a one in it like this. So if you go ahead and take registered three's value plus the value on the stack, we're going to get to and that's then going to be the value of this right here. After that, we can then go ahead and take this to right here and add it to the next value on the stack. So this to right here plus the one in the stack and then we get three. So as a bit confusing, balls go ahead and highlight or quick, but we just did. We go ahead and erase all this stuff for a quick. Cool. What I erase to here. Yeah. Okay. So we started off by saying want to go ahead and calculate combination of three common two for us to do that. We need to know the answer of combination at two common to in combination at two common one. So let's go ahead and work from left to right. We first go ahead and we solve combination to come to we first check to give the base case sit base case is hit. So we go ahead and we put a one inside of us are three return that value back here and put it on the stack. We go one right here. We then go ahead and we want or concerned about this part of the function now. Once we get to here, we go ahead and repeat that exact same process over again. We go ahead and we calculate what combination of one common one is against the base case. So we go ahead take this one, put it inside, return three return back over here and then put it on the stack. So I go ahead and put this yellow. That's going to be that one right here. And then we go ahead and we calculate the right hand side. The right hand side is going to be a base case right here. One C zero is going to be a base case. So we're going to go ahead and put a one inside. Right. Right. So we're going to go ahead and say combination the two kind of one is going to be equal to register three's value plus the first value in the stack. That's a value right on the stack remember we're also saving our value of n value of r and our return address. I'm not drawing it out to make it seem a bit easier, but there are going to be other values here on the stack. So consider that as well like what position the rat. So it's really good idea to go ahead and be consistent about how you push up the stack. So maybe you're pushing n then our return address and then maybe the value something if you have it there. Just be consistent. So we have r one, sorry r three is going to be a one this case plus this value off the stack. We're going to pop our stack right here, put it right here, get a one and then we have one plus one is two and that's going to be inside register three. We then went ahead and pop this value up the stack and then we again or sort of like climbing back up the building. So we go ahead and go back over here and say r three plus this value right here on the stack r three plus one is two plus one and that is three. And then we return back to where we're called from. So I hope this helped you guys out a little bit. If you have more questions about it, feel free to drop in the comments and try and think as anything else that's helpful to talk about. I can't think of any my main tips for the project again, understand the base case and what stops the person going back to the tree example. Remember how we went from left to right. We started calculating n minus one r and then once we did that, we went ahead and started going to the right tree and then we started going to the left as much as we could. By the left, I mean we try to calculate n minus one r first and then we try to calculate n minus one r minus one first. We're going ahead and we're building up small solutions to go ahead and solve the problem. Base cases can combine to go ahead and essentially solve the problem. One pattern is helpful to observe too. It's going back. Can I control see this? Okay, cannot. So we have three two, right? Think this. Remember, it's child over here is going to be two two. Two choose two to combination two same thing over here. We had what was that? One combination two, which is going to have children. Sorry, it's two combination two. No, sorry, two combination one. There we go. That's going to be one combination one and this is going to be one combination zero. Right. And again, this is like not needed for the project, but it's helpful to visualize it this way. The right hand side of the tree in this case, they're both going to be base cases. This is the only instance where it will happen where they're both going to be base cases. In this case, this value is going to be a two, right? Because we have one one right here. Again, we save this value on a stack and add to this value, we get a two. And then once you solve this part of the tree, everything else should already be solved, right? Because we already solved this left hand side of the tree right here, right? We already said this is going to be a one. So all the works being done, we're just returning now and adding, we're popping up the stack, adding that to our current value, returning, adding value from the current stack to our current value, returning and repeat that process over again. We're essentially saving the left hand side of the tree to the stack the entire time. Everything over here is going to be on a stack essentially. And when we return, the right hand side is basically saying, I have a current solution, I'm going to add the stack to it into one solution and then go back up the stack and pull the next value and add to that. And once you understand how that works, the program becomes so much easier to write. So my advice for the program is check base cases, calculate n minus 1, calculate n minus 1, r minus 1 and then combine them and return. So returning back to the previously function I called it. So in the case of 2,1, we had two children, right? We had 1,0 and then, sorry, we had 1,1,1,1,0, both base cases, right? Those two combined into one function, right? Some function called those two other functions, right? So I just returned to the function that called that and then build the solution up from that. So I hope it's helpful. Any questions drop in Piazza. Let's do on Tuesday, I believe, on the 26th. So you guys got plenty of time to do this. Good luck. Yeah. Any questions drop in the comments section. Piazza, we should look at them. All right. Good luck in the project.